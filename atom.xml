<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J.Lee&#39;s Town</title>
  
  <subtitle>Life is Fantastic</subtitle>
  <link href="https://www.jaylee.top/atom.xml" rel="self"/>
  
  <link href="https://www.jaylee.top/"/>
  <updated>2020-11-07T05:31:55.142Z</updated>
  <id>https://www.jaylee.top/</id>
  
  <author>
    <name>J.Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu18.04</title>
    <link href="https://www.jaylee.top/2020/11/07/Ubuntu18.04%E5%AE%89%E8%A3%85/"/>
    <id>https://www.jaylee.top/2020/11/07/Ubuntu18.04%E5%AE%89%E8%A3%85/</id>
    <published>2020-11-07T05:21:41.000Z</published>
    <updated>2020-11-07T05:31:55.142Z</updated>
    
    
    
    
    <category term="工具技能" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>C++代码风格</title>
    <link href="https://www.jaylee.top/2020/11/03/C++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://www.jaylee.top/2020/11/03/C++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2020-11-03T02:24:33.000Z</published>
    <updated>2020-11-07T05:31:55.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h1><p>成员函数缺省参数值通常写在头文件或者源文件二者之一的地方，通常写在源文件中，但是会造成后果，没太看明白。</p><h1 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h1><p>参考文章：<a href="https://blog.csdn.net/guyue35/article/details/46775211">https://blog.csdn.net/guyue35/article/details/46775211</a></p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缺省参数&quot;&gt;&lt;a href=&quot;#缺省参数&quot; class=&quot;headerlink&quot; title=&quot;缺省参数&quot;&gt;&lt;/a&gt;缺省参数&lt;/h1&gt;&lt;p&gt;成员函数缺省参数值通常写在头文件或者源文件二者之一的地方，通常写在源文件中，但是会造成后果，没太看明白。&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="C++" scheme="https://www.jaylee.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>算法移植ROS笔记</title>
    <link href="https://www.jaylee.top/2020/11/01/%E7%AE%97%E6%B3%95%E7%A7%BB%E6%A4%8DROS%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.jaylee.top/2020/11/01/%E7%AE%97%E6%B3%95%E7%A7%BB%E6%A4%8DROS%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-01T07:34:49.000Z</published>
    <updated>2020-11-01T07:40:30.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拟合算法"><a href="#拟合算法" class="headerlink" title="拟合算法"></a>拟合算法</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mincd_fitting = minCDFitting();</span><br><span class="line">m</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拟合算法&quot;&gt;&lt;a href=&quot;#拟合算法&quot; class=&quot;headerlink&quot; title=&quot;拟合算法&quot;&gt;&lt;/a&gt;拟合算法&lt;/h1&gt;&lt;h2 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h</summary>
      
    
    
    
    <category term="研究生" scheme="https://www.jaylee.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"/>
    
    
    <category term="lidar" scheme="https://www.jaylee.top/tags/lidar/"/>
    
  </entry>
  
  <entry>
    <title>Eigen学习笔记(二)</title>
    <link href="https://www.jaylee.top/2020/10/27/Eigen%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>https://www.jaylee.top/2020/10/27/Eigen%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/</id>
    <published>2020-10-27T02:18:20.000Z</published>
    <updated>2020-11-07T05:31:55.140Z</updated>
    
    <content type="html"><![CDATA[<p>转载自: <a href="https://blog.csdn.net/xuezhisdc/article/details/54645238">https://blog.csdn.net/xuezhisdc/article/details/54645238</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 - http://eigen.tuxfamily.org/dox/AsciiQuickReference.txt</span></span><br><span class="line"><span class="comment">// 一个关于Eigen的快速参考</span></span><br><span class="line"><span class="comment">// Matlab和Eigen的对应用法</span></span><br><span class="line"><span class="comment">// Main author: Keir Mierle</span></span><br><span class="line"><span class="comment">// 注释：张学志</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; A;               <span class="comment">// 固定大小的双精度矩阵，和Matrix3d一样。</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, Dynamic&gt; B;         <span class="comment">// 固定行数，列数为动态大小</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, Dynamic, Dynamic&gt; C;   <span class="comment">// 行数和列数都是动态大小，和MatrixXd一样。</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>, RowMajor&gt; E;     <span class="comment">// 行优先的矩阵（默认是列优先）</span></span><br><span class="line">Matrix3f P, Q, R;                     <span class="comment">// 3x3 的浮点型矩阵</span></span><br><span class="line">Vector3f x, y, z;                     <span class="comment">// 3x1 的浮点型矩阵（列向量）</span></span><br><span class="line">RowVector3f a, b, c;                  <span class="comment">// 1x3 的浮点型矩阵（行向量）</span></span><br><span class="line">VectorXd v;                           <span class="comment">// 动态大小的双精度列向量</span></span><br><span class="line"><span class="keyword">double</span> s;                            </span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="comment">// Eigen          // Matlab           // 注释</span></span><br><span class="line">x.size()          <span class="comment">// length(x)        // 向量的长度</span></span><br><span class="line">C.rows()          <span class="comment">// size(C,1)        // 矩阵的行数</span></span><br><span class="line">C.cols()          <span class="comment">// size(C,2)        // 矩阵的列数</span></span><br><span class="line">x(i)              <span class="comment">// x(i+1)           // 访问向量元素（Matlab的下标从1开始计数）</span></span><br><span class="line">C(i,j)            <span class="comment">// C(i+1,j+1)       // 访问矩阵元素</span></span><br><span class="line"></span><br><span class="line">A.resize(<span class="number">4</span>, <span class="number">4</span>);   <span class="comment">// 如果开启了断言，将会出现运行时错误。</span></span><br><span class="line">B.resize(<span class="number">4</span>, <span class="number">9</span>);   <span class="comment">// 如果开启了断言，将会出现运行时错误。</span></span><br><span class="line">A.resize(<span class="number">3</span>, <span class="number">3</span>);   <span class="comment">// 运行正常，矩阵的大小没有变化及。（A的行数和列数都是固定大小的）</span></span><br><span class="line">B.resize(<span class="number">3</span>, <span class="number">9</span>);   <span class="comment">// 运行正常，仅动态列数发生了变化。（B的列数是动态变化的）</span></span><br><span class="line">                  </span><br><span class="line">A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,     <span class="comment">// 初始化A。元素也可以是矩阵，先按列堆叠，再按行堆叠。</span></span><br><span class="line">     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,     </span><br><span class="line">     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;     </span><br><span class="line">B &lt;&lt; A, A, A;     <span class="comment">// B 是3个A水平排列</span></span><br><span class="line">A.fill(<span class="number">10</span>);       <span class="comment">// 将A的所有元素填充为10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen                                    // Matlab                       注释</span></span><br><span class="line">MatrixXd::Identity(rows,cols)               <span class="comment">// eye(rows,cols)               //单位矩阵</span></span><br><span class="line">C.setIdentity(rows,cols)                    <span class="comment">// C = eye(rows,cols)           //单位矩阵</span></span><br><span class="line">MatrixXd::Zero(rows,cols)                   <span class="comment">// zeros(rows,cols)             //全零矩阵</span></span><br><span class="line">C.setZero(rows,cols)                        <span class="comment">// C = zeros(rows,cols)         //全零矩阵</span></span><br><span class="line">MatrixXd::Ones(rows,cols)                   <span class="comment">// ones(rows,cols)              //全一矩阵</span></span><br><span class="line">C.setOnes(rows,cols)                        <span class="comment">// C = ones(rows,cols)          //全一矩阵</span></span><br><span class="line">MatrixXd::Random(rows,cols)                 <span class="comment">// rand(rows,cols)*2-1          //MatrixXd::Random 返回范围为(-1, 1)的均匀分布的随机数</span></span><br><span class="line">C.setRandom(rows,cols)                      <span class="comment">// C = rand(rows,cols)*2-1      //返回范围为(-1, 1)的均匀分布的随机数</span></span><br><span class="line">VectorXd::LinSpaced(size,low,high)          <span class="comment">// linspace(low,high,size)&#x27;     //返回size个等差数列，第一个数为low，最后一个数为high</span></span><br><span class="line">v.setLinSpaced(size,low,high)               <span class="comment">// v = linspace(low,high,size)&#x27; //返回size个等差数列，第一个数为low，最后一个数为high</span></span><br><span class="line">VectorXi::LinSpaced(((hi-low)/step)+<span class="number">1</span>,      <span class="comment">// low:step:hi                  //以step为步长的等差数列。((hi-low)/step)+1为个数</span></span><br><span class="line">                    low,low+step*(size<span class="number">-1</span>))  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Matrix 切片和块。下面列出的所有表达式都是可读/写的。</span></span><br><span class="line"><span class="comment">// 使用模板参数更快（如第2个）。注意：Matlab是的下标是从1开始的。</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab                        // 注释</span></span><br><span class="line">x.head(n)                          <span class="comment">// x(1:n)                        //前n个元素</span></span><br><span class="line">x.head&lt;n&gt;()                        <span class="comment">// x(1:n)                        //前n个元素</span></span><br><span class="line">x.tail(n)                          <span class="comment">// x(end - n + 1: end)           //倒数n个元素</span></span><br><span class="line">x.tail&lt;n&gt;()                        <span class="comment">// x(end - n + 1: end)           //倒数n个元素</span></span><br><span class="line">x.segment(i, n)                    <span class="comment">// x(i+1 : i+n)                  //切片</span></span><br><span class="line">x.segment&lt;n&gt;(i)                    <span class="comment">// x(i+1 : i+n)                  //切片</span></span><br><span class="line">P.block(i, j, rows, cols)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols) //块</span></span><br><span class="line">P.block&lt;rows, cols&gt;(i, j)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols) //块</span></span><br><span class="line">P.row(i)                           <span class="comment">// P(i+1, :)                     //第i行</span></span><br><span class="line">P.col(j)                           <span class="comment">// P(:, j+1)                     //第j列</span></span><br><span class="line">P.leftCols&lt;cols&gt;()                 <span class="comment">// P(:, 1:cols)                  //前cols列</span></span><br><span class="line">P.leftCols(cols)                   <span class="comment">// P(:, 1:cols)                  //前cols列</span></span><br><span class="line">P.middleCols&lt;cols&gt;(j)              <span class="comment">// P(:, j+1:j+cols)              //中间cols列</span></span><br><span class="line">P.middleCols(j, cols)              <span class="comment">// P(:, j+1:j+cols)              //中间cols列</span></span><br><span class="line">P.rightCols&lt;cols&gt;()                <span class="comment">// P(:, end-cols+1:end)          //后cols列</span></span><br><span class="line">P.rightCols(cols)                  <span class="comment">// P(:, end-cols+1:end)          //后cols列</span></span><br><span class="line">P.topRows&lt;rows&gt;()                  <span class="comment">// P(1:rows, :)                  //前rows行</span></span><br><span class="line">P.topRows(rows)                    <span class="comment">// P(1:rows, :)                  //前rows行</span></span><br><span class="line">P.middleRows&lt;rows&gt;(i)              <span class="comment">// P(i+1:i+rows, :)              //中间rows行</span></span><br><span class="line">P.middleRows(i, rows)              <span class="comment">// P(i+1:i+rows, :)              //中间rows行</span></span><br><span class="line">P.bottomRows&lt;rows&gt;()               <span class="comment">// P(end-rows+1:end, :)          //最后rows行</span></span><br><span class="line">P.bottomRows(rows)                 <span class="comment">// P(end-rows+1:end, :)          //最后rows行</span></span><br><span class="line">P.topLeftCorner(rows, cols)        <span class="comment">// P(1:rows, 1:cols)             //左上角块</span></span><br><span class="line">P.topRightCorner(rows, cols)       <span class="comment">// P(1:rows, end-cols+1:end)     //右上角块</span></span><br><span class="line">P.bottomLeftCorner(rows, cols)     <span class="comment">// P(end-rows+1:end, 1:cols)     //左下角块</span></span><br><span class="line">P.bottomRightCorner(rows, cols)    <span class="comment">// P(end-rows+1:end, end-cols+1:end) //右下角块</span></span><br><span class="line">P.topLeftCorner&lt;rows,cols&gt;()       <span class="comment">// P(1:rows, 1:cols)                 //左上角块</span></span><br><span class="line">P.topRightCorner&lt;rows,cols&gt;()      <span class="comment">// P(1:rows, end-cols+1:end)         //右上角块</span></span><br><span class="line">P.bottomLeftCorner&lt;rows,cols&gt;()    <span class="comment">// P(end-rows+1:end, 1:cols)         //左下角块</span></span><br><span class="line">P.bottomRightCorner&lt;rows,cols&gt;()   <span class="comment">// P(end-rows+1:end, end-cols+1:end) //右下角块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别说明：Eigen的交换函数进行了高度优化</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.row(i) = P.col(j);               <span class="comment">// R(i, :) = P(:, j)</span></span><br><span class="line">R.col(j1).swap(mat1.col(j2));      <span class="comment">// R(:, [j1 j2]) = R(:, [j2, j1]) //交换列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Views, transpose, etc;</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.adjoint()                        <span class="comment">// R&#x27;                    // 共轭转置</span></span><br><span class="line">R.transpose()                      <span class="comment">// R.&#x27; or conj(R&#x27;)       // 可读/写 转置</span></span><br><span class="line">R.diagonal()                       <span class="comment">// diag(R)               // 可读/写 对角元素</span></span><br><span class="line">x.asDiagonal()                     <span class="comment">// diag(x)               // 对角矩阵化</span></span><br><span class="line">R.transpose().colwise().reverse()  <span class="comment">// rot90(R)              // 可读/写 逆时针旋转90度</span></span><br><span class="line">R.rowwise().reverse()              <span class="comment">// fliplr(R)             // 水平翻转</span></span><br><span class="line">R.colwise().reverse()              <span class="comment">// flipud(R)             // 垂直翻转</span></span><br><span class="line">R.replicate(i,j)                   <span class="comment">// repmat(P,i,j)         // 复制矩阵，垂直复制i个，水平复制j个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四则运算，和Matlab相同。但Matlab中不能使用*=这样的赋值运算符</span></span><br><span class="line"><span class="comment">// 矩阵 - 向量    矩阵 - 矩阵      矩阵 - 标量</span></span><br><span class="line">y  = M*x;          R  = P*Q;        R  = P*s;</span><br><span class="line">a  = b*M;          R  = P - Q;      R  = s*P;</span><br><span class="line">a *= M;            R  = P + Q;      R  = P/s;</span><br><span class="line">                   R *= Q;          R  = s*P;</span><br><span class="line">                   R += Q;          R *= s;</span><br><span class="line">                   R -= Q;          R /= s;</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line"><span class="comment">// 逐像素操作Vectorized operations on each element independently</span></span><br><span class="line"><span class="comment">// Eigen                       // Matlab        //注释</span></span><br><span class="line">R = P.cwiseProduct(Q);         <span class="comment">// R = P .* Q    //逐元素乘法</span></span><br><span class="line">R = P.<span class="built_in">array</span>() * s.<span class="built_in">array</span>();     <span class="comment">// R = P .* s    //逐元素乘法（s为标量）</span></span><br><span class="line">R = P.cwiseQuotient(Q);        <span class="comment">// R = P ./ Q    //逐元素除法</span></span><br><span class="line">R = P.<span class="built_in">array</span>() / Q.<span class="built_in">array</span>();     <span class="comment">// R = P ./ Q    //逐元素除法</span></span><br><span class="line">R = P.<span class="built_in">array</span>() + s.<span class="built_in">array</span>();     <span class="comment">// R = P + s     //逐元素加法（s为标量）</span></span><br><span class="line">R = P.<span class="built_in">array</span>() - s.<span class="built_in">array</span>();     <span class="comment">// R = P - s     //逐元素减法（s为标量）</span></span><br><span class="line">R.<span class="built_in">array</span>() += s;                <span class="comment">// R = R + s     //逐元素加法（s为标量）</span></span><br><span class="line">R.<span class="built_in">array</span>() -= s;                <span class="comment">// R = R - s     //逐元素减法（s为标量）</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt; Q.<span class="built_in">array</span>();         <span class="comment">// R &lt; Q         //逐元素比较运算</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt;= Q.<span class="built_in">array</span>();        <span class="comment">// R &lt;= Q        //逐元素比较运算</span></span><br><span class="line">R.cwiseInverse();              <span class="comment">// 1 ./ P        //逐元素取倒数</span></span><br><span class="line">R.<span class="built_in">array</span>().inverse();           <span class="comment">// 1 ./ P        //逐元素取倒数</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sin</span>()                <span class="comment">// sin(P)        //逐元素计算正弦函数</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">cos</span>()                <span class="comment">// cos(P)        //逐元素计算余弦函数</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">pow</span>(s)               <span class="comment">// P .^ s        //逐元素计算幂函数</span></span><br><span class="line">R.<span class="built_in">array</span>().square()             <span class="comment">// P .^ 2        //逐元素计算平方</span></span><br><span class="line">R.<span class="built_in">array</span>().cube()               <span class="comment">// P .^ 3        //逐元素计算立方</span></span><br><span class="line">R.cwiseSqrt()                  <span class="comment">// sqrt(P)       //逐元素计算平方根</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sqrt</span>()               <span class="comment">// sqrt(P)       //逐元素计算平方根</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">exp</span>()                <span class="comment">// exp(P)        //逐元素计算指数函数</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">log</span>()                <span class="comment">// log(P)        //逐元素计算对数函数</span></span><br><span class="line">R.cwiseMax(P)                  <span class="comment">// max(R, P)     //逐元素计算R和P的最大值</span></span><br><span class="line">R.<span class="built_in">array</span>().max(P.<span class="built_in">array</span>())       <span class="comment">// max(R, P)     //逐元素计算R和P的最大值</span></span><br><span class="line">R.cwiseMin(P)                  <span class="comment">// min(R, P)     //逐元素计算R和P的最小值</span></span><br><span class="line">R.<span class="built_in">array</span>().min(P.<span class="built_in">array</span>())       <span class="comment">// min(R, P)     //逐元素计算R和P的最小值</span></span><br><span class="line">R.cwiseAbs()                   <span class="comment">// abs(P)        //逐元素计算R和P的绝对值</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">abs</span>()                <span class="comment">// abs(P)        //逐元素计算绝对值</span></span><br><span class="line">R.cwiseAbs2()                  <span class="comment">// abs(P.^2)     //逐元素计算平方</span></span><br><span class="line">R.<span class="built_in">array</span>().abs2()               <span class="comment">// abs(P.^2)     //逐元素计算平方</span></span><br><span class="line">(R.<span class="built_in">array</span>() &lt; s).select(P,Q );  <span class="comment">// (R &lt; s ? P : Q)                             //根据R的元素值是否小于s，选择P和Q的对应元素</span></span><br><span class="line">R = (Q.<span class="built_in">array</span>()==<span class="number">0</span>).select(P,A) <span class="comment">// R(Q==0) = P(Q==0) R(Q!=0) = P(Q!=0)         //根据Q中元素等于零的位置选择P中元素</span></span><br><span class="line">R = P.unaryExpr(ptr_fun(func)) <span class="comment">// R = arrayfun(func, P)     // 对P中的每个元素应用func函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reductions.</span></span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="comment">// Eigen                  // Matlab                 //注释</span></span><br><span class="line">R.minCoeff()              <span class="comment">// min(R(:))              //最小值</span></span><br><span class="line">R.maxCoeff()              <span class="comment">// max(R(:))              //最大值</span></span><br><span class="line">s = R.minCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i); //计算最小值和它的位置</span></span><br><span class="line">s = R.maxCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i); //计算最大值和它的位置</span></span><br><span class="line">R.sum()                   <span class="comment">// sum(R(:))              //求和（所有元素）</span></span><br><span class="line">R.colwise().sum()         <span class="comment">// sum(R)                 //按列求和</span></span><br><span class="line">R.rowwise().sum()         <span class="comment">// sum(R, 2) or sum(R&#x27;)&#x27;  //按行求和</span></span><br><span class="line">R.prod()                  <span class="comment">// prod(R(:))                 //累积</span></span><br><span class="line">R.colwise().prod()        <span class="comment">// prod(R)                    //按列累积</span></span><br><span class="line">R.rowwise().prod()        <span class="comment">// prod(R, 2) or prod(R&#x27;)&#x27;    //按行累积</span></span><br><span class="line">R.trace()                 <span class="comment">// trace(R)                   //迹</span></span><br><span class="line">R.all()                   <span class="comment">// all(R(:))                  //是否所有元素都非零</span></span><br><span class="line">R.colwise().all()         <span class="comment">// all(R)                     //按列判断，是否该列所有元素都非零</span></span><br><span class="line">R.rowwise().all()         <span class="comment">// all(R, 2)                  //按行判断，是否该行所有元素都非零</span></span><br><span class="line">R.any()                   <span class="comment">// any(R(:))                  //是否有元素非零</span></span><br><span class="line">R.colwise().any()         <span class="comment">// any(R)                     //按列判断，是否该列有元素都非零</span></span><br><span class="line">R.rowwise().any()         <span class="comment">// any(R, 2)                  //按行判断，是否该行有元素都非零</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点积，范数等</span></span><br><span class="line"><span class="comment">// Eigen                  // Matlab           // 注释</span></span><br><span class="line">x.norm()                  <span class="comment">// norm(x).         //范数（注意：Eigen中没有norm(R)）</span></span><br><span class="line">x.squaredNorm()           <span class="comment">// dot(x, x)        //平方和（注意：对于复数而言，不等价）</span></span><br><span class="line">x.dot(y)                  <span class="comment">// dot(x, y)        //点积</span></span><br><span class="line">x.cross(y)                <span class="comment">// cross(x, y)      //交叉积，需要头文件 #include &lt;Eigen/Geometry&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 类型转换</span><br><span class="line"><span class="comment">// Eigen                  // Matlab             // 注释</span></span><br><span class="line">A.cast&lt;<span class="keyword">double</span>&gt;();         <span class="comment">// double(A)          //变成双精度类型</span></span><br><span class="line">A.cast&lt;<span class="keyword">float</span>&gt;();          <span class="comment">// single(A)          //变成单精度类型</span></span><br><span class="line">A.cast&lt;<span class="keyword">int</span>&gt;();            <span class="comment">// int32(A)           //编程整型</span></span><br><span class="line">A.real();                 <span class="comment">// real(A)            //实部</span></span><br><span class="line">A.imag();                 <span class="comment">// imag(A)            //虚部</span></span><br><span class="line"><span class="comment">// 如果变换前后的类型相同，不做任何事情。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：Eigen中，绝大多数的涉及多个操作数的运算都要求操作数具有相同的类型</span></span><br><span class="line">MatrixXf F = MatrixXf::Zero(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">A += F;                <span class="comment">// 非法。Matlab中允许。（单精度+双精度）</span></span><br><span class="line">A += F.cast&lt;<span class="keyword">double</span>&gt;(); <span class="comment">// 将F转换成double，并累加。（一般都是在使用时临时转换）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen 可以将已存储数据的缓存 映射成 Eigen矩阵</span></span><br><span class="line"><span class="keyword">float</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line">Vector3f::Map(<span class="built_in">array</span>).fill(<span class="number">10</span>);            <span class="comment">// create a temporary Map over array and sets entries to 10</span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">Matrix2i <span class="title">mat2x2</span><span class="params">(data)</span></span>;                    <span class="comment">// 将 data 复制到 mat2x2</span></span><br><span class="line">Matrix2i::Map(data) = <span class="number">2</span>*mat2x2;           <span class="comment">// 使用 2*mat2x2 覆写data的元素 </span></span><br><span class="line">MatrixXi::Map(data, <span class="number">2</span>, <span class="number">2</span>) += mat2x2;      <span class="comment">// 将 mat2x2 加到 data的元素上 (当编译时不知道大小时，可选语法)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解线性方程组 Ax = b。结果保存在x中。      Matlab: x = A \ b.</span></span><br><span class="line">x = A.ldlt().solve(b));  <span class="comment">// A sym. p.s.d.    #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.llt() .solve(b));  <span class="comment">// A sym. p.d.      #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.lu()  .solve(b));  <span class="comment">// 稳定，快速       #include &lt;Eigen/LU&gt;</span></span><br><span class="line">x = A.qr()  .solve(b));  <span class="comment">// No pivoting.     #include &lt;Eigen/QR&gt;        //Eigen 3.3.2中没有？</span></span><br><span class="line">x = A.svd() .solve(b));  <span class="comment">// 稳定，慢速       #include &lt;Eigen/SVD&gt;       //Eigen 3.3.2中没有？</span></span><br><span class="line"><span class="comment">// .ldlt() -&gt; .matrixL() and .matrixD()                         //?</span></span><br><span class="line"><span class="comment">// .llt()  -&gt; .matrixL()                                        //?</span></span><br><span class="line"><span class="comment">// .lu()   -&gt; .matrixL() and .matrixU()                         //?</span></span><br><span class="line"><span class="comment">// .qr()   -&gt; .matrixQ() and .matrixR()                         //?</span></span><br><span class="line"><span class="comment">// .svd()  -&gt; .matrixU(), .singularValues(), and .matrixV()     //?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征值问题</span></span><br><span class="line"><span class="comment">// Eigen                          // Matlab</span></span><br><span class="line">A.eigenvalues();                  <span class="comment">// eig(A);</span></span><br><span class="line"><span class="function">EigenSolver&lt;Matrix3d&gt; <span class="title">eig</span><span class="params">(A)</span></span>;     <span class="comment">// [vec val] = eig(A)</span></span><br><span class="line">eig.eigenvalues();                <span class="comment">// diag(val)          //特征值，向量形式</span></span><br><span class="line">eig.eigenvectors();               <span class="comment">// vec                //特征向量，矩阵形式</span></span><br><span class="line"><span class="comment">// 对于自伴矩阵（Hermitian矩阵或对称矩阵），使用SelfAdjointEigenSolver&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Eigen矩阵操作与Matlab对比</summary>
    
    
    
    <category term="编程学习" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Eigen" scheme="https://www.jaylee.top/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>MST最小生成树</title>
    <link href="https://www.jaylee.top/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://www.jaylee.top/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2020-10-22T05:11:17.000Z</published>
    <updated>2020-10-22T06:11:51.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>参考视频链接: <a href="https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=6207310363940342792">https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=6207310363940342792</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134619242.png" alt="image-20201022134619242" style="zoom: 67%;"><img src="/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134724408.png" alt="image-20201022134724408"></p><p>树的三个特点, n个点至少需要n-1条边, 不能由环的出现</p><img src="/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134724408.png" alt="image-20201022134724408" style="zoom:67%;"><p>最小的概念: 每条边都有相应的权重(可以是成本,距离等度量), 树中所有边的权重之和最小的方案为MST</p><a id="more"></a><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>有两种方法: Prime(寻找顶点) 和Kruskal(直接寻找边)</p><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><img src="/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022135500215.png" alt="image-20201022135500215" style="zoom:67%;"><ul><li>先将所有边按权重排序成列表</li><li>然后优先放入每条边判断是否成环</li><li>没有成环则加入MST; 若成环则放弃该边.</li></ul><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><img src="/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022140814900.png" alt="image-20201022140814900" style="zoom:67%;"><p>以顶点为出发点, 每次选择两个集合(已选点集和未选点集)之间边权重最短的顶点加入已选集合,然后再以该顶点出发选择到未选集合权重最小的边. </p><p>需要三个列表,</p><ul><li>selected将顶点区分为两个集合:已选和未选</li><li>minDist, 保存与已选集合中顶点联通的边权重最小的值</li><li>parent, 保存minDist另一端的顶点编号</li></ul><p>三个步骤:</p><ol><li>更新列表, 更新所有与已选顶点集合相连通的顶点. 如果其边权重小于表中原来的值, 就更新minDist以及对应的parent顶点.</li><li>扫描minDist列表,选择最小的边的编号.</li><li>添加该边对应的顶点到已选点集. </li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;最小生成树&quot;&gt;&lt;a href=&quot;#最小生成树&quot; class=&quot;headerlink&quot; title=&quot;最小生成树&quot;&gt;&lt;/a&gt;最小生成树&lt;/h1&gt;&lt;p&gt;参考视频链接: &lt;a href=&quot;https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;amp;seid=6207310363940342792&quot;&gt;https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;amp;seid=6207310363940342792&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134619242.png&quot; alt=&quot;image-20201022134619242&quot; style=&quot;zoom: 67%;&quot;&gt;&lt;img src=&quot;/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134724408.png&quot; alt=&quot;image-20201022134724408&quot;&gt;&lt;/p&gt;
&lt;p&gt;树的三个特点, n个点至少需要n-1条边, 不能由环的出现&lt;/p&gt;
&lt;img src=&quot;/2020/10/22/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134724408.png&quot; alt=&quot;image-20201022134724408&quot; style=&quot;zoom:67%;&quot;&gt;

&lt;p&gt;最小的概念: 每条边都有相应的权重(可以是成本,距离等度量), 树中所有边的权重之和最小的方案为MST&lt;/p&gt;</summary>
    
    
    
    <category term="常识库" scheme="https://www.jaylee.top/categories/%E5%B8%B8%E8%AF%86%E5%BA%93/"/>
    
    
    <category term="MST" scheme="https://www.jaylee.top/tags/MST/"/>
    
  </entry>
  
  <entry>
    <title>随笔10月20日</title>
    <link href="https://www.jaylee.top/2020/10/21/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94/"/>
    <id>https://www.jaylee.top/2020/10/21/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94/</id>
    <published>2020-10-21T10:23:33.000Z</published>
    <updated>2020-10-21T13:16:00.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年10月21日"><a href="#2020年10月21日" class="headerlink" title="2020年10月21日"></a>2020年10月21日</h1><p>秋招就这样告一段落吧, 我必须好好准备一下自己的身体, 思想, 和专业知识去迎接社会的摧残。</p><a id="more"></a><h2 id="1-现状"><a href="#1-现状" class="headerlink" title="1 现状"></a>1 现状</h2><p>我现在每每努力一小会就觉得已经拼命了, 并且那一小会也总是不能集中注意力到重要的事情, 要么搞一些无关紧要的事情，要么就是刷手机去了。我真的努力不起来了，这也是我害怕去考公务员的原因吧？</p><p>另一个类似的现象就是每次开始工作的时候都要花一定时间去回顾上次干了什么，很多都忘记了，感觉到记性大不如前了。一个是可归结于工作不连续，时间过于零散造成的遗忘；另一方面就是记忆力真的下降了。大脑不用则退。</p><p>最近对这个道理突然很有感慨：平时这个技巧偷个懒，那个问题摸个油，看起来与别人差别不大，但是<strong>认真待事的态度</strong>简直太差地别，积累到最后就可以通过offer的质量和数量残酷的摆在自己眼前，让自己震惊。有人说，大学中加入各种社团和学生会就是为了没有太大代价的提前进入“小社会”捶打自己认真安排各种事务和处理各种人际的能力。我一直有察觉自己有一股无所谓、与世无争、随遇而安、淡然身外物、不斤斤计较的气，以前还挺引以为傲的，直到近年来才发觉ta已经越来越拖累自己了。这种刻意的反复的想法，潜移默化的在潜意识中为自己打上了这个标签，频率高了就可谓弄假成真。发展到现在这股气现在已经发展成为逃避麻烦、畏难、敷衍了事、对什么事都失去强烈的兴趣此般“黑紫色的邪恶的气”。</p><p>为什么这么说呢？举个例子，我真的很不明白为什么有人看个比赛能激动成那个样子，甚至是声泪俱下，我也有喜欢的队伍和比赛，但我顶多夸个666然后打住。或者说有人为了喜欢的姑娘那般投入时间和精力，那般愤怒那般快乐，而我和一个女生线上聊天都觉得折磨。<strong>我好像失去了什么</strong>。没有了强烈的情绪和兴趣，就连自己玩游戏也一副麻木的操作着，美其名曰娱乐至上。这种特质和我的另一个特点不谋而契合，那就是我做很多事情都是浮于表面，不能深入，不管是爱好还是专业知识。</p><p>此般种种现象都指向同一个问题，我仿佛失去了什么。<em>是爱的能力？</em> 爱自己，直面自己内心和情绪；爱一件事情，体会事物内部的细节；爱别人；爱生活。没有爱，是因为自己没有认真对待上述每一样。有人说，多大决心办多大事。下决心，就是下决心去认真对待并认真执行。而我这股气就是在阻止我认真的态度！一味的怕麻烦逃避敷衍也许可以生存下去，但决不能好好的生活。</p><h2 id="2分析"><a href="#2分析" class="headerlink" title="2分析"></a>2分析</h2><p>那么，是什么造成了我现在的困境呢？</p><p>知乎问，<a href="https://www.zhihu.com/question/422796779/answer/1507988868">人这一辈子，最不能透支是什么？ - 温水公爵的回答 - 知乎</a> 或许这个回答能帮助我看清楚一些上述问题根源。</p><blockquote><p>Imagine life as a game in which you are juggling some five balls in the air. You name them <strong>work, family, health, friends and spirit</strong> and you re keeping all of these in the air.You will soon understand that work is a rubber ball.If you drop it, it will bounce back. But the other four balls family, health, friends, and spirit are made of glass. If you drop one of these, they will be irrevocably scuffed, marked, nicked, damaged, or even shattered. They will never be the same. You must understand that and strive for balance in your life.</p></blockquote><h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><p>想要优质的物质和精神条件，就需要好好的利用时间。而在这之前是要有一个好好的身体。</p><p>现在我年轻气盛，想要做到健康，关键就在于：<strong>节欲</strong>。人与人之间的智力差别并不大，而造成我与别人差距这么大的原因就是身体。</p><p>纵欲的人，<strong>付出微小的代价就能收获很大的刺激</strong>(奶头乐），因而造成总是体力不支，精力不够，<em>做事总想赶紧完成，投入不够深</em>，<em>注意力不集中</em>，<em>长期记忆力变差</em>，别人在飞速学习的时候他就总需要休息。这种差距日积月累，在offer这个触发点上就清晰可见。</p><p>想要改善自己的身体状况，那就是节欲，熬夜的欲望，赖床的欲望，性欲，食欲……。</p><p>按时睡觉，早起吃早饭，男女之事不要过度，拒绝垃圾食品，拒绝抽烟喝酒，规律锻炼运动。</p><p>看起来简单，多年前我也总结出来了，但实行起来，尤为困难。最大的难点就是早起吃早饭以及性欲的规律了。调整回来这两点之后，坑定会为我提高精力，去认真对待其他事件。</p><h3 id="娱乐至死"><a href="#娱乐至死" class="headerlink" title="娱乐至死"></a>娱乐至死</h3><p>与上一个有异曲同工之处。奶头乐真正的危害是对于精神层面的。低代价的短期的高刺激满足感，正在一点点侵蚀掉我对于真正重要的低刺激的长期回报的事物的执行的动力。造成我努力一小会就觉得很拼命的错觉，行动力的上限条被很大程度削减了。特点，</p><p>另一方面，如今零碎化的信息正充斥着我的生活的方方面面，知乎、哔哩哔哩、微信公众号……，他们碎片化的高刺激的特点，并善于伪装成有用的特点，极大程度的吸走了属于我自己的注意力和时间。每个人每天的注意力集中的程度是有上限的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2020年10月21日&quot;&gt;&lt;a href=&quot;#2020年10月21日&quot; class=&quot;headerlink&quot; title=&quot;2020年10月21日&quot;&gt;&lt;/a&gt;2020年10月21日&lt;/h1&gt;&lt;p&gt;秋招就这样告一段落吧, 我必须好好准备一下自己的身体, 思想, 和专业知识去迎接社会的摧残。&lt;/p&gt;</summary>
    
    
    
    <category term="生活随笔" scheme="https://www.jaylee.top/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.jaylee.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>CXX零碎知识点(二)</title>
    <link href="https://www.jaylee.top/2020/10/18/CXX%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9-%E4%BA%8C/"/>
    <id>https://www.jaylee.top/2020/10/18/CXX%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9-%E4%BA%8C/</id>
    <published>2020-10-18T06:59:20.000Z</published>
    <updated>2020-11-01T13:31:07.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年11月"><a href="#2020年11月" class="headerlink" title="2020年11月"></a>2020年11月</h1><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h2 id="条件-表达式"><a href="#条件-表达式" class="headerlink" title="条件?=表达式"></a>条件?=表达式</h2><p><code>int v = (w&lt;0) ? -1:1</code>表示如果w小于0, v取-1, 否则取1.</p><h2 id="子类虚函数调用"><a href="#子类虚函数调用" class="headerlink" title="子类虚函数调用"></a>子类虚函数调用</h2><p><a href="https://blog.csdn.net/ly890700/article/details/55803398">参考链接</a></p><p>覆盖override: 派生类重新写父类中virtual虚函数的实现, 参数列表返回类型需要保持一致.</p><p>重载overload: 两个同名函数的参数列表不同, 包括虚函数</p><blockquote><p>重定义: 重定义也是描述分别位于父类与子类中的同名函数的，但返回值可以不同。</p><ul><li>如果参数列表不同，这时子类中重定义的函数不论是否有virtual关键字，都会隐藏父类的同名函数。</li><li>如果参数列表相同，但父类中的同名函数没有virtual关键字修饰，此时父类中的函数仍然被隐藏。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//父类中定义了两个重载函数f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::f</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f(int) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f() &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===============================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span>)</span></span>; <span class="comment">//子类重定义了函数f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">float</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::f(float)&quot;</span> &lt;&lt; showpoint &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p1 = <span class="keyword">new</span> Base;</span><br><span class="line">    p1-&gt;f(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    Derived *p2 = <span class="keyword">new</span> Derived;<span class="comment">//定义指向子类的指针p2</span></span><br><span class="line">    p2-&gt;f(<span class="number">2.0</span>); <span class="comment">//调用子类::f(float),可运行 输出Derived::f(float)2.00000</span></span><br><span class="line">    p2-&gt;f(<span class="number">3</span>);<span class="comment">// 调用子类::f(float), 可运行输出Derived::f(float)3.00000</span></span><br><span class="line">    </span><br><span class="line">    Base *p3 = <span class="keyword">new</span> Derived; <span class="comment">//定义指向父类的指针p3,实际指向子类,仍会调用父类的函数f(int)</span></span><br><span class="line">    p3-&gt;f(<span class="number">2.0</span>);<span class="comment">//由于重定义(重载)的Derived::f(float)并没有覆盖掉父类的f()函数, 因此会调用父类::f(int), 输出Base::f(int) 2</span></span><br><span class="line">    p3-&gt;f(<span class="number">1</span>);<span class="comment">//可运行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line">    <span class="keyword">delete</span> p3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在写子类的虚函数的时候, 如果参数列表不同, 可以不加override关键字, 不用覆盖的功能,而直接使用重定义或者叫重载. </p><p>只是需要注意定义该子类对象时不能是指向父类的指针<code>Base *p = new Derived</code>, 否则父类的同名函数不会隐藏,而被调用.</p><h2 id="private-public"><a href="#private-public" class="headerlink" title="private / public"></a>private / public</h2><p><strong>访问范围</strong>:</p><ul><li>private: 只能被该类中的函数、该类的友元函数访问，该类的<strong>实例对象</strong>和<strong>子类函数</strong>都不能访问</li><li>protected成员，可以被该类中的函数、类的友元函数、子类函数访问，该<strong>类的对象</strong>不能访问</li><li>public成员, 可以被类中的函数、友元函数、类的实例对象、子类成员函数<strong>均可访问</strong>.</li></ul><p><strong>继承权限</strong>：</p><ul><li>public：可以访问父类的所有public成员</li><li>protected：父类的public和protected都变成子类的protected</li><li>private：父类的所有成员都变成子类的private</li></ul><h2 id="const引用传参"><a href="#const引用传参" class="headerlink" title="const引用传参"></a>const引用传参</h2><p>定义一个类，类中定义<code>int value()</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mc_int</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="keyword">int</span> val;      <span class="comment">//actual int</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;  <span class="comment">//Returns value</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//Changes and returns value</span></span><br><span class="line">        mc_int();  <span class="comment">//Default constructor</span></span><br><span class="line">        mc_int(<span class="keyword">int</span>);<span class="comment">//Create from int</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">asBytes</span><span class="params">(<span class="keyword">char</span>*)</span></span>; <span class="comment">//generate byte array</span></span><br><span class="line"></span><br><span class="line">        mc_int&amp; <span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">        mc_int&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mc_int&amp;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> endianity;  <span class="comment">//true for little</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当外部定义时采用常引用<code>mc_int&amp; operator=(const mc_int&amp;);</code>报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mc_int&amp; mc_int::<span class="keyword">operator</span>=(<span class="keyword">const</span> mc_int&amp; other) &#123;</span><br><span class="line">            val = other.value();  </span><br><span class="line">            <span class="comment">//    |--------&gt;Error: No instance of overloaded function matches the argument list and object (object has type quelifiers that prevent the match)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因在于：<code>other</code>对象被常引用，意指该对象不会被修改内部成员。而调用的成员函数<code>other.value()</code>没有被声明为仅访问函数，因此编译器认为该函数可能会改变常引用的对象<code>other</code>而报错。</p><p>修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//申明为仅访问函数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2020年11月&quot;&gt;&lt;a href=&quot;#2020年11月&quot; class=&quot;headerlink&quot; title=&quot;2020年11月&quot;&gt;&lt;/a&gt;2020年11月&lt;/h1&gt;&lt;h2 id=&quot;动态内存&quot;&gt;&lt;a href=&quot;#动态内存&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="C++" scheme="https://www.jaylee.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Eigen学习笔记</title>
    <link href="https://www.jaylee.top/2020/10/13/Eigen%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>https://www.jaylee.top/2020/10/13/Eigen%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</id>
    <published>2020-10-13T12:05:29.000Z</published>
    <updated>2020-11-07T05:31:55.139Z</updated>
    
    <content type="html"><![CDATA[<p>参考网站: <a href="https://zhuanlan.zhihu.com/p/36772345">https://zhuanlan.zhihu.com/p/36772345</a></p><p><a href="http://zhaoxuhui.top/blog/2019/08/21/eigen-note-1.html">参考博客</a></p><p>官方教程: <a href="https://eigen.tuxfamily.org/dox/group__QuickRefPage.html">https://eigen.tuxfamily.org/dox/group__QuickRefPage.html</a></p><h1 id="CMake库中的声明"><a href="#CMake库中的声明" class="headerlink" title="CMake库中的声明"></a>CMake库中的声明</h1><p>Eigen库本身全是头文件，只需要将头文件包含到路径中即可。</p><h2 id="方法1-修改vscode环境配置"><a href="#方法1-修改vscode环境配置" class="headerlink" title="方法1 修改vscode环境配置"></a>方法1 修改vscode环境配置</h2><p><a href="%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode%E9%85%8D%E7%BD%AEC++%E7%A8%8B%E5%BA%8F.md">vscode配置C++程序.md</a></p><h2 id="方法2-CMake工具"><a href="#方法2-CMake工具" class="headerlink" title="方法2 CMake工具"></a>方法2 CMake工具</h2><p>利用Cmake文件将包含路径写进去。</p><p><em>cmake也可以在vscode中利用cmake tool工具读入，自动包含路径，而无需再对vscode进行配置</em></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#寻找库Eigen</span></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="comment">#把库包含进去</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;EIGEN3_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="comment">#因为只有头文件，因此不需要target_link_libraries</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="矩阵和向量"><a href="#矩阵和向量" class="headerlink" title="矩阵和向量"></a>矩阵和向量</h1><h2 id="初始定义"><a href="#初始定义" class="headerlink" title="初始定义"></a>初始定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//started</span></span><br><span class="line">    <span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">1</span>) = m(<span class="number">1</span>,<span class="number">0</span>) + m(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态大小的矩阵</span></span><br><span class="line">    MatrixXd M1 = MatrixXd::Random(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    M1 = (M1 + MatrixXd::Constant(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1.2</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;M1= &quot;</span>&lt;&lt;M1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    v &lt;&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;v*M1 = &quot;</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;M1*v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//固定的矩阵</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">v2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    Matrix3d M2 = Matrix3d::Random();</span><br><span class="line">    M2 = M2 + Matrix3d::Constant(<span class="number">1.2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;M2*v2= &quot;</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;M2*v2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Matrix3d M3;</span><br><span class="line">    <span class="comment">//逗号初始化</span></span><br><span class="line">    M3 &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵变换</span></span><br><span class="line">    MatrixXcf a = MatrixXcf::Random(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//定义2-by-2随机矩阵</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here is the matrix a\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//矩阵a</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here is the matrix a^T\n&quot;</span> &lt;&lt; a.transpose() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//a的转置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here is the matrix a^H\n&quot;</span> &lt;&lt; a.conjugate() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//a的共轭</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here is the matrix a^&#123;-1&#125;\n&quot;</span> &lt;&lt; a.inverse() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//a的逆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向量乘法</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">w</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dot product: &quot;</span> &lt;&lt; v.dot(w) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//向量点乘</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cross product:\n&quot;</span> &lt;&lt; v.cross(w) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//向量叉乘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><p><code>.colwise()</code>返回每一列的值.</p><p><code>.rowwise()</code> 返回每一行的值</p><h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><p><code>.col(),.row(),.size()</code>：获取列数行数和元素个数</p><p><code>.data()</code>: 返回矩阵首地址的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MatrixXd::Zeros(n,m);</span><br><span class="line">MatrixXd::Ones(n,m);</span><br><span class="line">MatrixXd::Identity(n,m);</span><br><span class="line">MatrixXd::LineSpaced(size,low,high)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考网站: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/36772345&quot;&gt;https://zhuanlan.zhihu.com/p/36772345&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zhaoxuhui.top/blog/2019/08/21/eigen-note-1.html&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方教程: &lt;a href=&quot;https://eigen.tuxfamily.org/dox/group__QuickRefPage.html&quot;&gt;https://eigen.tuxfamily.org/dox/group__QuickRefPage.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;CMake库中的声明&quot;&gt;&lt;a href=&quot;#CMake库中的声明&quot; class=&quot;headerlink&quot; title=&quot;CMake库中的声明&quot;&gt;&lt;/a&gt;CMake库中的声明&lt;/h1&gt;&lt;p&gt;Eigen库本身全是头文件，只需要将头文件包含到路径中即可。&lt;/p&gt;
&lt;h2 id=&quot;方法1-修改vscode环境配置&quot;&gt;&lt;a href=&quot;#方法1-修改vscode环境配置&quot; class=&quot;headerlink&quot; title=&quot;方法1 修改vscode环境配置&quot;&gt;&lt;/a&gt;方法1 修改vscode环境配置&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode%E9%85%8D%E7%BD%AEC++%E7%A8%8B%E5%BA%8F.md&quot;&gt;vscode配置C++程序.md&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;方法2-CMake工具&quot;&gt;&lt;a href=&quot;#方法2-CMake工具&quot; class=&quot;headerlink&quot; title=&quot;方法2 CMake工具&quot;&gt;&lt;/a&gt;方法2 CMake工具&lt;/h2&gt;&lt;p&gt;利用Cmake文件将包含路径写进去。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;cmake也可以在vscode中利用cmake tool工具读入，自动包含路径，而无需再对vscode进行配置&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#寻找库Eigen&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;find_package&lt;/span&gt;(Eigen3 REQUIRED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#把库包含进去&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;include_directories&lt;/span&gt;(&lt;span class=&quot;variable&quot;&gt;$&amp;#123;EIGEN3_INCLUDE_DIRS&amp;#125;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#因为只有头文件，因此不需要target_link_libraries&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="编程学习" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Eigen" scheme="https://www.jaylee.top/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>vscode调试运行cpp程序</title>
    <link href="https://www.jaylee.top/2020/10/12/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode%E9%85%8D%E7%BD%AEC++%E7%A8%8B%E5%BA%8F/"/>
    <id>https://www.jaylee.top/2020/10/12/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode%E9%85%8D%E7%BD%AEC++%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-10-12T12:05:29.000Z</published>
    <updated>2020-10-26T05:44:09.644Z</updated>
    
    <content type="html"><![CDATA[<p>与文档”vscode调试运行ROS程序.md”相似,本文档简单讲讲不使用Cmake配置C++/gcc环境.以简单程序调用Eigen库为例.</p><h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mypg.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Eigen::MatrixXd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">1</span>) = m(<span class="number">1</span>,<span class="number">0</span>) + m(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h1><p>先要将文档编译成可执行文件,但是需要链接Eigen库头文件,可利用<code>gcc -I</code>指令在终端编译</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I /usr/include/eigen3/ mypg.cpp -o mypg</span><br></pre></td></tr></table></figure><h2 id="Task-json"><a href="#Task-json" class="headerlink" title="Task.json"></a>Task.json</h2><p>而在vscode中, 可按<code>ctrl+shift+b</code>或F7编译. <code>ctrl+shift+P</code>输入Task指令生成<em>task.json</em>, 修改task.json中的编译相关参数. 该文件相当于吧命令行中输入的所有参数预先保存下来，以后每次编译的时候就会来这里读取需要的参数。json只是一个字典类型文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//命名</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/g++&quot;</span>,<span class="comment">//终端运行的指令</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [ <span class="comment">//此项是上述命令G++的参数列表</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/*.cpp&quot;</span>,</span><br><span class="line">                <span class="comment">//&quot;$&#123;workspaceFolder&#125;/src/*.cpp&quot;,//填写需要编译的目标cpp文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,               </span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">                <span class="comment">//生成的可执行文件存放的目录</span></span><br><span class="line">                <span class="comment">//$&#123;fileDirname&#125;当前工作目录; $&#123;fileBasenameNoExtension&#125;以活动文件名为基础的没有扩展名的可执行文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-stdlib=libc++&quot;</span>,<span class="comment">//这两句是默认的编译器C++98更改为C++11</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-I&quot;</span>,   <span class="comment">//头文件链接目录.实践证明不好用,在c_cpp_properties中includePath设置更好.ctrl+shift+p配置C/C++.</span></span><br><span class="line">                <span class="string">&quot;/usr/include/eigen3/&quot;</span>，</span><br><span class="line">                <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span> <span class="comment">//the task runner&#x27;s current working directory on startup</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><p>虽然上述可以编译了，但是我们发现vscode自身并没有链接上eigen库, 代码下不会有红色波浪线提示找不到文件，因此需要配置C/C++ Configrations链接起来，写代码时方便跳转查看。</p><p><code>ctrl+shift+P</code>调出<em>C/C++ Configrations.</em> 在includePath中添加包含路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;default&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;gnu11&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以编译了,<code>ctrl+shift+B</code>. 生成相应的可执行文件<code>mypg.exe</code></p><h1 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h1><p>按F5自动生成调试用的<strong>launch.json</strong>文档.</p><p>要清楚调试是基于生成的可执行文件*.exe才能调试, 因此在先没有可执行文件情况下需要设置<strong>preLaunchTask</strong>为自己的编译任务的名字. </p><p>可以定义多个调试器, 以运行不同的cpp和参数调试.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,<span class="comment">//注意可执行文件的后缀</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与文档”vscode调试运行ROS程序.md”相似,本文档简单讲讲不使用Cmake配置C++/gcc环境.以简单程序调用Eigen库为例.&lt;/p&gt;
&lt;h1 id=&quot;编写代码&quot;&gt;&lt;a href=&quot;#编写代码&quot; class=&quot;headerlink&quot; title=&quot;编写代码&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="工具技能" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/"/>
    
    <category term="vscode" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode/"/>
    
    
    <category term="vscode" scheme="https://www.jaylee.top/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>CXX学习整理</title>
    <link href="https://www.jaylee.top/2020/10/11/CXX/C++%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/"/>
    <id>https://www.jaylee.top/2020/10/11/CXX/C++%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/</id>
    <published>2020-10-11T01:57:06.000Z</published>
    <updated>2020-10-11T02:06:01.493Z</updated>
    
    <content type="html"><![CDATA[<p>C++学习主要内容</p><ul><li>数据结构</li><li>指针与引用</li><li>类和对象</li><li>继承与重载与多态</li><li>函数</li><li>模板库</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++学习主要内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;指针与引用&lt;/li&gt;
&lt;li&gt;类和对象&lt;/li&gt;
&lt;li&gt;继承与重载与多态&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;模板库&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="C++" scheme="https://www.jaylee.top/tags/C/"/>
    
  </entry>
  
</feed>
