<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J.Lee&#39;s Town</title>
  
  <subtitle>Life is Fantastic</subtitle>
  <link href="https://www.jaylee.top/atom.xml" rel="self"/>
  
  <link href="https://www.jaylee.top/"/>
  <updated>2020-11-27T14:14:56.096Z</updated>
  <id>https://www.jaylee.top/</id>
  
  <author>
    <name>J.Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SAT</title>
    <link href="https://www.jaylee.top/2020/11/27/SAT/"/>
    <id>https://www.jaylee.top/2020/11/27/SAT/</id>
    <published>2020-11-27T14:14:06.000Z</published>
    <updated>2020-11-27T14:14:56.096Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/11/27/SAT/clip_image001.png" alt="d JA ؤ 0.  ) . ه لا)٨١ . ٩١ (٨  (ي ور ه  A ،و طوم  ة با ز و وه .4&#39;  زا لا د  هـ "></p><p><img src="/2020/11/27/SAT/clip_image002.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2020/11/27/SAT/clip_image001.png&quot; alt=&quot;d JA ؤ 0.  ) . ه لا)٨١ . ٩١ (٨  (ي ور ه  A ،و طوم  ة با ز و وه .4&amp;#39;  زا لا د  هـ &quot;&gt;&lt;</summary>
      
    
    
    
    <category term="研究生" scheme="https://www.jaylee.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"/>
    
    
    <category term="SAT" scheme="https://www.jaylee.top/tags/SAT/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.jaylee.top/2020/11/19/%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E5%8F%91%E7%83%A7/"/>
    <id>https://www.jaylee.top/2020/11/19/%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E5%8F%91%E7%83%A7/</id>
    <published>2020-11-19T12:25:06.178Z</published>
    <updated>2020-11-19T12:59:32.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h2><p>logi M330C</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;鼠标&quot;&gt;&lt;a href=&quot;#鼠标&quot; class=&quot;headerlink&quot; title=&quot;鼠标&quot;&gt;&lt;/a&gt;鼠标&lt;/h2&gt;&lt;p&gt;logi M330C&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ROS学习笔记(二)</title>
    <link href="https://www.jaylee.top/2020/11/12/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>https://www.jaylee.top/2020/11/12/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</id>
    <published>2020-11-12T07:14:22.000Z</published>
    <updated>2020-11-19T05:16:26.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h1><p>可以采集一些topic数据并发布数据。相当于subscriber和publisher。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record /topic_name -o my_rosbag_name</span><br></pre></td></tr></table></figure><p>record指令后面可以接多个topic名字，<code>-o</code>是输出文件名字.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag info my_rosbag_name</span><br></pre></td></tr></table></figure><p>可查看记录的rosbag的信息，包括topic，消息类型，包的大小时长等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play my_rosbag_name</span><br></pre></td></tr></table></figure><p>重新发布记录的包到各自的主题。注意仿真的时间依据，<code>--clock</code>可限制为系统时间. <code>-l</code>可以循环播放, <code>-s</code>可以设置开始播放的时间起点, <code>-r</code>可以限制播放的速率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic echo /topic_name</span><br></pre></td></tr></table></figure><p>可实时输出topic的内容信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag filter input.bag output.bag &quot;t.to_sec() &lt;= 1284703931.86&quot;</span><br></pre></td></tr></table></figure><p>上面的命令需要你有inputbag，然后它会把Bag Time&lt;=1284703931.86的部分提取出来，重新放到一个新的ouput.bag里.</p><h1 id="msg"><a href="#msg" class="headerlink" title="msg"></a>msg</h1><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>有一些msg含有header信息，包含了消息的常用的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint32 seq</span><br><span class="line">time stamp</span><br><span class="line">string frame_id</span><br></pre></td></tr></table></figure><h2 id="自定义msg"><a href="#自定义msg" class="headerlink" title="自定义msg"></a>自定义msg</h2><img src="/2020/11/12/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/image-20201112160208278.png" alt="image-20201112160208278" style="zoom:67%;"><p>四个步骤如图所示.</p><ol><li><p><code>touch Person.msg</code>新建消息文件，catkin_make的时候会根据系统位数语言等自动生成包含person类的头文件，因此<code>#include &quot;pakage_name/person_msg.h&quot;</code></p></li><li><p>添加编译运行依赖包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改CMakeLists：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_executable(person_publisher src/person_publisher.cpp)</span><br><span class="line">target_link_libraries(person_publisher $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(person_publisher $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br><span class="line"><span class="meta">#</span><span class="bash">与2中相应</span></span><br><span class="line"></span><br><span class="line">add_executable(person_subscriber src/person_subscriber.cpp)</span><br><span class="line">target_link_libraries(person_subscriber $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br></pre></td></tr></table></figure></li></ol><h1 id="tf-transform"><a href="#tf-transform" class="headerlink" title="tf::transform"></a>tf::transform</h1><p><code>#include &lt;tf/tranform_listener.h&gt;</code></p><p><code>#include &lt;tf/transform_broadcaster.h&gt;</code></p><h2 id="广播器Broadcaster"><a href="#广播器Broadcaster" class="headerlink" title="广播器Broadcaster"></a>广播器Broadcaster</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> tf::TransformBroadcaster bc;</span><br><span class="line"></span><br><span class="line">tf::Transform transform;</span><br><span class="line"><span class="comment">//set 平移变换</span></span><br><span class="line">transform.setOrigin(tf::Vector(input_msg.x, input_msg.y, <span class="number">0.0</span>)); </span><br><span class="line"><span class="comment">//set 旋转变换</span></span><br><span class="line">tf:: Quaternion q;<span class="comment">//四元素</span></span><br><span class="line">q.setRPY(<span class="number">0.0</span>，<span class="number">0.0</span>，input_msg.theta);</span><br><span class="line">transform.setRotation(q);</span><br><span class="line"></span><br><span class="line">bc.sendTransform(tf::StampedTransform(transform,ros::Time:now(), <span class="string">&quot;world&quot;</span>, turtle_name) );</span><br></pre></td></tr></table></figure><h2 id="订阅器listener"><a href="#订阅器listener" class="headerlink" title="订阅器listener"></a>订阅器listener</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建tf的监听器</span></span><br><span class="line">tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (node.ok())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">    tf::StampedTransform transform;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        listener.waitForTransform(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::Time(<span class="number">0</span>), ros::Duration(<span class="number">3.0</span>));<span class="comment">//等待消息的到来， duration设置为3s超时</span></span><br><span class="line">        listener.lookupTransform(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::Time(<span class="number">0</span>), transform);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (tf::TransformException &amp;ex) </span><br><span class="line">    &#123;</span><br><span class="line">        ROS_ERROR(<span class="string">&quot;%s&quot;</span>,ex.what());</span><br><span class="line">        ros::Duration(<span class="number">1.0</span>).sleep();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    transform.getOrigin().x();</span><br><span class="line">    transform.getOrigin().y();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static-transform-publisher节点"><a href="#static-transform-publisher节点" class="headerlink" title="static_transform_publisher节点"></a>static_transform_publisher节点</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Calibration--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_link_to_rslidar_left&quot;</span>  <span class="attr">args</span>=<span class="string">&quot;-1.249000902703301e-16 0.65 -0.2 0 0.017453293 -0.8203047710000001 /rslidar /rslidar_left 1&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_link_to_rslidar_right&quot;</span>  <span class="attr">args</span>=<span class="string">&quot;2.654126918244515e-16 -0.5250000000000004 -0.2 0 0 0.006981317200000003 /rslidar /rslidar_right 1&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码是我们在launch文件中将两侧雷达的数据坐标变换到中间雷达中运行的两个节点。<code>tf::static_transform_publisher</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf static_transform_publisher </span><br></pre></td></tr></table></figure><p>可通过上述指令查看该节点需要的参数的顺序，如下：</p><blockquote><p>Usage: static_transform_publisher <em>x y z yaw pitch roll frame_id child_frame_id  period</em>(milliseconds)<br>OR<br>Usage: static_transform_publisher <em>x y z qx qy qz qw frame_id child_frame_id  period</em>(milliseconds) </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rosbag&quot;&gt;&lt;a href=&quot;#rosbag&quot; class=&quot;headerlink&quot; title=&quot;rosbag&quot;&gt;&lt;/a&gt;rosbag&lt;/h1&gt;&lt;p&gt;可以采集一些topic数据并发布数据。相当于subscriber和publisher。&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    <category term="工具技能" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/"/>
    
    <category term="ROS" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.jaylee.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>C++代码风格</title>
    <link href="https://www.jaylee.top/2020/11/03/C++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://www.jaylee.top/2020/11/03/C++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2020-11-03T02:24:33.000Z</published>
    <updated>2020-11-07T05:31:55.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h1><p>成员函数缺省参数值通常写在头文件或者源文件二者之一的地方，通常写在源文件中，但是会造成后果，没太看明白。</p><h1 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h1><p>参考文章：<a href="https://blog.csdn.net/guyue35/article/details/46775211">https://blog.csdn.net/guyue35/article/details/46775211</a></p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缺省参数&quot;&gt;&lt;a href=&quot;#缺省参数&quot; class=&quot;headerlink&quot; title=&quot;缺省参数&quot;&gt;&lt;/a&gt;缺省参数&lt;/h1&gt;&lt;p&gt;成员函数缺省参数值通常写在头文件或者源文件二者之一的地方，通常写在源文件中，但是会造成后果，没太看明白。&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="C++" scheme="https://www.jaylee.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CXX零碎知识点(二)</title>
    <link href="https://www.jaylee.top/2020/10/18/CXX%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9-%E4%BA%8C/"/>
    <id>https://www.jaylee.top/2020/10/18/CXX%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9-%E4%BA%8C/</id>
    <published>2020-10-18T06:59:20.000Z</published>
    <updated>2020-11-19T05:16:26.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年11月"><a href="#2020年11月" class="headerlink" title="2020年11月"></a>2020年11月</h1><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h2 id="条件-表达式"><a href="#条件-表达式" class="headerlink" title="条件?=表达式"></a>条件?=表达式</h2><p><code>int v = (w&lt;0) ? -1:1</code>表示如果w小于0, v取-1, 否则取1.</p><h2 id="子类虚函数调用"><a href="#子类虚函数调用" class="headerlink" title="子类虚函数调用"></a>子类虚函数调用</h2><p><a href="https://blog.csdn.net/ly890700/article/details/55803398">参考链接</a></p><p>覆盖override: 派生类重新写父类中virtual虚函数的实现, 参数列表返回类型需要保持一致.</p><p>重载overload: 两个同名函数的参数列表不同, 包括虚函数</p><blockquote><p>重定义: 重定义也是描述分别位于父类与子类中的同名函数的，但返回值可以不同。</p><ul><li>如果参数列表不同，这时子类中重定义的函数不论是否有virtual关键字，都会隐藏父类的同名函数。</li><li>如果参数列表相同，但父类中的同名函数没有virtual关键字修饰，此时父类中的函数仍然被隐藏。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//父类中定义了两个重载函数f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::f</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f(int) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f() &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===============================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span>)</span></span>; <span class="comment">//子类重定义了函数f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">float</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::f(float)&quot;</span> &lt;&lt; showpoint &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p1 = <span class="keyword">new</span> Base;</span><br><span class="line">    p1-&gt;f(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    Derived *p2 = <span class="keyword">new</span> Derived;<span class="comment">//定义指向子类的指针p2</span></span><br><span class="line">    p2-&gt;f(<span class="number">2.0</span>); <span class="comment">//调用子类::f(float),可运行 输出Derived::f(float)2.00000</span></span><br><span class="line">    p2-&gt;f(<span class="number">3</span>);<span class="comment">// 调用子类::f(float), 可运行输出Derived::f(float)3.00000</span></span><br><span class="line">    </span><br><span class="line">    Base *p3 = <span class="keyword">new</span> Derived; <span class="comment">//定义指向父类的指针p3,实际指向子类,仍会调用父类的函数f(int)</span></span><br><span class="line">    p3-&gt;f(<span class="number">2.0</span>);<span class="comment">//由于重定义(重载)的Derived::f(float)并没有覆盖掉父类的f()函数, 因此会调用父类::f(int), 输出Base::f(int) 2</span></span><br><span class="line">    p3-&gt;f(<span class="number">1</span>);<span class="comment">//可运行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line">    <span class="keyword">delete</span> p3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在写子类的虚函数的时候, 如果参数列表不同, 可以不加override关键字, 不用覆盖的功能,而直接使用重定义或者叫重载. </p><p>只是需要注意定义该子类对象时不能是指向父类的指针<code>Base *p = new Derived</code>, 否则父类的同名函数不会隐藏,而被调用.</p><h2 id="private-public"><a href="#private-public" class="headerlink" title="private / public"></a>private / public</h2><p><strong>访问范围</strong>:</p><ul><li>private: 只能被该类中的函数、该类的友元函数访问，该类的<strong>实例对象</strong>和<strong>子类函数</strong>都不能访问</li><li>protected成员，可以被该类中的函数、类的友元函数、子类函数访问，该<strong>类的对象</strong>不能访问</li><li>public成员, 可以被类中的函数、友元函数、类的实例对象、子类成员函数<strong>均可访问</strong>.</li></ul><p><strong>继承权限</strong>：</p><ul><li>public：可以访问父类的所有public成员</li><li>protected：父类的public和protected都变成子类的protected</li><li>private：父类的所有成员都变成子类的private</li></ul><h2 id="const引用传参"><a href="#const引用传参" class="headerlink" title="const引用传参"></a>const引用传参</h2><p>定义一个类，类中定义<code>int value()</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mc_int</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="keyword">int</span> val;      <span class="comment">//actual int</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;  <span class="comment">//Returns value</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//Changes and returns value</span></span><br><span class="line">        mc_int();  <span class="comment">//Default constructor</span></span><br><span class="line">        mc_int(<span class="keyword">int</span>);<span class="comment">//Create from int</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">asBytes</span><span class="params">(<span class="keyword">char</span>*)</span></span>; <span class="comment">//generate byte array</span></span><br><span class="line"></span><br><span class="line">        mc_int&amp; <span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">        mc_int&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mc_int&amp;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> endianity;  <span class="comment">//true for little</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当外部定义时采用常引用<code>mc_int&amp; operator=(const mc_int&amp;);</code>报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mc_int&amp; mc_int::<span class="keyword">operator</span>=(<span class="keyword">const</span> mc_int&amp; other) &#123;</span><br><span class="line">            val = other.value();  </span><br><span class="line">            <span class="comment">//    |--------&gt;Error: No instance of overloaded function matches the argument list and object (object has type quelifiers that prevent the match)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因在于：<code>other</code>对象被常引用，意指该对象不会被修改内部成员。而调用的成员函数<code>other.value()</code>没有被声明为仅访问函数，因此编译器认为该函数可能会改变常引用的对象<code>other</code>而报错。</p><p>修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//申明为仅访问函数</span></span><br></pre></td></tr></table></figure><h2 id="array-vector区别"><a href="#array-vector区别" class="headerlink" title="array vector区别"></a>array vector区别</h2><h2 id="子类构造函数调用父类的构造函数"><a href="#子类构造函数调用父类的构造函数" class="headerlink" title="子类构造函数调用父类的构造函数"></a>子类构造函数调用父类的构造函数</h2><p><a href="https://blog.csdn.net/fchyang/article/details/81508030">https://blog.csdn.net/fchyang/article/details/81508030</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParkingSlot::ParkingSlot(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PointType2f&gt; rect_points):Object2D(rect_points)&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2020年11月&quot;&gt;&lt;a href=&quot;#2020年11月&quot; class=&quot;headerlink&quot; title=&quot;2020年11月&quot;&gt;&lt;/a&gt;2020年11月&lt;/h1&gt;&lt;h2 id=&quot;动态内存&quot;&gt;&lt;a href=&quot;#动态内存&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="C++" scheme="https://www.jaylee.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vscode调试运行cpp程序</title>
    <link href="https://www.jaylee.top/2020/10/12/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode%E9%85%8D%E7%BD%AEC++%E7%A8%8B%E5%BA%8F/"/>
    <id>https://www.jaylee.top/2020/10/12/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode%E9%85%8D%E7%BD%AEC++%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-10-12T12:05:29.000Z</published>
    <updated>2020-10-26T05:44:09.644Z</updated>
    
    <content type="html"><![CDATA[<p>与文档”vscode调试运行ROS程序.md”相似,本文档简单讲讲不使用Cmake配置C++/gcc环境.以简单程序调用Eigen库为例.</p><h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mypg.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Eigen::MatrixXd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">1</span>) = m(<span class="number">1</span>,<span class="number">0</span>) + m(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h1><p>先要将文档编译成可执行文件,但是需要链接Eigen库头文件,可利用<code>gcc -I</code>指令在终端编译</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I /usr/include/eigen3/ mypg.cpp -o mypg</span><br></pre></td></tr></table></figure><h2 id="Task-json"><a href="#Task-json" class="headerlink" title="Task.json"></a>Task.json</h2><p>而在vscode中, 可按<code>ctrl+shift+b</code>或F7编译. <code>ctrl+shift+P</code>输入Task指令生成<em>task.json</em>, 修改task.json中的编译相关参数. 该文件相当于吧命令行中输入的所有参数预先保存下来，以后每次编译的时候就会来这里读取需要的参数。json只是一个字典类型文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//命名</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/g++&quot;</span>,<span class="comment">//终端运行的指令</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [ <span class="comment">//此项是上述命令G++的参数列表</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/*.cpp&quot;</span>,</span><br><span class="line">                <span class="comment">//&quot;$&#123;workspaceFolder&#125;/src/*.cpp&quot;,//填写需要编译的目标cpp文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,               </span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">                <span class="comment">//生成的可执行文件存放的目录</span></span><br><span class="line">                <span class="comment">//$&#123;fileDirname&#125;当前工作目录; $&#123;fileBasenameNoExtension&#125;以活动文件名为基础的没有扩展名的可执行文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-stdlib=libc++&quot;</span>,<span class="comment">//这两句是默认的编译器C++98更改为C++11</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-I&quot;</span>,   <span class="comment">//头文件链接目录.实践证明不好用,在c_cpp_properties中includePath设置更好.ctrl+shift+p配置C/C++.</span></span><br><span class="line">                <span class="string">&quot;/usr/include/eigen3/&quot;</span>，</span><br><span class="line">                <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span> <span class="comment">//the task runner&#x27;s current working directory on startup</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><p>虽然上述可以编译了，但是我们发现vscode自身并没有链接上eigen库, 代码下不会有红色波浪线提示找不到文件，因此需要配置C/C++ Configrations链接起来，写代码时方便跳转查看。</p><p><code>ctrl+shift+P</code>调出<em>C/C++ Configrations.</em> 在includePath中添加包含路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;default&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;gnu11&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以编译了,<code>ctrl+shift+B</code>. 生成相应的可执行文件<code>mypg.exe</code></p><h1 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h1><p>按F5自动生成调试用的<strong>launch.json</strong>文档.</p><p>要清楚调试是基于生成的可执行文件*.exe才能调试, 因此在先没有可执行文件情况下需要设置<strong>preLaunchTask</strong>为自己的编译任务的名字. </p><p>可以定义多个调试器, 以运行不同的cpp和参数调试.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,<span class="comment">//注意可执行文件的后缀</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与文档”vscode调试运行ROS程序.md”相似,本文档简单讲讲不使用Cmake配置C++/gcc环境.以简单程序调用Eigen库为例.&lt;/p&gt;
&lt;h1 id=&quot;编写代码&quot;&gt;&lt;a href=&quot;#编写代码&quot; class=&quot;headerlink&quot; title=&quot;编写代码&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="工具技能" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/"/>
    
    <category term="vscode" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode/"/>
    
    
    <category term="vscode" scheme="https://www.jaylee.top/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>PCL基础知识</title>
    <link href="https://www.jaylee.top/2020/10/10/PCL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.jaylee.top/2020/10/10/PCL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-10-10T03:00:00.000Z</published>
    <updated>2020-11-19T05:16:26.250Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/walkthrough.html#common">官方文档</a></p><h2 id="PCL点云数据结构"><a href="#PCL点云数据结构" class="headerlink" title="PCL点云数据结构"></a>PCL点云数据结构</h2><p><a href="https://blog.csdn.net/qq_30815237/article/details/86475877?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">学习链接</a></p><h3 id="PointCLoud"><a href="#PointCLoud" class="headerlink" title="PointCLoud:"></a><strong>PointCLoud</strong>:</h3><ul><li>width(int),每一束激光扫描的点数</li><li>height(int), 激光的线数, 当点云为无序点云时候height=1</li><li>points(std::vector), 存储点的类型的向量,如XYZ,XYZI等,</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud;</span><br><span class="line">cloud.points[i].x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pcl::PointXYZ&gt; data = cloud.points;</span><br><span class="line"><span class="keyword">if</span>(!cloud.isOrganized())&#123;&#125;<span class="comment">//判断是不是有序点云</span></span><br><span class="line">is_dense(<span class="literal">true</span>)<span class="comment">//指定所有点都是稠密的,inf/nan</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//指针类型</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">ptr <span class="title">cloud2</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">cloud2-&gt;point[i].x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li><p>PointXYZ</p><p>结构: <code>float x,y,z </code> </p><p>用cloud.points[i].x访问</p></li><li><p>PointXYZI</p><p>结构:<code>float x,y,z,Indensity;</code></p><p>用cloud.points[i].Data[4]访问强度</p></li><li><p>PointXYZRGB</p><p>结构:<code>float x,y,z,rgb</code> rgb用一个浮点数表示</p></li></ol><h2 id="点云预处理"><a href="#点云预处理" class="headerlink" title="点云预处理"></a>点云预处理</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pcl.readthedocs.io/projects/tutorials/en/latest/walkthrough.html#common&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;PCL点云数据结构&quot;&gt;&lt;a href=&quot;#PCL点云数据结构&quot; class=&quot;headerlink&quot; title=&quot;PCL点云数据结构&quot;&gt;&lt;/a&gt;PCL点云数据结构&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_30815237/article/details/86475877?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&quot;&gt;学习链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;PointCLoud&quot;&gt;&lt;a href=&quot;#PointCLoud&quot; class=&quot;headerlink&quot; title=&quot;PointCLoud:&quot;&gt;&lt;/a&gt;&lt;strong&gt;PointCLoud&lt;/strong&gt;:&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;width(int),每一束激光扫描的点数&lt;/li&gt;
&lt;li&gt;height(int), 激光的线数, 当点云为无序点云时候height=1&lt;/li&gt;
&lt;li&gt;points(std::vector), 存储点的类型的向量,如XYZ,XYZI等,&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="研究生" scheme="https://www.jaylee.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"/>
    
    <category term="PCL" scheme="https://www.jaylee.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/PCL/"/>
    
    
    <category term="PCL" scheme="https://www.jaylee.top/tags/PCL/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu常用问题记录</title>
    <link href="https://www.jaylee.top/2020/10/10/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/ubuntu%E5%B8%B8%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.jaylee.top/2020/10/10/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/ubuntu%E5%B8%B8%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-10-10T02:18:51.000Z</published>
    <updated>2020-10-21T12:10:00.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开机启动VPN脚本"><a href="#开机启动VPN脚本" class="headerlink" title="开机启动VPN脚本"></a>开机启动VPN脚本</h1><p>每次开机都要设置鼠标灵敏度和打开ssVPN操作,不如让这两行命令开机启动,省事.</p><p>1.在<code>/etc/init.d/</code>文件夹下添加一个脚本文件vpn_open.sh, </p><p>脚本格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:          vpn_open.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start:    <span class="variable">$local_fs</span> <span class="variable">$network</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop:     <span class="variable">$local_fs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:      0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description: open vpn service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description:       open vpn service HK2.json</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line">nohup ss-local -c /home/lee/socketpro/HK2.json &amp;</span><br><span class="line">xset m 2</span><br></pre></td></tr></table></figure><p>2.将这个脚本添加到开机启动的服务中.<a href="https://blog.csdn.net/MakerCloud/article/details/81257953?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">参考链接</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x start_test.sh #设置权限</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将脚本添加到启动脚本,90为优先级,数值越高优先级越低</span></span><br><span class="line">cd /etc/init.d/</span><br><span class="line">sudo update-rc.d start_test.sh defaults 90</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除服务方法</span></span><br><span class="line">cd /etc/init.d</span><br><span class="line">sudo update-rc.d -f start_test.sh remove</span><br></pre></td></tr></table></figure><h1 id="设置鼠标速度"><a href="#设置鼠标速度" class="headerlink" title="设置鼠标速度"></a>设置鼠标速度</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xset m N #N为速度,2即可</span><br></pre></td></tr></table></figure><h1 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown lee:lee rslidar_sdk/ -R</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开机启动VPN脚本&quot;&gt;&lt;a href=&quot;#开机启动VPN脚本&quot; class=&quot;headerlink&quot; title=&quot;开机启动VPN脚本&quot;&gt;&lt;/a&gt;开机启动VPN脚本&lt;/h1&gt;&lt;p&gt;每次开机都要设置鼠标灵敏度和打开ssVPN操作,不如让这两行命令开机启动,省事.&lt;/</summary>
      
    
    
    
    <category term="工具技能" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="Ubuntu小操作" scheme="https://www.jaylee.top/tags/Ubuntu%E5%B0%8F%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>ROS之CMakeList</title>
    <link href="https://www.jaylee.top/2020/10/05/ROS%E4%B9%8BCMakeList/"/>
    <id>https://www.jaylee.top/2020/10/05/ROS%E4%B9%8BCMakeList/</id>
    <published>2020-10-05T12:20:25.000Z</published>
    <updated>2020-10-19T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考学习链接：</p><p><a href="https://www.cnblogs.com/Jessica-jie/p/6520481.html"><strong>catkin软件包的组成</strong></a></p><p><a href="https://blog.csdn.net/u010122972/article/details/78216013">CMakeList的基本写法</a></p><h1 id="CmakeList"><a href="#CmakeList" class="headerlink" title="CmakeList"></a>CmakeList</h1><p> <a href="https://blog.csdn.net/AdamShan/article/details/82901295"><strong>ROS：依赖文件和环境</strong></a></p><p> CMakeLists.txt文件是CMake构建系统的输入，在这里我们不会详细讨论CMake的写法（因为它本身可以很复杂），我们大致熟悉一下我们常用的CMake的语法：</p><p><code>cmake_minimum_required：</code>需要的CMake的最低版本<br><code>project():</code>包的名称<br><code>find_package()</code> 查找建构是需要的其他 CMake/Catkin 包<br><code>add_message_files() add_service_files() add_action_files</code> 生成Message /Service /Action<br><code>generate_messages()</code> 调用消息生成<br><code>catkin_package()</code> 指定包的构建信息<br><code>add_library()/add_executable()/target_link_libraries()</code> 用于构建的库，可执行代码</p><p>同样的，在<code>CMakeList</code>中，我们通过<code>find_package</code>查找这三个包的路径，然后将三个包添加到 <code>CATKIN_DEPENDS</code>, 在使用pcl库前，需要将PCL库的路径链接，通过<code>link_directories( $ &#123;PCL_LIBRARY_DIRS&#125;)</code>来完成，并在最后的<code>target_link_libraries</code>中添加<code>$&#123;PCL_LIBRARIES&#125;</code>。</p><p> <code>package.xml</code>的内容很简单，实际上就是这个包的描述文件， <code>build_depend</code> 和 <code>run_depend</code> 两个描述符分别指定了程序包编译和运行的依赖项，通常是所用到的库文件的名称。 在这里我们指定了三个编译和运行时依赖项，分别是<code>roscpp</code>（编写C++ ROS节点），<code>sensor_msgs</code>（定义了激光雷达的msg），<code>pcl_ros</code>（连接ROS和pcl库）。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考学习链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Jessica-jie/p/6520481.html&quot;&gt;&lt;strong&gt;catkin软件包的组成&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blo</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Cmake" scheme="https://www.jaylee.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Cmake/"/>
    
    
    <category term="CMake" scheme="https://www.jaylee.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>ROS学习笔记</title>
    <link href="https://www.jaylee.top/2020/10/05/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.jaylee.top/2020/10/05/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-05T12:20:25.000Z</published>
    <updated>2020-11-19T05:16:26.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h1><p>可以启动多个节点, 并传入节点需要的参数变量等. 同时也不需要先启动roscore了. </p><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span> = <span class="string">&quot;lidar_perception&quot;</span> <span class="attr">type</span> = <span class="string">&quot;slot_detection&quot;</span> <span class="attr">name</span> = <span class="string">&quot;detecting slots&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> = <span class="string">&quot;slot_width&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.7&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;thershold_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;lidar_perception&quot;</span> <span class="attr">type</span>=<span class="string">&quot;slot_detection&quot;</span> <span class="attr">arg</span>=<span class="string">&quot;$&#123;arg threshold_length&#125;&quot;</span> <span class="attr">name</span> &quot;<span class="attr">detection</span> <span class="attr">slots</span>&quot; /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>标签node</strong>表示运行包pkg, 中的可执行cpp文件type (若使用py脚本需要添加.py后缀), 然后将这个节点的ROS名字取为name. 还可以添加需要传入的变量参数,用arg传入. </p><p><strong>标签param</strong>表示定义一些参数名及其值. <strong>rosparam</strong>可以传入参数文件中所有参数.</p><p><strong>标签arg</strong>定义launch内部使用的变量参数,可供其他使用.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;slot_detection/thresh_l&quot;</span> <span class="attr">to</span>=<span class="string">&quot;thresh_l&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$&#123;dirname&#125;/other.launch&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>标签remap</strong>重新定义topic(或其他?)所有资源的名字, </p><p><strong>标签include</strong>嵌套使用另外一个launch文件.</p><a id="more"></a><h1 id="订阅-发布接口编写"><a href="#订阅-发布接口编写" class="headerlink" title="订阅/发布接口编写"></a>订阅/发布接口编写</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;std_msg/Strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    ros::init(argc,argv,<span class="string">&quot;listener&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Subscriber subscriber = </span><br><span class="line">        nh.subscribe(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>,callback);</span><br><span class="line">    <span class="comment">//ros::Publisher publiser = </span></span><br><span class="line">    <span class="comment">//  nh.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;,1);</span></span><br><span class="line">    <span class="comment">// publisher.publish(msg1);</span></span><br><span class="line">    ros::spin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;launch&quot;&gt;&lt;a href=&quot;#launch&quot; class=&quot;headerlink&quot; title=&quot;launch&quot;&gt;&lt;/a&gt;launch&lt;/h1&gt;&lt;p&gt;可以启动多个节点, 并传入节点需要的参数变量等. 同时也不需要先启动roscore了. &lt;/p&gt;
&lt;h2 id=&quot;简单实例&quot;&gt;&lt;a href=&quot;#简单实例&quot; class=&quot;headerlink&quot; title=&quot;简单实例&quot;&gt;&lt;/a&gt;简单实例&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;launch&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;pkg&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&amp;quot;lidar_perception&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&amp;quot;slot_detection&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&amp;quot;detecting slots&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&amp;quot;slot_width&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;1.7&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;thershold_length&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;1.5&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;pkg&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;lidar_perception&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;slot_detection&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;arg&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;$&amp;#123;arg threshold_length&amp;#125;&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt; &amp;quot;&lt;span class=&quot;attr&quot;&gt;detection&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;slots&lt;/span&gt;&amp;quot; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;launch&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;标签node&lt;/strong&gt;表示运行包pkg, 中的可执行cpp文件type (若使用py脚本需要添加.py后缀), 然后将这个节点的ROS名字取为name. 还可以添加需要传入的变量参数,用arg传入. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标签param&lt;/strong&gt;表示定义一些参数名及其值. &lt;strong&gt;rosparam&lt;/strong&gt;可以传入参数文件中所有参数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标签arg&lt;/strong&gt;定义launch内部使用的变量参数,可供其他使用.&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;launch&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;remap&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;from&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;slot_detection/thresh_l&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;to&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;thresh_l&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;$&amp;#123;dirname&amp;#125;/other.launch&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;launch&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;标签remap&lt;/strong&gt;重新定义topic(或其他?)所有资源的名字, &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标签include&lt;/strong&gt;嵌套使用另外一个launch文件.&lt;/p&gt;</summary>
    
    
    
    <category term="工具技能" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/"/>
    
    <category term="ROS" scheme="https://www.jaylee.top/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.jaylee.top/tags/ROS/"/>
    
    <category term="launch" scheme="https://www.jaylee.top/tags/launch/"/>
    
  </entry>
  
</feed>
