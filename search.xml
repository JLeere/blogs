<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>202011备忘录</title>
    <url>/2020/11/18/202011%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h1 id="2020年11月"><a href="#2020年11月" class="headerlink" title="2020年11月"></a>2020年11月</h1><h2 id="2020-10-31"><a href="#2020-10-31" class="headerlink" title="2020-10-31"></a>2020-10-31</h2><p>写完了minCD拟合和去除后视镜点云的方法</p>
<p><strong>明todo</strong>: </p>
<ul>
<li><del>检测拟合算法接口逻辑整理</del></li>
<li>位置估计整理</li>
</ul>
<h2 id="2020-11-01"><a href="#2020-11-01" class="headerlink" title="2020-11-01"></a>2020-11-01</h2><p>拟合算法逻辑，fitting_one_cluster_minCD.</p>
<p><strong>明todo:</strong></p>
<ul>
<li><del>缺省函数</del></li>
<li>位置估计代码</li>
</ul>
<h2 id="2020-11-03"><a href="#2020-11-03" class="headerlink" title="2020-11-03"></a>2020-11-03</h2><p><strong>todo</strong>:</p>
<ol>
<li><p>searching阶段到detection阶段的过度阶段，</p>
<p>​    <em>若通过跟踪列表筛选</em></p>
<ul>
<li>无序点云聚类拟合,trackinglist</li>
<li>对比searching阶段结果，提取出跟踪的列表中形成库位的两辆车vehicle2D编号</li>
</ul>
<p>​    <em>若通过变换ROI</em>: 先筛选点云在一定范围内,再聚类拟合.</p>
</li>
<li><p>detection阶段：</p>
<ul>
<li>输入两个聚类，minCD拟合</li>
<li>筛选出表征库位的4个角点</li>
<li>数据关联</li>
<li>坐标转换</li>
<li>EKF</li>
</ul>
</li>
<li><p>调试环境的使用。</p>
</li>
<li><p>位置估计的代码查看。</p>
</li>
</ol>
<p><strong>断点记录</strong>：</p>
<ol>
<li><del>minCD中box的传入和修改</del></li>
</ol>
<h2 id="2020-11-06"><a href="#2020-11-06" class="headerlink" title="2020-11-06"></a>2020-11-06</h2><p><strong>todo:</strong></p>
<ul>
<li><del>无序点云处理</del></li>
<li>【minCD】拟合算法还没有调参就绪. 去除后视镜的算法的进入条件dele_rule几乎都为false</li>
</ul>
<p><strong>断点记录:</strong></p>
<h2 id="2020-11-07"><a href="#2020-11-07" class="headerlink" title="2020-11-07"></a>2020-11-07</h2><p><strong>todo</strong></p>
<ul>
<li><del>ubuntu18.04</del></li>
<li><del>无序点云预处理</del></li>
</ul>
<h2 id="2020-11-08"><a href="#2020-11-08" class="headerlink" title="2020-11-08"></a>2020-11-08</h2><p>todo:</p>
<ul>
<li><del>调试环境搭建</del></li>
<li><del>Hexo笔记安装</del></li>
</ul>
<h2 id="2020-11-09"><a href="#2020-11-09" class="headerlink" title="2020-11-09"></a>2020-11-09</h2><p>TODO：</p>
<ul>
<li><del>无序点云处理</del></li>
<li><del>位姿态估计代码查看</del></li>
<li><del>两个矩形框推出slot_corner</del></li>
</ul>
<h2 id="2020-11-10"><a href="#2020-11-10" class="headerlink" title="2020-11-10"></a>2020-11-10</h2><p>TODO：</p>
<ul>
<li><del>两个矩形框推出slot_corner</del><ul>
<li>上一个时刻库位的角度没有传进来</li>
</ul>
</li>
<li>将三个雷达点云topic融合在一起</li>
<li>行位推算使用</li>
<li><del>ROS Parameter server</del></li>
</ul>
<p>duandian:</p>
<ul>
<li><del>数据关联</del></li>
</ul>
<h2 id="2020-11-11"><a href="#2020-11-11" class="headerlink" title="2020-11-11"></a>2020-11-11</h2><p>TODO：</p>
<ul>
<li><del>数据关联</del></li>
<li><del>tf使用</del></li>
<li><del>rviz Marker</del></li>
</ul>
<h2 id="2020-11-12"><a href="#2020-11-12" class="headerlink" title="2020-11-12"></a>2020-11-12</h2><p>TODO：</p>
<ul>
<li><del>rviz Marker</del></li>
<li><del>坐标变换</del></li>
<li><del>tf使用</del></li>
<li><strong>误差的传播分析</strong></li>
</ul>
<h2 id="2020-11-13"><a href="#2020-11-13" class="headerlink" title="2020-11-13"></a>2020-11-13</h2><p>TODO：</p>
<ul>
<li><del>坐标变换，eigen实现buliao</del></li>
<li><del>小论文PPT</del></li>
</ul>
<h2 id="2020-11-15"><a href="#2020-11-15" class="headerlink" title="2020-11-15"></a>2020-11-15</h2><p>TODO：</p>
<ul>
<li><del>EKFB编写</del></li>
</ul>
<h2 id="2020-11-16"><a href="#2020-11-16" class="headerlink" title="2020-11-16"></a>2020-11-16</h2><p>todo：</p>
<ul>
<li><del>Marker操练</del></li>
<li><del>EKFV编写</del></li>
</ul>
<h2 id="2020-11-17"><a href="#2020-11-17" class="headerlink" title="2020-11-17"></a>2020-11-17</h2><p>todo：</p>
<ul>
<li><del>定位参考点切换</del><ul>
<li>利用点和角度来表征库位，而不是4个点。这样每次生成库位都判断一下入口点和他们的角度，比起后续对4个点的排序处理容易一些。【有时间可以改改】</li>
</ul>
</li>
<li>可视化调试</li>
<li><em>DR节点的行位推算的增量话题怎么传递到检测节点？</em>【callback函数订阅多个参数】</li>
<li><em>检测阶段的targets_template怎么传递到跟踪阶段？什么时候判断检测收敛了？</em>【三个阶段的过度】</li>
<li><em>拟合算法的效果改善问题</em></li>
<li><del>工作的最终决定</del></li>
<li>搜寻库位阶段还要改一改库位的表征</li>
</ul>
<h2 id="2020-11-18"><a href="#2020-11-18" class="headerlink" title="2020-11-18"></a>2020-11-18</h2><p><del>体检</del></p>
<h2 id="2020-11-19"><a href="#2020-11-19" class="headerlink" title="2020-11-19"></a>2020-11-19</h2><p><del>大论文大纲</del></p>
<p>2020-12-18 没写实车实验，耗时一个月。查重1.3%</p>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>202012备忘录</title>
    <url>/2020/12/18/202012%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h1 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h1><h2 id="2020-12-18"><a href="#2020-12-18" class="headerlink" title="2020-12-18"></a>2020-12-18</h2><p>大论文写完了，3天打鱼两天晒网那种方式磨叽完了，实车实验部分还没有做，先这样拿去抽盲吧，抽不中就慢慢做是测试样，抽中就可能延毕，一场豪赌。</p>
<p>论文质量我是不敢苟同的，实话说，实验的效果我也是没有底的。现在的心情和当年本科毕设一样难过，感觉自己是写了一坨又臭又长的shit。</p>
<p>为了给自己的学术生涯画上一个比较圆的句号，让自己进入社会之后更有底气和自信一些的话，我必须后面3个月里把实验做好，把自己想要实现的原理实现。同时巩固之前欠下的知识。</p>
<ol>
<li>库位搜寻实现本周</li>
<li>库位检测实现一周</li>
<li>库位跟踪实现一周</li>
</ol>
<h1 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h1><p>本周任务：</p>
<ol>
<li><p><del>搜寻库位实验</del></p>
</li>
<li><p>三个雷达数据同时接受并标定</p>
</li>
</ol>
<h2 id="2020-12-21"><a href="#2020-12-21" class="headerlink" title="2020-12-21"></a>2020-12-21</h2><blockquote>
<p>又颓废了一个周末，啥也没干。早上一定要起来啊，不要等着手机没电了才起来。就算只有一小时也能干很多事。</p>
</blockquote>
<ol>
<li>库位搜寻调试:<ul>
<li><del>寻找库位的矩形表征，写求解成员函数</del>。</li>
</ul>
</li>
</ol>
<h2 id="2020-12-23"><a href="#2020-12-23" class="headerlink" title="2020-12-23"></a>2020-12-23</h2><blockquote>
<p>昨天开例会又没能走出寝室，今天我要证明在寝室也能好好学习。必须紧张起来了，想想昨晚不能入眠的原因。</p>
</blockquote>
<ol>
<li>库位搜寻：<ul>
<li>整合到detection节点中调试运行。<strong>发现MST可能不适用有立柱的情况，不固定矩形框比例不能适用。</strong></li>
</ul>
</li>
</ol>
<h2 id="2020-12-25"><a href="#2020-12-25" class="headerlink" title="2020-12-25"></a>2020-12-25</h2><blockquote>
<p>昨天又没有走出寝室，走出舒适区，养成学习常态，迎接社会的打磨。</p>
</blockquote>
<p>今天的目标是：</p>
<ol>
<li>适配新的矩形库位推导方式。</li>
</ol>
<p>为什么修改后出现这个问题？1，删除了固定障碍物比例的句子  2，修改了分类为vehicle型的rule，加入立柱的判断依据。</p>
<p>–&gt; MST分组失败；发现BBox角度定义的理解错误</p>
<h2 id="2020-12-26"><a href="#2020-12-26" class="headerlink" title="2020-12-26"></a>2020-12-26</h2><blockquote>
<p>这个星期又过了，今天又没能早起，至少现在开始努力解决一个一个的问题</p>
</blockquote>
<p>今天的任务是：</p>
<ol>
<li><del>解决bbox的定义匹配问题</del></li>
<li>实现矩形表征库位的输出</li>
<li>改善搜寻库位的算法效果</li>
</ol>
<h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a><strong>问题记录</strong></h3><ul>
<li>编译后还是运行之前的版本。拟解决：cmakeType Debug。重启几次</li>
<li>除法“70/180*M_PI” 默认 <strong>整数除法</strong>，注意小数精度，拟解决：“70.0f/180.0f *M_PI”</li>
<li><strong>一般式直线方程</strong>： $cos\alpha x +sin\alpha y+ p =0 $ 中指的是直线法向量的角度，与直线方向向量垂直。</li>
</ul>
<h2 id="2020-12-27"><a href="#2020-12-27" class="headerlink" title="2020-12-27"></a>2020-12-27</h2><blockquote>
<p>昨天遇到好多新的问题，莫名其妙的问题。看来还需要下很多功夫的，不能吊儿郎当的，必须认真。</p>
</blockquote>
<p>今天的任务是：</p>
<ol>
<li><del>输出myrect表征库位</del></li>
<li>改善效果</li>
</ol>
<p><strong>调试No1:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> case2(delta_angle=180):A,B,theta_PS  88,92.6667,-89.6667</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> filter_by_size: 0 width: 2.31299 deep: 9.56939</span></span><br></pre></td></tr></table></figure>

<p>theta_PS是对的，库位尺寸depp为什么这么大不可能呀？</p>
<ul>
<li><strong>定比分点公式是不是用错了</strong>，参考链接：<a href="https://zhuanlan.zhihu.com/p/26374239">https://zhuanlan.zhihu.com/p/26374239</a></li>
<li>采用一般式直线方程求解投影点坐标更简单</li>
</ul>
<p><strong>调试NO2</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case0(half),A,B,theta_PS: 176,176,-4</span><br><span class="line">filter_by_size: 1 width: 4.1423 deep: 6.95453	#看起来正常</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case1(delta_angle=90):A,B,theta_PS  1.66667,86.3333,-1	#有问题，应考虑库位类型</span><br></pre></td></tr></table></figure>

<ul>
<li>case1中出现这种情况，是由于只看见了某一辆车的车头，其拟合框的车宽大于车身的长度，此时以长边为准的角度会差90度，应该旋转修正面积小的矩形的朝向。</li>
</ul>
<p><strong>调试No3：</strong></p>
<div align="left"> <img src="/2020/12/18/202012%E5%A4%87%E5%BF%98%E5%BD%95/image-20201227220403955.png" alt="image-20201227220403955" style="zoom:30%;">

<p>程序中给的角度是库位中线的角度，不等于BBox的角度。通过比较width和deep的长度分别给BBox构造函数初始化</p>
<h3 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a><strong>问题总结：</strong></h3><ul>
<li><div align="left"><img src="/2020/12/18/202012%E5%A4%87%E5%BF%98%E5%BD%95/image-20201227224538834.png" alt="image-20201227224538834" style="zoom:33%;">

<p>地下车库的<strong>立柱</strong>被识别成障碍物让库位被分类为占据</p>
</div></li>
<li><p><strong>abs和fabs问题</strong>，abs给float型求值有时候为0，得用fabs</p>
</li>
<li><p><strong>vector问题</strong>，当初始化时给出大小为4，后续用push_back()会在末尾添加，容器大小变为5，前几项仍为初始值0.</p>
</li>
<li><p>求库位中线向量的时候用方向向量的加法可能会比较方便，<em>未实现，有时间可以尝试</em></p>
</li>
<li><p>BBox的构造函数要弄清楚</p>
</li>
</ul>
<h1 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h1><blockquote>
<p>上一周在周末的努力下算是勉强调通了搜寻阶段的实验，事实证明任何事情只要迈出第一步其实也没有那么难的。三天打鱼两天晒网的工作状态实在不好，必须将学习常态化，融入自己的热爱生活的理念中去，不断进步。这周是2020年的最后一周的，希望给它画上一个圆圆的句号。</p>
</blockquote>
<p>本周的主要任务是：</p>
<ol>
<li>检测算法的输入接口：<ol>
<li>三个雷达的数据，</li>
<li>目标库位的锁定,</li>
<li>底盘DR数据传入</li>
</ol>
</li>
<li>检测算法的调通</li>
<li>多雷达标定的改良</li>
</ol>
<h2 id="2020-12-28"><a href="#2020-12-28" class="headerlink" title="2020-12-28"></a>2020-12-28</h2><blockquote>
<p>昨天最后时刻调通了，勉勉强强算是完成了任务。今天修葺一下之后，开始攻克检测算法吧！</p>
</blockquote>
<p>今天的任务是：</p>
<ul>
<li><del>修葺归档，搜寻算法</del></li>
<li>开启检测算法的整理</li>
</ul>
<h3 id="问题记录-1"><a href="#问题记录-1" class="headerlink" title="问题记录"></a>问题记录</h3><p>今日全场最佳耗时问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> angle_AB = <span class="built_in">fabs</span>(coefficient_line_AB[<span class="number">1</span>]) &lt; <span class="number">1e-6</span> ? M_PI_2 : <span class="built_in">atan</span>(-coefficient_line_AB[<span class="number">0</span>]/coefficient_line_AB[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>在讨论分母不等于0时，没有加绝对值，浪费好多时间照这个问题。</p>
<blockquote>
<p>头疼欲裂开</p>
</blockquote>
<h2 id="2020-12-29"><a href="#2020-12-29" class="headerlink" title="2020-12-29"></a>2020-12-29</h2><blockquote>
<p>今天很早就被吵醒了，睡不着，跑去看了部电影：心灵奇旅，好看，打算二刷。现在收心回来好好学习吧。</p>
</blockquote>
<p>今天的任务是：</p>
<ol>
<li><del>整理编译检测阶段的算法</del></li>
<li>修改各个阶段的接口。</li>
</ol>
<blockquote>
<p>看了看同步多个topic的ROS类,明天写写,然后和chen merge一下新的代码.</p>
</blockquote>
<h2 id="2020-12-30"><a href="#2020-12-30" class="headerlink" title="2020-12-30"></a>2020-12-30</h2><blockquote>
<p>现在18:00才来到实验室,今天没起得来,没想到下午也没起得来,太冷了,虽然也不是借口, 在这种时候紧张起来,我就是紧张不起来.</p>
</blockquote>
<p>今天的任务是:</p>
<ol>
<li><del>编写多个topic同步的节点</del></li>
</ol>
<p>把3个topic用同步器收到一个callback函数中，收取transform信息，将消息转换到pcl中合在一起，写好了没验证。</p>
<blockquote>
<p>没有验证,好乏力,感觉感冒了</p>
</blockquote>
<h2 id="2020-12-31"><a href="#2020-12-31" class="headerlink" title="2020-12-31"></a>2020-12-31</h2><blockquote>
<p>今天下午和chen在寝室讨论了一下代码的merge，他定义了新的消息格式和内容。寝室太冷了。</p>
</blockquote>
</div>]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="2021年3月1日，Mon"><a href="#2021年3月1日，Mon" class="headerlink" title="2021年3月1日，Mon."></a>2021年3月1日，Mon.</h2><ol>
<li>修改论文，摘要和结论，送评阅<ul>
<li>X方向最大误差的情况分析：主要原因+次要原因，定性定量，数据支撑</li>
<li>与（检测）单线和（跟踪）DR的对比</li>
</ul>
</li>
</ol>
<h2 id="2021年3月4日，Wen"><a href="#2021年3月4日，Wen" class="headerlink" title="2021年3月4日，Wen."></a>2021年3月4日，Wen.</h2><ol>
<li><p>梳理论文逻辑，分析清楚问题</p>
<ol>
<li><p>量化 定位的误差。</p>
<p>–&gt;&gt;按照相对位置关系，更换定位的基准试试</p>
<p>–&gt;&gt;分析最大误差量化其构成</p>
</li>
<li><p>由单线和DR引出问题分析 –&gt;&gt; 对比性能和改善的地方</p>
</li>
</ol>
</li>
<li><p>制作PPT（3月9号）</p>
</li>
</ol>
<h2 id="2021-03-05，Thur"><a href="#2021-03-05，Thur" class="headerlink" title="2021-03-05，Thur."></a>2021-03-05，Thur.</h2><ol>
<li><h3 id="分析jiaoyun-ver2，修改算法"><a href="#分析jiaoyun-ver2，修改算法" class="headerlink" title="分析jiaoyun-ver2，修改算法"></a>分析jiaoyun-ver2，修改算法</h3><ol>
<li>最大误差情形1，残缺+噪点？</li>
</ol>
<p><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305103614587.png" alt="image-20210305103614587" style="zoom:40%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305104721877.png" alt="image-20210305104721877" style="zoom:50%;"></p>
<ul>
<li><p>加入统计滤波看看噪声点效果如何，</p>
<p>== 滤波参数25\1.0，过滤太多了，调小一点. 较远的地方B车点云已经被删除了大部分。</p>
<p>==25\3.0,要好一些了，当噪点还是很抖动</p>
<p>==25\2.0, 点云太小，偏向1.0</p>
<p>==35/2.0，还是很小</p>
<p>== 40/2.5，<strong>OK</strong></p>
</li>
<li><p>长宽的拓展方向总是有错会一直抖动，会不会带来的误差比不拓展还大？</p>
<p>== 为啥拓展长？为了解决库位的四个点找不准？——但是拓展不准，反向之后更会造成4个点排序混乱，是否有必要？</p>
<p>==为啥拓展宽？为了弥补看不到圆角。感觉没啥必要，更换定位路标更重要。</p>
<p>== 尝试取消拓展，效果如何？</p>
<ul>
<li>无拓展</li>
</ul>
<p><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305155221774.png" alt="image-20210305155221774" style="zoom:%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305155744775.png" alt="image-20210305155744775"></p>
<ul>
<li>拓展</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code> ![image-20210305160010148](202103备忘录/image-20210305160010148.png)![image-20210305155837176](202103备忘录/image-20210305155837176.png)

 == 从观测值来看，*不拓展好那么一丢丢*；倒车大转角处拓展就会很差，直接失效启动行位推算了。最后位置y方向拓展会好一些

 ![image-20210305175412358](202103备忘录/image-20210305175412358.png)

 &lt;img src=&quot;202103备忘录/image-20210305182129241.png&quot; alt=&quot;image-20210305182129241&quot; style=&quot;zoom:;&quot; /&gt;![image-20210305182202941](202103备忘录/image-20210305182202941.png)

 ​                                                           </code></pre>
<ul>
<li><p>按照相对位置关系判断以哪一个做为基准点？</p>
<p>== 对比下有switch算法和没有的差别</p>
</li>
</ul>
<ol start="2">
<li><p>标的真值也发生了偏差，坐标转换过程中有偏差？</p>
<p><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305103614587.png" alt="image-20210305103614587" style="zoom: 50%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305180903787.png" alt="image-20210305180903787" style="zoom:50%;"></p>
<p><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305181419945.png" alt="image-20210305181419945" style="zoom:33%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305180903787.png" alt="image-20210305180903787" style="zoom:50%;"></p>
<p><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305181419945.png" alt="image-20210305181419945" style="zoom:30%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305181545324.png" alt="image-20210305181545324" style="zoom: 33%;"></p>
<p><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305181419945.png" alt="image-20210305181419945" style="zoom: 33%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305181545324.png" alt="image-20210305181545324" style="zoom:50%;"></p>
</li>
</ol>
   <img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210305182025204.png" alt="image-20210305182025204" style="zoom:50%;">



<h2 id="2021-03-07，Sunday"><a href="#2021-03-07，Sunday" class="headerlink" title="2021-03-07，Sunday"></a>2021-03-07，Sunday</h2><h3 id="jiaoyun-ver2分析"><a href="#jiaoyun-ver2分析" class="headerlink" title="jiaoyun-ver2分析"></a>jiaoyun-ver2分析</h3><p>最大误差，情形一，远离库位。</p>
<p><strong>主要原因</strong>：点云残缺，</p>
<p><strong>次要原因</strong>：噪点，拓展框抖动</p>
<ol>
<li><p>次要原因：噪点</p>
<ul>
<li>k/std = 70/1.0;  leafsize0.05/0.05/1.0</li>
</ul>
<p>== 噪点过滤得太猛了</p>
<ul>
<li><p>k/std = 50/1.5; </p>
<img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210307112350352.png" alt="image-20210307112350352" style="zoom:33%;">
</li>
<li><p>voxelGrid Z-leafsize增大 </p>
<p>==效果聊胜于无</p>
</li>
<li><p>minimunPointsNumber（2）leafsize=0.05/0.05/2</p>
<img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210307140809379.png" alt="image-20210307140809379" style="zoom:50%;">

<p>==minNumber(1) leafsize=0.04/0.04/5,很难调好，k,sd=50,2.0</p>
<p>==<em>放弃噪音点优化这个吧。</em></p>
</li>
</ul>
</li>
<li><p>主要原因，残缺</p>
<p>失效时刻1，离B车太远了残缺——<strong>ICP补全</strong>，A车库位角又残缺了——<strong>拓展宽度</strong> &amp; <strong>更换定位基准</strong></p>
<p>按照相对位置关系判断以哪一个做为基准点？对比下有switch算法和没有的差别？</p>
<ul>
<li><p>按照库位坐标系下自车位置，切换使用B点定位</p>
<p>== try1好像没起作用</p>
<p>== try2 滤波后，点残缺但是效果变好了,残缺厉害后，拓展也容易失效了。</p>
<p>==3 好像误差是小了一点点，&gt;1.5m</p>
</li>
<li><p>拓展长度容易翻转，失效</p>
<p>== 都拓展，然后使用B车定位，噪音稍微消除k,sd=50,1.5</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>== 对比下有switch算法和没有的差别</p>
<p>==有switch &amp; 强制B车定位 无tuozhan</p>
<p><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210307204559391.png" alt="image-20210307204559391"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210307205531194.png" alt="image-20210307205531194" style="zoom:80%;"></p>
<p>==无switch和强制B，有拓展</p>
<p>== <img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210307204851097.png" alt="image-20210307204851097" style="zoom:80%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210307205431178.png" alt="image-20210307205431178"></p>
<p>=有switch无强制B，有拓展</p>
<p><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/x.svg" alt="x" style="zoom:80%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/position.svg" alt="position" style="zoom:80%;"></p>
</li>
</ul>
<p>   <img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/y.svg" alt="y" style="zoom:80%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/angle.svg" alt="angle" style="zoom:80%;"></p>
<p>   <img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/x_err.svg" alt="x_err" style="zoom:80%;"><img src="/2021/03/09/202103%E5%A4%87%E5%BF%98%E5%BD%95/image-20210307211624706.png" alt="image-20210307211624706" style="zoom:80%;"></p>
<p>   ==可以看出在大误差情形1的时候，依靠残缺的B定位还没有拓展可靠；而在内部的时候有switch明显改善很多。</p>
]]></content>
  </entry>
  <entry>
    <title>C++代码风格</title>
    <url>/2020/11/03/C++%20to%20learn/</url>
    <content><![CDATA[<h1 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h1><p>成员函数缺省参数值通常写在头文件或者源文件二者之一的地方，通常写在源文件中，但是会造成后果，没太看明白。</p>
<h1 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h1><p>参考文章：<a href="https://blog.csdn.net/guyue35/article/details/46775211">https://blog.csdn.net/guyue35/article/details/46775211</a></p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="to-learn"><a href="#to-learn" class="headerlink" title="to learn"></a>to learn</h2><ul>
<li><p>const</p>
</li>
<li><p>static</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CXX零碎知识点(二)</title>
    <url>/2020/10/18/CXX%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="2020年11月"><a href="#2020年11月" class="headerlink" title="2020年11月"></a>2020年11月</h1><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h2 id="条件-表达式"><a href="#条件-表达式" class="headerlink" title="条件?=表达式"></a>条件?=表达式</h2><p><code>int v = (w&lt;0) ? -1:1</code>表示如果w小于0, v取-1, 否则取1.</p>
<h2 id="子类虚函数调用"><a href="#子类虚函数调用" class="headerlink" title="子类虚函数调用"></a>子类虚函数调用</h2><p><a href="https://blog.csdn.net/ly890700/article/details/55803398">参考链接</a></p>
<p>覆盖override: 派生类重新写父类中virtual虚函数的实现, 参数列表返回类型需要保持一致.</p>
<p>重载overload: 两个同名函数的参数列表不同, 包括虚函数</p>
<blockquote>
<p>重定义: 重定义也是描述分别位于父类与子类中的同名函数的，但返回值可以不同。</p>
<ul>
<li>如果参数列表不同，这时子类中重定义的函数不论是否有virtual关键字，都会隐藏父类的同名函数。</li>
<li>如果参数列表相同，但父类中的同名函数没有virtual关键字修饰，此时父类中的函数仍然被隐藏。</li>
</ul>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//父类中定义了两个重载函数f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::f</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f(int) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f() &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===============================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span>)</span></span>; <span class="comment">//子类重定义了函数f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">float</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::f(float)&quot;</span> &lt;&lt; showpoint &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p1 = <span class="keyword">new</span> Base;</span><br><span class="line">    p1-&gt;f(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    Derived *p2 = <span class="keyword">new</span> Derived;<span class="comment">//定义指向子类的指针p2</span></span><br><span class="line">    p2-&gt;f(<span class="number">2.0</span>); <span class="comment">//调用子类::f(float),可运行 输出Derived::f(float)2.00000</span></span><br><span class="line">    p2-&gt;f(<span class="number">3</span>);<span class="comment">// 调用子类::f(float), 可运行输出Derived::f(float)3.00000</span></span><br><span class="line">    </span><br><span class="line">    Base *p3 = <span class="keyword">new</span> Derived; <span class="comment">//定义指向父类的指针p3,实际指向子类,仍会调用父类的函数f(int)</span></span><br><span class="line">    p3-&gt;f(<span class="number">2.0</span>);<span class="comment">//由于重定义(重载)的Derived::f(float)并没有覆盖掉父类的f()函数, 因此会调用父类::f(int), 输出Base::f(int) 2</span></span><br><span class="line">    p3-&gt;f(<span class="number">1</span>);<span class="comment">//可运行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line">    <span class="keyword">delete</span> p3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此在写子类的虚函数的时候, 如果参数列表不同, 可以不加override关键字, 不用覆盖的功能,而直接使用重定义或者叫重载. </p>
<p>只是需要注意定义该子类对象时不能是指向父类的指针<code>Base *p = new Derived</code>, 否则父类的同名函数不会隐藏,而被调用.</p>
<h2 id="private-public"><a href="#private-public" class="headerlink" title="private / public"></a>private / public</h2><p><strong>访问范围</strong>:</p>
<ul>
<li>private: 只能被该类中的函数、该类的友元函数访问，该类的<strong>实例对象</strong>和<strong>子类函数</strong>都不能访问</li>
<li>protected成员，可以被该类中的函数、类的友元函数、子类函数访问，该<strong>类的对象</strong>不能访问</li>
<li>public成员, 可以被类中的函数、友元函数、类的实例对象、子类成员函数<strong>均可访问</strong>.</li>
</ul>
<p><strong>继承权限</strong>：</p>
<ul>
<li>public：可以访问父类的所有public成员</li>
<li>protected：父类的public和protected都变成子类的protected</li>
<li>private：父类的所有成员都变成子类的private</li>
</ul>
<h2 id="const引用传参"><a href="#const引用传参" class="headerlink" title="const引用传参"></a>const引用传参</h2><p>定义一个类，类中定义<code>int value()</code>函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mc_int</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="keyword">int</span> val;      <span class="comment">//actual int</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;  <span class="comment">//Returns value</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//Changes and returns value</span></span><br><span class="line">        mc_int();  <span class="comment">//Default constructor</span></span><br><span class="line">        mc_int(<span class="keyword">int</span>);<span class="comment">//Create from int</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">asBytes</span><span class="params">(<span class="keyword">char</span>*)</span></span>; <span class="comment">//generate byte array</span></span><br><span class="line"></span><br><span class="line">        mc_int&amp; <span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">        mc_int&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mc_int&amp;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> endianity;  <span class="comment">//true for little</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当外部定义时采用常引用<code>mc_int&amp; operator=(const mc_int&amp;);</code>报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mc_int&amp; mc_int::<span class="keyword">operator</span>=(<span class="keyword">const</span> mc_int&amp; other) &#123;</span><br><span class="line">            val = other.value();  </span><br><span class="line">            <span class="comment">//    |--------&gt;Error: No instance of overloaded function matches the argument list and object (object has type quelifiers that prevent the match)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因在于：<code>other</code>对象被常引用，意指该对象不会被修改内部成员。而调用的成员函数<code>other.value()</code>没有被声明为仅访问函数，因此编译器认为该函数可能会改变常引用的对象<code>other</code>而报错。</p>
<p>修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//申明为仅访问函数</span></span><br></pre></td></tr></table></figure>

<h2 id="array-vector区别"><a href="#array-vector区别" class="headerlink" title="array vector区别"></a>array vector区别</h2><h2 id="子类构造函数调用父类的构造函数"><a href="#子类构造函数调用父类的构造函数" class="headerlink" title="子类构造函数调用父类的构造函数"></a>子类构造函数调用父类的构造函数</h2><p><a href="https://blog.csdn.net/fchyang/article/details/81508030">https://blog.csdn.net/fchyang/article/details/81508030</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ParkingSlot::ParkingSlot(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PointType2f&gt; rect_points):Object2D(rect_points)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a;</span><br><span class="line"><span class="keyword">double</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a);</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">int</span>(a);</span><br><span class="line"><span class="keyword">double</span> d  = (<span class="keyword">double</span>)a;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>泊车感知框架阅读笔记</title>
    <url>/2020/06/28/LiDAR-Perception%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="lidar-perception-调试"><a href="#lidar-perception-调试" class="headerlink" title="lidar_perception 调试"></a>lidar_perception 调试</h1><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>从Chen的仓库中克隆最新分支dev,并转移到自己新建的分支dev_Lee</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://***</span><br><span class="line">git checkout dev</span><br><span class="line">git checkout -b dev_Lee</span><br></pre></td></tr></table></figure>

<h2 id="文件架构"><a href="#文件架构" class="headerlink" title="文件架构"></a>文件架构</h2><p><strong>根目录</strong>:拉取下来的lidar_perception是ros工作空间的一个packege<br><strong>一级目录</strong>:</p>
<ul>
<li>include(头文件.h,每个阶段步骤所包括的类及其方法的声明),</li>
<li>src(源文件.cpp,对头文件类的方法的具体实现进行描述,类外申明),</li>
<li>node(*.cpp,调用其他各类方法的主函数,还包括与ros进行通信),</li>
<li>rviz(显示的配置设置)</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>配置好packege.xml和CMakeLists,成功catkin_make编译后,会在workspace的devel文件夹下生成release版本的可执行文件.</p>
<blockquote>
<p>cmake和catkin_make编译都是生成release版本,优化较好跑得快,而调试用生成debug版本,可以设置断点。</p>
</blockquote>
<p>打开roscore,运行主节点node,将采集的点云包rosbag文件play,自动发布到topic中,打开rviz进行显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun &lt;rospackage&gt; node</span><br><span class="line">rosbag play ~&#x2F;rosbagfiles&#x2F;**.bag -l -r 0.1</span><br><span class="line">rviz</span><br></pre></td></tr></table></figure>

<p>当然，更方便的方法就是将多节点运行顺序写到roslaunch文件中，一键启动。<br><code>roslaunch &lt;rospackage&gt; **.launch</code></p>
<h2 id="算法细节笔记"><a href="#算法细节笔记" class="headerlink" title="算法细节笔记"></a>算法细节笔记</h2><ul>
<li>基于环视图方法组织点云, 进行地面切除和点云聚类.</li>
<li>再在鸟瞰图中拟合, 限定拟合框的长宽比, 筛选出车辆类型的拟合框.</li>
</ul>
<a id="more"></a>

<h1 id="自定义接口"><a href="#自定义接口" class="headerlink" title="自定义接口"></a>自定义接口</h1><h2 id="my-point-type-h"><a href="#my-point-type-h" class="headerlink" title="my_point_type.h"></a>my_point_type.h</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointXYZIR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PCL_ADD_POINT4D <span class="comment">//???</span></span><br><span class="line">    <span class="keyword">float</span> intensity;</span><br><span class="line">    <span class="keyword">uint16_t</span> ring</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW <span class="comment">// make sure our new allocators are aligned</span></span><br><span class="line">    PointXYZIR()&#123;&#125;</span><br><span class="line">    PointXYZIR(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> intensity, <span class="keyword">uint16_t</span> ring):x(x),y(y),z(z),intensity(intensity),ring(ring)&#123;&#125;</span><br><span class="line">&#125; EIGEN_ALIGN16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> RichPoint = PointXYZIR;</span><br><span class="line"><span class="keyword">using</span> CloudType = pcl::PointCloud&lt;RichPoint&gt;;</span><br><span class="line"><span class="keyword">using</span> VectorType = <span class="keyword">typename</span> pcl::PointCloud&lt;RichPoint&gt;::VectorType;</span><br><span class="line"><span class="keyword">using</span> CloudTypePtr = <span class="keyword">typename</span> CloudType::Ptr;</span><br><span class="line"><span class="keyword">using</span> CloudTypeConstPtr = <span class="keyword">typename</span> CloudType::ConstPtr;</span><br><span class="line"><span class="keyword">using</span> CloudTypePtrList = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CloudTypePtr&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="定义CTimer"><a href="#定义CTimer" class="headerlink" title="定义CTimer"></a>定义CTimer</h2><p>在聚类中,的<strong>目的</strong>是干嘛?</p>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ul>
<li><del>共享指针make_shared</del></li>
<li><del>Eigen库</del></li>
</ul>
<h1 id="to-ask"><a href="#to-ask" class="headerlink" title="to ask"></a>to ask</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RangeMapCloudPtr cloud = boost::make_shared&lt;RangeMapCloud&gt;(<span class="built_in">std</span>::move(*pcl_cloud));</span><br><span class="line"><span class="comment">//智能指针</span></span><br><span class="line"></span><br><span class="line">assert(<span class="literal">nullptr</span> == _projection);</span><br><span class="line"></span><br><span class="line">RangeMapCloud(RangeMapCloud &amp;&amp;cloud) : _projection&#123;<span class="built_in">std</span>::move(cloud._projection)&#125;,<span class="comment">//初始化列表</span></span><br><span class="line">_tensor_class&#123;cloud._tensor_class&#125;</span><br><span class="line"><span class="comment">// _sensor_pose&#123;cloud._sensor_pose&#125;</span></span><br><span class="line">&#123;</span><br><span class="line">    ((Base *)<span class="keyword">this</span>)-&gt;swap(cloud);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">double</span> _calc_criterion(<span class="keyword">const</span> Eigen::MatrixX2f &amp;points_mat, <span class="keyword">const</span> <span class="keyword">double</span> angle_rad, BBox &amp;box) <span class="keyword">const</span> <span class="keyword">override</span>;</span><br><span class="line"><span class="comment">//虚拟函数,可让派生类自己写定义</span></span><br><span class="line"><span class="comment">//override,覆盖父类的同名函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> l_fitting = LOrientationFitting();<span class="comment">//后者是一个类,这么初始化怎么回事?</span></span><br><span class="line"><span class="comment">// A: 赋值构造函数.</span></span><br></pre></td></tr></table></figure>

<h1 id="库函数调用记录"><a href="#库函数调用记录" class="headerlink" title="库函数调用记录"></a>库函数调用记录</h1><h2 id="openCV"><a href="#openCV" class="headerlink" title="openCV"></a>openCV</h2><p>cv::contourArea(convex_hull);</p>
<p>cv:minEnclosingCircle(convex_hull,center,radius)</p>
<p>cv::convexHull</p>
<p>cv::pointPolygonTest</p>
<h2 id="PCL"><a href="#PCL" class="headerlink" title="PCL"></a>PCL</h2><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<ol>
<li><p>在将车辆点云分成4部分,遍历矩阵,将每个点放到其所属类中:</p>
</li>
<li><p>删除pointCloud中不符合条件的点: <code>group.points.erase(index)</code></p>
</li>
<li><p>VectorType怎么使用?</p>
</li>
</ol>
<h2 id="std"><a href="#std" class="headerlink" title="std"></a>std</h2><ol>
<li><p>std::move</p>
</li>
<li><p>vetor.reserve()和vector.resize()有何不同?</p>
</li>
</ol>
<p>=======<br>pcl::VoxelGrid</p>
<h2 id="std-1"><a href="#std-1" class="headerlink" title="std"></a>std</h2><p>std::log</p>
<p><code>std::for_each(points.begin(), points.end(), [&amp;pv](const PointType2f &amp;p) &#123; pv.push_back(p); &#125;);</code></p>
<h2 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h2><p>Eigen::Rotation2Df</p>
<p>std::list</p>
<p>std::pair</p>
<p>std::Array</p>
<h2 id="Eigen-1"><a href="#Eigen-1" class="headerlink" title="Eigen"></a>Eigen</h2><p>Eigen::Rotation2Df</p>
<p>Eigen::Affine</p>
<h1 id="Problem-record"><a href="#Problem-record" class="headerlink" title="Problem record"></a>Problem record</h1><blockquote>
<p>By not providing “Findcatkin.cmake” in CMAKE_MODULE_PATH this project has<br>asked CMake to find a package configuration file provided by “catkin”, but<br>CMake did not find one.</p>
</blockquote>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>lidar</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/14/C++%E6%9C%80%E5%80%BC%E5%B8%B8%E9%87%8F%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="C-C-中-int-float-double-最大值，最小值"><a href="#C-C-中-int-float-double-最大值，最小值" class="headerlink" title="C/C++ 中 int float double 最大值，最小值"></a>C/C++ 中 int float double 最大值，最小值</h1><p><a href="https://blog.csdn.net/ACb0y/article/details/5336822">https://blog.csdn.net/ACb0y/article/details/5336822</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;float.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int 类型能存储的最大值和最小值&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;INT_MAX = &quot;</span> &lt;&lt; INT_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;INT_MIN = &quot;</span> &lt;&lt; INT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long 类型能存储的最大值和最小值&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LONG_MAX = &quot;</span> &lt;&lt; LONG_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LONG_MIN = &quot;</span> &lt;&lt; LONG_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long 类型能存储的最大值和最小值&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LONG_LONG_MAX = &quot;</span> &lt;&lt; LONG_LONG_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LONG_LONG_MIN = &quot;</span> &lt;&lt; LONG_LONG_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;float 类型能存储的最大值和最小值&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;FLT_MAX = &quot;</span> &lt;&lt; FLT_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;FLT_MIN = &quot;</span> &lt;&lt; FLT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double 类型能存储的最大值和最小值&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;DBL_MAX = &quot;</span> &lt;&lt; DBL_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;DBL_MIN = &quot;</span> &lt;&lt; DBL_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int和long都是用32位来存储最大值和最小值分别为2147483647（2^31-1 ~ 10^9）， -2147483648(-2^31)；</p>
<p>long long 是用64位来存储最大值和最小值分别为9223372036854775807（10^18），-9223372036854775808；</p>
<p>float的最大值和最小值分别为3.40282e+038（10^38），1.17549e-038（10^-38）；</p>
<p>double的最大值和最小值分别为1.79769e+308（10^308），2.22507e-308（10^-308）</p>
]]></content>
  </entry>
  <entry>
    <title>ubuntu18.04扩大交换空间</title>
    <url>/2021/01/09/Linux%E6%89%A9%E5%A4%A7%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>当时建系统的时候交换空间给了1G，太小了，导致编译程序的时候一旦RAM满了就会卡死，我不得不用-j1命令限制编译的线程数，这样很慢。</p>
<p>因而我们可以扩大交换空间，这样，内存满的时候他可以自动把一些静态的缓存放到这里面避免卡死。</p>
<p>我也是小白，试了很多教程，就这一篇是最好的，能够成功。</p>
<p><a href="https://www.howtoing.com/how-to-add-swap-space-on-ubuntu-18-04%EF%BC%8C%E8%BD%AC%E8%BD%BD%E4%BF%9D%E5%AD%98%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.howtoing.com/how-to-add-swap-space-on-ubuntu-18-04，转载保存如下：</a></p>
<p>《如何在Ubuntu 18.04上添加交换空间》</p>
<p>防范应用程序内存不足错误的最简单方法之一是为服务器添加一些交换空间。在本指南中，我们将介绍如何将交换文件添加到Ubuntu 18.04服务器。</p>
<p>分类:<a href="https://www.howtoing.com/category/ubuntu">Ubuntu</a><a href="https://www.howtoing.com/category/linux-basics">Linux基础</a><a href="https://www.howtoing.com/category/operating-system">操作系统</a><a href="https://www.howtoing.com/category/ubuntu-18-04">Ubuntu 18.04</a></p>
<p> <em>2018-07-05 15:24:21</em></p>
<p><em>本教程的先前版本由<a href="https://www.digitalocean.com/community/users/jellingwood">Justin Ellingwood</a>编写</em></p>
<p>防范应用程序内存不足错误的最简单方法之一是为服务器添加一些交换空间。 在本指南中，我们将介绍如何将交换文件添加到Ubuntu 18.04服务器。</p>
<p><strong>警告：</strong>虽然通常建议对使用传统旋转硬盘驱动器的系统进行交换，但使用SSD交换可能会导致硬件随着时间的推移而出现问题。 出于这种考虑，我们不建议在DigitalOcean或任何其他使用SSD存储的提供商上启用交换。 这样做会影响您和您的邻居的底层硬件的可靠性。 本指南是为可能在其他地方使用旋转磁盘系统的用户提供的参考。</p>
<p>如果您需要在DigitalOcean上提高服务器的性能，我们建议您升级Droplet。 这将导致更好的结果，并将降低导致可能影响您的服务的硬件问题的可能性。</p>
<h2 id="什么是交换？"><a href="#什么是交换？" class="headerlink" title="什么是交换？"></a>什么是交换？</h2><p><em>交换</em>是硬盘驱动器上的一个区域，它被指定为操作系统可以临时存储无法再保存在RAM中的数据的位置。 基本上，这使您能够增加服务器在其工作“内存”中可以保留的信息量，但有一些注意事项。 硬盘驱动器上的交换空间将主要用于RAM中不再有足够空间来保存正在使用的应用程序数据。</p>
<p>写入磁盘的信息将比保存在RAM中的信息慢得多，但操作系统更愿意在内存中运行应用程序数据并使用交换旧数据。 总的来说，将交换空间作为系统RAM耗尽时的后备空间，可以很好地防范具有非SSD存储的系统上的内存不足异常。</p>
<h2 id="第1步-检查系统的交换信息"><a href="#第1步-检查系统的交换信息" class="headerlink" title="第1步 - 检查系统的交换信息"></a>第1步 - 检查系统的交换信息</h2><p>在开始之前，我们可以检查系统是否已经有一些可用的交换空间。 可以有多个交换文件或交换分区，但通常一个就足够了。</p>
<p>我们可以通过键入以下内容来查看系统是否已配置任</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br></pre></td></tr></table></figure>

<p>如果您没有收到任何输出，这意味着您的系统当前没有可用的交换空间。</p>
<p>您可以使用<code>free</code>实用程序验证没有活动交换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -h</span><br><span class="line">Output              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           985M         84M        222M        680K        678M        721M</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>

<p>正如您在输出的<strong>Swap</strong>行中所看到的，系统上没有活动交换。</p>
<h2 id="第2步-检查硬盘驱动器分区上的可用空间"><a href="#第2步-检查硬盘驱动器分区上的可用空间" class="headerlink" title="第2步 - 检查硬盘驱动器分区上的可用空间"></a>第2步 - 检查硬盘驱动器分区上的可用空间</h2><p>在我们创建交换文件之前，我们将检查当前的磁盘使用情况，以确保我们有足够的空间。 通过输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">OutputFilesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            481M     0  481M   0% &#x2F;dev</span><br><span class="line">tmpfs            99M  656K   98M   1% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;vda1        25G  1.4G   23G   6% &#x2F;</span><br><span class="line">tmpfs           493M     0  493M   0% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           493M     0  493M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vda15      105M  3.4M  102M   4% &#x2F;boot&#x2F;efi</span><br><span class="line">tmpfs            99M     0   99M   0% &#x2F;run&#x2F;user&#x2F;1000</span><br></pre></td></tr></table></figure>

<p>在这种情况下，带有<code>/</code>在<code>Mounted on</code>列上的设备是我们的磁盘。 在这个例子中我们有足够的空间（仅使用1.4G）。 您的用法可能会有所不同。</p>
<p>虽然对交换空间的适当大小有很多意见，但这实际上取决于您的个人偏好和您的应用程序要求。 通常，等于或加倍系统RAM的量是一个很好的起点。 另一个好的经验法则是，如果您只是将其用作RAM后备，那么任何超过4G的交换都可能是不必要的。</p>
<h2 id="第3步-创建交换文件"><a href="#第3步-创建交换文件" class="headerlink" title="第3步 - 创建交换文件"></a>第3步 - 创建交换文件</h2><p>现在我们知道了可用的硬盘空间，我们可以在文件系统上创建一个交换文件。 我们将在根（/）目录中分配一个我们想要的交换大小的文件，称为<code>swapfile</code> 。</p>
<p>创建交换文件的最佳方法是使用<code>fallocate</code>程序。 此命令立即创建指定大小的文件。</p>
<p>由于我们示例中的服务器具有1G的RAM，因此我们将在本指南中创建1G文件。 调整此项以满足您自己的服务器的需求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fallocate -l 1G &#x2F;swapfile</span><br></pre></td></tr></table></figure>

<p>我们可以通过输入以下内容来验证是否保留了正确的空间量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lh &#x2F;swapfile</span><br><span class="line">-rw-r--r-- 1 root root 1.0G Apr 25 11:14 &#x2F;swapfile</span><br></pre></td></tr></table></figure>

<p>我们的文件创建时留出了正确的空间。</p>
<h2 id="第4步-启用交换文件"><a href="#第4步-启用交换文件" class="headerlink" title="第4步 - 启用交换文件"></a>第4步 - 启用交换文件</h2><p>现在我们有一个正确大小的文件，我们需要实际将其转换为交换空间。</p>
<p>首先，我们需要锁定文件的权限，以便只有具有<strong>root</strong>权限的用户才能读取内容。 这可以防止普通用户访问该文件，这会产生重大的安全隐患。</p>
<p>通过键入以下内容使该文件只能由<strong>root</strong>访问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 600 &#x2F;swapfile</span><br></pre></td></tr></table></figure>

<p>键入以下命令验证权限更改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lh &#x2F;swapfile</span><br><span class="line">Output-rw------- 1 root root 1.0G Apr 25 11:14 &#x2F;swapfile</span><br></pre></td></tr></table></figure>

<p>如您所见，只有<strong>root</strong>用户启用了读写标志。</p>
<p>我们现在可以通过输入以下内容将文件标记为交换空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkswap &#x2F;swapfile</span><br><span class="line">OutputSetting up swapspace version 1, size &#x3D; 1024 MiB (1073737728 bytes)</span><br><span class="line">no label, UUID&#x3D;6e965805-2ab9-450f-aed6-577e74089dbf</span><br></pre></td></tr></table></figure>

<p>标记文件后，我们可以启用交换文件，允许我们的系统开始使用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo swapon &#x2F;swapfile</span><br></pre></td></tr></table></figure>

<p>输入以下内容验证交换是否可用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br><span class="line">OutputNAME      TYPE  SIZE USED PRIO</span><br><span class="line">&#x2F;swapfile file 1024M   0B   -2</span><br></pre></td></tr></table></figure>

<p>我们可以再次检查<code>free</code>工具的输出以证实我们的发现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -h</span><br><span class="line">Output              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           985M         84M        220M        680K        680M        722M</span><br><span class="line">Swap:          1.0G          0B        1.0G</span><br></pre></td></tr></table></figure>

<p>我们的交换已成功设置，我们的操作系统将在必要时开始使用它。</p>
<h2 id="第5步-使交换文件永久化"><a href="#第5步-使交换文件永久化" class="headerlink" title="第5步 - 使交换文件永久化"></a>第5步 - 使交换文件永久化</h2><p>我们最近的更改已启用当前会话的交换文件。 但是，如果我们重新启动，服务器将不会自动保留交换设置。 我们可以通过将交换文件添加到<code>/etc/fstab</code>文件来更改此设置。</p>
<p>备份<code>/etc/fstab</code>文件，以防出现任何问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp &#x2F;etc&#x2F;fstab &#x2F;etc&#x2F;fstab.bak</span><br></pre></td></tr></table></figure>

<p>键入以下命令，将交换文件信息添加到<code>/etc/fstab</code>文件的末尾：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;&#x2F;swapfile none swap sw 0 0&#39; | sudo tee -a &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>

<p>接下来，我们将查看一些我们可以更新的设置以调整我们的交换空间。</p>
<h2 id="第6步-调整您的交换设置"><a href="#第6步-调整您的交换设置" class="headerlink" title="第6步 - 调整您的交换设置"></a>第6步 - 调整您的交换设置</h2><p>您可以配置一些选项，这些选项会在处理交换时对系统的性能产生影响。</p>
<h3 id="调整Swappiness属性"><a href="#调整Swappiness属性" class="headerlink" title="调整Swappiness属性"></a>调整Swappiness属性</h3><p><code>swappiness</code>参数配置系统将数据从RAM交换到交换空间的频率。 这是介于0和100之间的值，表示百分比。</p>
<p>值接近于零时，除非绝对必要，否则内核不会将数据交换到磁盘。 请记住，与交换文件的交互是“昂贵的”，因为它们比与RAM的交互花费更长的时间，并且它们可能导致性能的显着降低。 告诉系统不要太依赖交换通常会使您的系统更快。</p>
<p>接近100的值将尝试将更多数据放入交换中以努力保持更多RAM空间。 根据应用程序的内存配置文件或服务器的使用情况，在某些情况下可能会更好。</p>
<p>我们可以通过输入以下内容来查看当前的swappiness值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness</span><br><span class="line">Output60</span><br></pre></td></tr></table></figure>

<p>对于桌面，swappiness设置为60并不是一个糟糕的值。 对于服务器，您可能希望将其移近0。</p>
<p>我们可以使用<code>sysctl</code>命令将swappiness设置为不同的值。</p>
<p>例如，要将swappiness设置为10，我们可以键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sysctl vm.swappiness&#x3D;10</span><br><span class="line">Outputvm.swappiness &#x3D; 10</span><br></pre></td></tr></table></figure>

<p>此设置将持续到下次重新引导。 我们可以通过在<code>/etc/sysctl.conf</code>文件中添加该行来自动设置此值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<p>在底部，您可以添加：</p>
<p>/etc/sysctl.conf中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.swappiness&#x3D;10</span><br></pre></td></tr></table></figure>

<p>完成后保存并关闭文件。</p>
<h3 id="调整缓存压力设置"><a href="#调整缓存压力设置" class="headerlink" title="调整缓存压力设置"></a>调整缓存压力设置</h3><p>您可能想要修改的另一个相关值是<code>vfs_cache_pressure</code> 。 此设置配置系统将选择多少缓存<em>inode</em>和<em>dentry</em>信息而不是其他数据。</p>
<p>基本上，这是关于文件系统的访问数据。 这通常是非常昂贵的查询和非常频繁的请求，所以这是你的系统缓存的一个很好的事情。 您可以通过再次查询<code>proc</code>文件系统来查看当前值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;vfs_cache_pressure</span><br><span class="line">Output100</span><br></pre></td></tr></table></figure>

<p>由于它当前已配置，我们的系统会过快地从缓存中删除inode信息。 我们可以通过键入以下内容将其设置为更保守的设置（如50）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sysctl vm.vfs_cache_pressure&#x3D;50</span><br><span class="line">Outputvm.vfs_cache_pressure &#x3D; 50</span><br></pre></td></tr></table></figure>

<p>同样，这仅适用于我们当前的会话。 我们可以通过将其添加到配置文件来改变它，就像我们使用swappiness设置一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<p>在底部，添加指定新值的行：</p>
<p>/etc/sysctl.conf中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.vfs_cache_pressure&#x3D;50</span><br></pre></td></tr></table></figure>

<p>完成后保存并关闭文件。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>按照本指南中的步骤将为您提供一些Wheezy空间，否则会导致内存不足异常。 交换空间在避免一些常见问题方面非常有用。</p>
<p>如果遇到OOM（内存不足）错误，或者如果发现系统无法使用所需的应用程序，最佳解决方案是优化应用程序配置或升级服务器。</p>
]]></content>
      <categories>
        <category>工具技能</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS之CMakeList</title>
    <url>/2020/10/05/ROS%E4%B9%8BCMakeList/</url>
    <content><![CDATA[<p>参考学习链接：</p>
<p><a href="https://www.cnblogs.com/Jessica-jie/p/6520481.html"><strong>catkin软件包的组成</strong></a></p>
<p><a href="https://blog.csdn.net/u010122972/article/details/78216013">CMakeList的基本写法</a></p>
<h1 id="CmakeList"><a href="#CmakeList" class="headerlink" title="CmakeList"></a>CmakeList</h1><p> <a href="https://blog.csdn.net/AdamShan/article/details/82901295"><strong>ROS：依赖文件和环境</strong></a></p>
<p> CMakeLists.txt文件是CMake构建系统的输入，在这里我们不会详细讨论CMake的写法（因为它本身可以很复杂），我们大致熟悉一下我们常用的CMake的语法：</p>
<p><code>cmake_minimum_required：</code>需要的CMake的最低版本<br><code>project():</code>包的名称<br><code>find_package()</code> 查找建构是需要的其他 CMake/Catkin 包<br><code>add_message_files() add_service_files() add_action_files</code> 生成Message /Service /Action<br><code>generate_messages()</code> 调用消息生成<br><code>catkin_package()</code> 指定包的构建信息<br><code>add_library()/add_executable()/target_link_libraries()</code> 用于构建的库，可执行代码</p>
<p>同样的，在<code>CMakeList</code>中，我们通过<code>find_package</code>查找这三个包的路径，然后将三个包添加到 <code>CATKIN_DEPENDS</code>, 在使用pcl库前，需要将PCL库的路径链接，通过<code>link_directories( $ &#123;PCL_LIBRARY_DIRS&#125;)</code>来完成，并在最后的<code>target_link_libraries</code>中添加<code>$&#123;PCL_LIBRARIES&#125;</code>。</p>
<p> <code>package.xml</code>的内容很简单，实际上就是这个包的描述文件， <code>build_depend</code> 和 <code>run_depend</code> 两个描述符分别指定了程序包编译和运行的依赖项，通常是所用到的库文件的名称。 在这里我们指定了三个编译和运行时依赖项，分别是<code>roscpp</code>（编写C++ ROS节点），<code>sensor_msgs</code>（定义了激光雷达的msg），<code>pcl_ros</code>（连接ROS和pcl库）。</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1>]]></content>
      <categories>
        <category>编程学习</category>
        <category>Cmake</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS之Rviz入门</title>
    <url>/2020/11/12/ROS%E4%B9%8BRviz/</url>
    <content><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1386902">https://cloud.tencent.com/developer/article/1386902</a></p>
<p>我主要会向rviz发布点线等可视化信息，因此会用到<strong>visualization_msgs::Marker</strong> 下的<strong>POINTS/LINE_STRIP/LINE_LIST</strong></p>
<p>参考<a href="http://wiki.ros.org/rviz/Tutorials/Markers%3A%20Points%20and%20Lines#Using_Points.2C_Line_Strips.2C_and_Line_Lists">http://wiki.ros.org/rviz/Tutorials/Markers%3A%20Points%20and%20Lines#Using_Points.2C_Line_Strips.2C_and_Line_Lists</a></p>
<h2 id="points"><a href="#points" class="headerlink" title="points"></a>points</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::NodeHandle n;</span><br><span class="line">ros::Publisher marker_pub = n.advertise&lt;visulization_msgs::Marker&gt;(<span class="string">&quot;my_points_topic&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(ros::ok())&#123;</span><br><span class="line">    visualization_msg::Marker points;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set header</span></span><br><span class="line">    points.header.frame_id = <span class="string">&quot;my_frame&quot;</span>;</span><br><span class="line">    points.header.stamp = ros::Time::now();</span><br><span class="line">    points.ns = <span class="string">&quot;my_namespace&quot;</span>;</span><br><span class="line">    points.action = visulization_msgs::Marker::ADD;</span><br><span class="line">    points.pose.orientation.w = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set other attributes</span></span><br><span class="line">    points.id = <span class="number">0</span>;</span><br><span class="line">   	points.type = visulization_msgs::Marker::POINTS;	<span class="comment">///////////////////////////////////////</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set the size of point</span></span><br><span class="line">    points.scale.x = <span class="number">0.2</span>;</span><br><span class="line">    points.scale.y = <span class="number">0.2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set corlor</span></span><br><span class="line">    points.color.f = <span class="number">1.0</span>;</span><br><span class="line">    points.color.a = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add vertex coordinate</span></span><br><span class="line">    geometry_msgs::Point p	<span class="comment">/////////////////////////////////////////////////</span></span><br><span class="line">     p.x = <span class="number">0</span>; p.y = <span class="number">0</span>; p.z = <span class="number">0</span>;</span><br><span class="line">    points.push_back(p);</span><br><span class="line">    </span><br><span class="line">    marker_pub.publish(points);</span><br><span class="line">    r.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="line-strip-line-list"><a href="#line-strip-line-list" class="headerlink" title="line_strip line_list"></a>line_strip line_list</h2><p>strip是按点的顺序一次连接保存多段线，[0]连[1], [1]连[2];</p>
<p>list中的线不是相连的,[0]连[1], [2]连[3].</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">visualization_msgs::Marker line_strip,line_list;</span><br><span class="line"><span class="keyword">while</span>(ros::ok())&#123;</span><br><span class="line">    <span class="comment">//set header</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set id etc.</span></span><br><span class="line">    line_strip.type = visualization_msgs::Marker::LINE_STRIP;</span><br><span class="line">    line_list.type =  visualization_msgs::Marker::LINE_LIST;</span><br><span class="line">   </span><br><span class="line">    line_strip.scale.x = <span class="number">0.1</span>;  	line_list.scale.x = <span class="number">0.1</span>;</span><br><span class="line">    </span><br><span class="line">    line_strip.color.b = <span class="number">1.0</span>;    line_strip.color.a = <span class="number">1.0</span>;</span><br><span class="line">    line_list.color.r = <span class="number">1.0</span>;     line_list.color.a = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    line_strip.points.push_back(p);</span><br><span class="line">    <span class="comment">// The line list needs two points for each line</span></span><br><span class="line">      line_list.points.push_back(p);</span><br><span class="line">      p.z += <span class="number">1.0</span>;</span><br><span class="line">      line_list.points.push_back(p);</span><br><span class="line">    </span><br><span class="line">    marker_pub.publish(line_strip);</span><br><span class="line">    marker_pub.publish(line_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具技能</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/04/PPT%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>合抱之木，生于毫末；九层之台，起于累土。</p>
<p>三部分：策划难忘、视觉设计、演讲仪式</p>
<h2 id="演讲"><a href="#演讲" class="headerlink" title="演讲"></a>演讲</h2><p>以观众的思维演讲，文字数据可视化，避免单向交流。整体的逻辑。</p>
<h2 id="PPT-演讲自检清单"><a href="#PPT-演讲自检清单" class="headerlink" title="PPT 演讲自检清单"></a>PPT 演讲自检清单</h2><table>
<thead>
<tr>
<th>演讲的主题：</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td>观众情况</td>
<td align="left"></td>
</tr>
<tr>
<td>观众最想听的三点</td>
<td align="left"></td>
</tr>
<tr>
<td>观众最不能接受的</td>
<td align="left"></td>
</tr>
<tr>
<td>提前试听并确认过这些吗？</td>
<td align="left">动画、时间、衔接、PPT页面完整、顺利打开播放、字体展示</td>
</tr>
<tr>
<td>开场方式</td>
<td align="left">普通、互动、多媒体、自我介绍</td>
</tr>
<tr>
<td>如何打造个人特色</td>
<td align="left">表演、服装、号召</td>
</tr>
<tr>
<td>演讲是否有令人难忘的举动句子？</td>
<td align="left">什么形式？多少？</td>
</tr>
<tr>
<td>收尾的方式？</td>
<td align="left">祝福？首尾呼应？</td>
</tr>
<tr>
<td>我觉得观众会记住哪3点？</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>ROS学习笔记(二)</title>
    <url>/2020/11/12/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h1><p>可以采集一些topic数据并发布数据。相当于subscriber和publisher。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosbag record /topic_name -o my_rosbag_name</span><br></pre></td></tr></table></figure>

<p>record指令后面可以接多个topic名字，<code>-o</code>是输出文件名字.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosbag info my_rosbag_name</span><br></pre></td></tr></table></figure>

<p>可查看记录的rosbag的信息，包括topic，消息类型，包的大小时长等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosbag play my_rosbag_name</span><br></pre></td></tr></table></figure>

<p>重新发布记录的包到各自的主题。注意仿真的时间依据，<code>--clock</code>可限制为系统时间. <code>-l</code>可以循环播放, <code>-s</code>可以设置开始播放的时间起点, <code>-r</code>可以限制播放的速率</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rostopic echo /topic_name</span><br></pre></td></tr></table></figure>

<p>可实时输出topic的内容信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosbag filter input.bag output.bag &quot;t.to_sec() &lt;= 1284703931.86&quot;</span><br></pre></td></tr></table></figure>

<p>上面的命令需要你有inputbag，然后它会把Bag Time&lt;=1284703931.86的部分提取出来，重新放到一个新的ouput.bag里.</p>
<a id="more"></a>

<h1 id="msg"><a href="#msg" class="headerlink" title="msg"></a>msg</h1><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>有一些msg含有header信息，包含了消息的常用的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint32 seq</span><br><span class="line">time stamp</span><br><span class="line">string frame_id</span><br></pre></td></tr></table></figure>

<h2 id="自定义msg"><a href="#自定义msg" class="headerlink" title="自定义msg"></a>自定义msg</h2><img src="/2020/11/12/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/image-20201112160208278.png" alt="image-20201112160208278" style="zoom:67%;">

<p>四个步骤如图所示.</p>
<ol>
<li><p><code>touch Person.msg</code>新建消息文件，catkin_make的时候会根据系统位数语言等自动生成包含person类的头文件，因此<code>#include &quot;pakage_name/person_msg.h&quot;</code></p>
</li>
<li><p>添加编译运行依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改CMakeLists：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add_executable(person_publisher src/person_publisher.cpp)</span><br><span class="line">target_link_libraries(person_publisher $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(person_publisher $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br><span class="line"><span class="meta">#</span><span class="bash">与2中相应</span></span><br><span class="line"></span><br><span class="line">add_executable(person_subscriber src/person_subscriber.cpp)</span><br><span class="line">target_link_libraries(person_subscriber $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="tf-transform"><a href="#tf-transform" class="headerlink" title="tf::transform"></a>tf::transform</h1><p><code>#include &lt;tf/tranform_listener.h&gt;</code></p>
<p><code>#include &lt;tf/transform_broadcaster.h&gt;</code></p>
<h2 id="广播器Broadcaster"><a href="#广播器Broadcaster" class="headerlink" title="广播器Broadcaster"></a>广播器Broadcaster</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> tf::TransformBroadcaster bc;</span><br><span class="line"></span><br><span class="line">tf::Transform transform;</span><br><span class="line"><span class="comment">//set 平移变换</span></span><br><span class="line">transform.setOrigin(tf::Vector(input_msg.x, input_msg.y, <span class="number">0.0</span>)); </span><br><span class="line"><span class="comment">//set 旋转变换</span></span><br><span class="line">tf:: Quaternion q;	<span class="comment">//四元素</span></span><br><span class="line">q.setRPY(<span class="number">0.0</span>，<span class="number">0.0</span>，input_msg.theta);</span><br><span class="line">transform.setRotation(q);</span><br><span class="line"></span><br><span class="line">bc.sendTransform(tf::StampedTransform(transform,ros::Time:now(), <span class="string">&quot;world&quot;</span>, turtle_name) );</span><br></pre></td></tr></table></figure>

<h2 id="订阅器listener"><a href="#订阅器listener" class="headerlink" title="订阅器listener"></a>订阅器listener</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建tf的监听器</span></span><br><span class="line">tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (node.ok())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">    tf::StampedTransform transform;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        listener.waitForTransform(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::Time(<span class="number">0</span>), ros::Duration(<span class="number">3.0</span>));	<span class="comment">//等待消息的到来， duration设置为3s超时</span></span><br><span class="line">        listener.lookupTransform(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::Time(<span class="number">0</span>), transform);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (tf::TransformException &amp;ex) </span><br><span class="line">    &#123;</span><br><span class="line">        ROS_ERROR(<span class="string">&quot;%s&quot;</span>,ex.what());</span><br><span class="line">        ros::Duration(<span class="number">1.0</span>).sleep();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    transform.getOrigin().x();</span><br><span class="line">    transform.getOrigin().y();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="static-transform-publisher节点"><a href="#static-transform-publisher节点" class="headerlink" title="static_transform_publisher节点"></a>static_transform_publisher节点</h2><p><a href="http://wiki.ros.org/tf#static_transform_publisher">http://wiki.ros.org/tf#static_transform_publisher</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Calibration--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_link_to_rslidar_left&quot;</span>  <span class="attr">args</span>=<span class="string">&quot;-1.249000902703301e-16 0.65 -0.2 0 0.017453293 -0.8203047710000001 /rslidar /rslidar_left 1&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_link_to_rslidar_right&quot;</span>  <span class="attr">args</span>=<span class="string">&quot;2.654126918244515e-16 -0.5250000000000004 -0.2 0 0 0.006981317200000003 /rslidar /rslidar_right 1&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是我们在launch文件中将两侧雷达的数据坐标变换到中间雷达中运行的两个节点。<code>tf::static_transform_publisher</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun tf static_transform_publisher </span><br></pre></td></tr></table></figure>

<p>可通过上述指令查看该节点需要的参数的顺序，如下：</p>
<blockquote>
<p>Usage: static_transform_publisher <em>x y z yaw pitch roll frame_id child_frame_id  period</em>(milliseconds)<br>OR<br>Usage: static_transform_publisher <em>x y z qx qy qz qw frame_id child_frame_id  period</em>(milliseconds) </p>
</blockquote>
]]></content>
      <categories>
        <category>工具技能</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM基础学习</title>
    <url>/2020/12/03/SLAM/</url>
    <content><![CDATA[<h1 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h1><p><img src="/2020/12/03/SLAM/541075978d219fa03aa9357894d4d8f4.svg" alt="img"></p>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/16/%E3%80%90Linux%E3%80%91Proxy/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"></span><br><span class="line">env | grep -i proxy</span><br><span class="line">unset ALL_PROXY</span><br><span class="line">unset all_proxy</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>PCL基础知识</title>
    <url>/2020/10/10/PCL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/walkthrough.html#common">官方文档</a></p>
<h2 id="PCL点云数据结构"><a href="#PCL点云数据结构" class="headerlink" title="PCL点云数据结构"></a>PCL点云数据结构</h2><p><a href="https://blog.csdn.net/qq_30815237/article/details/86475877?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">学习链接</a></p>
<h3 id="PointCLoud"><a href="#PointCLoud" class="headerlink" title="PointCLoud:"></a><strong>PointCLoud</strong>:</h3><ul>
<li>width(int),每一束激光扫描的点数</li>
<li>height(int), 激光的线数, 当点云为无序点云时候height=1</li>
<li>points(std::vector), 存储点的类型的向量,如XYZ,XYZI等,</li>
</ul>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud;</span><br><span class="line">cloud.points[i].x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pcl::PointXYZ&gt; data = cloud.points;</span><br><span class="line"><span class="keyword">if</span>(!cloud.isOrganized())&#123;&#125;<span class="comment">//判断是不是有序点云</span></span><br><span class="line">is_dense(<span class="literal">true</span>)<span class="comment">//指定所有点都是稠密的,inf/nan</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//指针类型</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">ptr <span class="title">cloud2</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">cloud2-&gt;point[i].x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>PointXYZ</p>
<p>结构: <code>float x,y,z </code> </p>
<p>用cloud.points[i].x访问</p>
</li>
<li><p>PointXYZI</p>
<p>结构:<code>float x,y,z,Indensity;</code></p>
<p>用cloud.points[i].Data[4]访问强度</p>
</li>
<li><p>PointXYZRGB</p>
<p>结构:<code>float x,y,z,rgb</code> rgb用一个浮点数表示</p>
</li>
</ol>
<h2 id="点云预处理"><a href="#点云预处理" class="headerlink" title="点云预处理"></a>点云预处理</h2>]]></content>
      <categories>
        <category>研究生</category>
        <category>PCL</category>
      </categories>
      <tags>
        <tag>PCL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/16/%E3%80%90ROS%E3%80%91Parameter%20server/</url>
    <content><![CDATA[<h2 id="roslaunch"><a href="#roslaunch" class="headerlink" title="roslaunch"></a>roslaunch</h2><p>param <code>name=</code>+<code>value=</code></p>
<p>rosparam <code>file=</code>+<code>command=</code></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/14/%E3%80%90ROS%E3%80%91Rviz/</url>
    <content><![CDATA[<p>Rviz教程：<a href="http://wiki.ros.org/rviz/Tutorials">http://wiki.ros.org/rviz/Tutorials</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线条</span></span><br><span class="line">visualization_msgs::Marker OV_line,PS_line;</span><br><span class="line"><span class="keyword">while</span>(ros::ok())&#123;</span><br><span class="line">    <span class="comment">//set header</span></span><br><span class="line">    OV_line.header.frame_id = PS_line.header.frame_id =  header_parkingSlot.frame_id;</span><br><span class="line">    OV_line.header.stamp = PS_line.header.stamp = header_parkingSlot.stamp;</span><br><span class="line">    OV_line.ns = PS_line.ns = <span class="string">&quot;rslidar_perception&quot;</span>;</span><br><span class="line">    OV_line.action = PS_line.action = visualization_msgs::Marker::ADD;</span><br><span class="line">    OV_line.pose.orientation.w = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    OV_line.id = <span class="number">0</span>;</span><br><span class="line">    PS_line.id = <span class="number">1</span>;</span><br><span class="line">    OV_line.type = PS_line.type = visualization_msgs::Marker::LINE_STRIP;</span><br><span class="line"></span><br><span class="line">    OV_line.scale.x=<span class="number">0.1</span>;</span><br><span class="line">    PS_line.scale.x = <span class="number">0.1</span>;</span><br><span class="line">    OV_line.color.b = <span class="number">1.0</span>;</span><br><span class="line">    PS_line.color.r = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    OV_line.points.push_back()</span><br><span class="line">        geometry_msgs::Point P_PS,P_OV;</span><br><span class="line">    P_PS.x = PS_pose_filtered[<span class="number">0</span>]+<span class="number">1.5</span>*<span class="built_in">cos</span>(PS_pose_filtered[<span class="number">2</span>]);</span><br><span class="line">    P_PS.y = PS_pose_filtered[<span class="number">1</span>]+<span class="number">1.5</span>*<span class="built_in">sin</span>(PS_pose_filtered[<span class="number">2</span>]);</span><br><span class="line">    P_PS.z = <span class="number">0</span>;</span><br><span class="line">    PS_line.points.push_back(P_PS);</span><br><span class="line">    P_PS.x = PS_pose_filtered[<span class="number">0</span>];</span><br><span class="line">    P_PS.y = PS_pose_filtered[<span class="number">1</span>];</span><br><span class="line">    PS_line.points.push_back(P_PS);</span><br><span class="line">    P_PS.x = PS_pose_filtered[<span class="number">0</span>]+<span class="number">2.5</span>*<span class="built_in">cos</span>(PS_pose_filtered[<span class="number">2</span>]-M_PI_2);</span><br><span class="line">    P_PS.y = PS_pose_filtered[<span class="number">1</span>]+<span class="number">2.5</span>*<span class="built_in">sin</span>(PS_pose_filtered[<span class="number">2</span>]-M_PI_2);</span><br><span class="line">    PS_line.points.push_back(P_PS);</span><br><span class="line"></span><br><span class="line">    P_OV.x = OV_pose_filtered[<span class="number">0</span>]+<span class="number">1.5</span>*<span class="built_in">cos</span>(OV_pose_filtered[<span class="number">2</span>]);</span><br><span class="line">    P_OV.y = OV_pose_filtered[<span class="number">1</span>]+<span class="number">1.5</span>*<span class="built_in">sin</span>(OV_pose_filtered[<span class="number">2</span>]);</span><br><span class="line">    P_OV.z = <span class="number">0</span>;</span><br><span class="line">    OV_line.points.push_back(P_OV);</span><br><span class="line">    P_OV.x = OV_pose_filtered[<span class="number">0</span>];</span><br><span class="line">    P_OV.y = OV_pose_filtered[<span class="number">1</span>];</span><br><span class="line">    OV_line.points.push_back(P_OV);</span><br><span class="line">    P_OV.x = OV_pose_filtered[<span class="number">0</span>]+<span class="number">2.5</span>*<span class="built_in">cos</span>(OV_pose_filtered[<span class="number">2</span>]-M_PI_2);</span><br><span class="line">    P_OV.y = OV_pose_filtered[<span class="number">1</span>]+<span class="number">2.5</span>*<span class="built_in">sin</span>(OV_pose_filtered[<span class="number">2</span>]-M_PI_2);</span><br><span class="line">    OV_line.points.push_back(P_OV);</span><br><span class="line"></span><br><span class="line">    tracked_slot_marker_pub.publish(PS_line);</span><br><span class="line">    marker_pub.publish(OV_line);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 用箭头来代替有向点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>【ROS】transform变换矩阵</title>
    <url>/2020/12/29/%E3%80%90ROS%E3%80%91tf/</url>
    <content><![CDATA[<p>学习视频：<a href="https://www.bilibili.com/video/BV1mJ411R7Ni?p=31">https://www.bilibili.com/video/BV1mJ411R7Ni?p=31</a></p>
<p><em>之前零零碎碎了解了很多，但是都没系统性的学习和实现，在这里详细的总结一下每个知识，加强记忆</em></p>
<h2 id="描述规范："><a href="#描述规范：" class="headerlink" title="描述规范："></a><strong>描述规范：</strong></h2><ol>
<li>source、target frame是在<strong>进行坐标变换</strong>时的概念，source是坐标变换的源坐标系，target是目标坐标系。这个时候，这个变换代表的是<strong>坐标变换</strong>。</li>
<li>parent、child frame是在<strong>描述坐标系变换</strong>时的概念，parent是原坐标系，child是变换后的坐标系，这个时候这个变换<strong>描述的是坐标系变换</strong>，也是child坐标系在parent坐标系下的描述。</li>
<li>a frame到b frame的坐标系变换（frame transform），也表示了b frame在a frame的姿态描述，也代表了把一个点在b frame里坐标变换成在a frame里坐标的<strong>坐标变换</strong>。</li>
<li>从parent到child的坐标系变换（frame transform）等同于把一个点从child坐标系向parent坐标系的<strong>坐标变换</strong>，等于child坐标系在parent frame坐标系的姿态描述。</li>
</ol>
<p>二者其实是等价的, 坐标系变换会反转一下,本子上依然是坐标系原点的坐标变换,但是该坐标系中的坐标依赖于它,因此会反一下,不难理解.</p>
<h2 id="坐标变换举例"><a href="#坐标变换举例" class="headerlink" title="坐标变换举例"></a><strong>坐标变换举例</strong></h2><ul>
<li><p>我记忆，为了防止混淆，都以坐标变换为基础，而不在考虑坐标系变换的角度，也不要用旋转平移的动态视角去记忆。即统一利用描述规范中的1,4点进行记忆，编程时不易出错</p>
</li>
<li><center><img src="file:///home/jlee/文档/github_repositories/Blog/source/_posts/坐标变换/image-20201113151857377.png?lastModify=1612318184" alt="image-20201113151857377" style="zoom: 80%;" div></center>
</li>
<li><p>现在我们要将局部坐标系O‘下的P点坐标（记为P_O’ ）转换到全局坐标系O下，即获得全局坐标系O的P点坐标(记为P_O) 。按照规范1来讲，O‘是source，O是target</p>
</li>
<li><p>首先我们要获取变换矩阵transform，记为T_O_O’，意味着从O‘到O坐标系的坐标变换矩阵。transform矩阵的参数本质也是个pose，是局部坐标系O’ 在全局坐标系O中的pose，即设置translate参数为<strong>O‘的坐标</strong>，rotation参数为<strong>O‘ x正半轴的角度</strong>（即逆时针为正）。——与之前旋转平移原坐标系到新坐标系一致。</p>
</li>
<li><p>$P_O’ =T_{OO’}*P_{O’}$ 类似与向量乘法，大部分库都是默认变换矩阵<strong>左乘</strong>，因此我们从右向左看。$P_{O’}$ 为<strong>列向量</strong>，因此 $T_{OO’}$ 是<strong>从右往左</strong>依次进行运算，表示<strong>从O’到O的坐标变换</strong>.</p>
</li>
<li><p>$P_a =T_{aO}T_{OO’}*P_{O’}$ 上式再左乘一个矩阵，从右往左看，$T_{aO}T_{OO’}=T_{aO’}$ , 下标依次抵消，最后就可以得到P在a坐标系下的坐标。</p>
</li>
</ul>
<h2 id="tf-tree"><a href="#tf-tree" class="headerlink" title="tf tree"></a>tf tree</h2>]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/16/%E3%80%90ROS%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>ROS:: spin()</p>
<p>ROS::spinOnce()</p>
<p>ROS::MultiThreadedSpinner</p>
<p>ROS::AsyncSpinner</p>
<p>ros::CallbackQueue::callAvailable() / ::callOne()</p>
<p>std::thread process{func, argument}</p>
<p>std::queue&lt; &gt; x</p>
<p>std::mutex </p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/16/%E3%80%90Python%E3%80%91matplotlib&amp;pandas/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/dev-liu/p/pandas_plt_basic.html">https://www.cnblogs.com/dev-liu/p/pandas_plt_basic.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>【ROS】同时收取多个topic消息</title>
    <url>/2020/12/29/%E3%80%90ROS%E3%80%91%E5%90%8C%E6%97%B6%E6%94%B6%E5%8F%96%E5%A4%9A%E4%B8%AAtopic%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p>ros官方链接：<a href="http://wiki.ros.org/message_filters">http://wiki.ros.org/message_filters</a></p>
<p>参考链接：<a href="https://www.cnblogs.com/gdut-gordon/p/10293446.html">https://www.cnblogs.com/gdut-gordon/p/10293446.html</a></p>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转</title>
    <url>/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="旋转基础"><a href="#旋转基础" class="headerlink" title="旋转基础"></a>旋转基础</h1><p>转载链接：<a href="https://www.cnblogs.com/21207-iHome/p/6894128.html">https://www.cnblogs.com/21207-iHome/p/6894128.html</a></p>
<h2 id="RPY角与Z-Y-X欧拉角"><a href="#RPY角与Z-Y-X欧拉角" class="headerlink" title="RPY角与Z-Y-X欧拉角"></a><strong>RPY角与Z-Y-X欧拉角</strong></h2><p>　　描述坐标系{B}相对于参考坐标系{A}的姿态有两种方式。第一种是<strong>绕固定（参考）坐标轴旋转</strong>：假设开始两个坐标系重合，先将{B}绕{A}的X轴旋转$\lambda$，然后绕{A}的Y轴旋转 $\beta$ ，最后绕{A}的Z轴旋转$\alpha$，就能旋转到当前姿态。可以称其为X-Y-Z fixed angles或RPY角(Roll, Pitch, Yaw)。</p>
<a id="more"></a>

<p>Roll:横滚</p>
<img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/890966-20170525140304841-1105765244.gif" alt="img" style="zoom:50%;">

<p>　　Pitch: 俯仰</p>
<img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/890966-20170525140116919-1889606213.gif" alt="img" style="zoom:50%;">

<p>Yaw: 偏航（航向）</p>
<img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/890966-20170525140337654-1615043244.gif" alt="img" style="zoom:50%;">

<p>由于是绕固定坐标系旋转，则旋转矩阵为（$c\alpha$ is shorthand for $\cos\alpha$, $s\alpha$ is shorthand for $\sin\alpha$,and so on.）<br>$$<br>R_{XYZ}(\gamma,\beta,\alpha)=R_Z(\alpha)R_Y(\beta)R_X(\gamma)=\begin{bmatrix}<br>c\alpha c\beta &amp; c\alpha s\beta s\gamma-s\alpha c\gamma &amp; c\alpha s\beta c\gamma+s\alpha s\gamma\<br>s\alpha c\beta &amp; s\alpha s\beta s\gamma+c\alpha c\gamma &amp; s\alpha s\beta c\gamma-c\alpha s\gamma\<br>-s\beta&amp; c\beta s\gamma &amp; c\beta c\gamma<br>\end{bmatrix}<br>$$<br>　　另一种姿态描述方式是<strong>绕自身坐标轴旋转</strong>：假设开始两个坐标系重合，先将{B}绕自身的Z轴旋转$\alpha$，然后绕Y轴旋转$\beta$，最后绕X轴旋转$\gamma$，就能旋转到当前姿态。称其为Z-Y-X欧拉角，由于是绕自身坐标轴进行旋转，则旋转矩阵为：<br>$$<br>R_{Z’Y’X’}(\alpha,\beta,\gamma)=R_Z(\alpha)R_Y(\beta)R_X(\gamma)=\begin{bmatrix}<br>c\alpha c\beta &amp; c\alpha s\beta s\gamma-s\alpha c\gamma &amp; c\alpha s\beta c\gamma+s\alpha s\gamma\<br>s\alpha c\beta &amp; s\alpha s\beta s\gamma+c\alpha c\gamma &amp; s\alpha s\beta c\gamma-c\alpha s\gamma\<br>-s\beta&amp; c\beta s\gamma &amp; c\beta c\gamma<br>\end{bmatrix}<br>$$<br>　　可以发现这两种描述方式得到的旋转矩阵是一样的，即绕固定坐标轴X-Y-Z旋转$(\gamma,\beta,\alpha)$和绕自身坐标轴Z-Y-X旋转$(\alpha,\beta,\gamma)$的最终结果一样，只是描述的方法有差别而已。In gerenal: three rotations taken about fixed axes yield the same final orientation as the same three rotations taken in opposite order about the axes of the moving frame.</p>
<h2 id="Axis-Angle与四元数"><a href="#Axis-Angle与四元数" class="headerlink" title="Axis-Angle与四元数"></a><strong>Axis-Angle与四元数</strong></h2><p>　　绕坐标轴的多次旋转可以等效为绕某一转轴旋转一定的角度。假设等效旋转轴方向向量为$\vec{K}=[k_x,k_y,k_z]^T$，等效旋转角为$\theta$，则四元数$q=(x,y,z,w)$，其中：</p>
<p>$$\begin{align*}<br>x &amp;= k_x \cdot sin \frac{\theta}{2}\<br>y &amp;= k_y \cdot sin \frac{\theta}{2}\<br>z &amp;= k_z \cdot sin \frac{\theta}{2}\<br>w &amp;= cos \frac{\theta}{2}<br>\end{align*}$$</p>
<p>　　且有$x^2+y^2+z^2+w^2=1$</p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/quaternion.png" alt="img"></p>
<p>　　即四元数存储了旋转轴和旋转角的信息，它能方便的描述刚体绕任意轴的旋转。</p>
<p>　　四元数转换为旋转矩阵：</p>
<p>$$R=\begin{bmatrix}<br>1-2y^2-2z^2 &amp; 2(xy-zw) &amp; 2(xz+yw)\<br>2(xy+zw) &amp; 1-2x^2-2z^2 &amp; 2(yz-xw)\<br>2(xz-yw)&amp; 2(yz+xw) &amp; 1-2x^2-2y^2<br>\end{bmatrix}$$</p>
<p> 　已知旋转矩阵为：</p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/890966-20170525130817779-2094968004.png" alt="img"></p>
<p>　　则对应的四元数为：</p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/890966-20170525130848716-419557543.png" alt="img"></p>
<hr>
<h2 id="四元数与欧拉角的相互转换"><a href="#四元数与欧拉角的相互转换" class="headerlink" title="四元数与欧拉角的相互转换"></a><strong>四元数与欧拉角的相互转换</strong></h2><p>　　定义两个四元数：</p>
<p>　　<img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/14ce36d3d539b60003b31a9feb50352ac65cb79c.jpg" alt="img"></p>
<p>　　<img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/8cb1cb1349540923a2da76569058d109b3de4962.jpg" alt="img"></p>
<p>　　其中<img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/7dd98d1001e939017bae981679ec54e736d1966d.jpg" alt="img"> 表示矢量 </p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/63d0f703918fa0ec052e7125249759ee3d6ddb28.jpg" alt="img"> </p>
<p> ；而 </p>
<p> <img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/a8014c086e061d95f4ec221079f40ad162d9ca74.jpg" alt="img"></p>
<p> 表示矢量 </p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/9c16fdfaaf51f3dedb19ac4c96eef01f3a29796a.jpg" alt="img"> </p>
<p><strong>四元数加法：</strong></p>
<p>　　跟复数、向量和矩阵一样，两个四元数之和需要将不同的元素加起来。</p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/d01373f082025aaf6ace6be3f9edab64034f1a1d.jpg" alt="img"></p>
<p>　　加法遵循实数和复数的所有交换律和结合律。</p>
<p><strong>四元数乘法：</strong></p>
<p>　　四元数的乘法的意义类似于矩阵的乘法，可以表示旋转的合成。当有多次旋转操作时，使用四元数可以获得更高的计算效率。</p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/7e3e6709c93d70cf36be3013fbdcd100baa12b63.jpg" alt="img"></p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/54fbb2fb43166d2233909989452309f79152d2cc.jpg" alt="img"></p>
<p>　　由于四元数乘法的非可换性，pq并不等于qp，qp乘积的向量部分是：</p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/72f082025aafa40f75cb4bc3a864034f78f0199a.jpg" alt="img"></p>
<p>　　</p>
<p>　　Mathematica中有四元数相关的程序包<a href="https://reference.wolfram.com/language/Quaternions/tutorial/Quaternions.html"><strong>Quaternions Package</strong></a>，需要先导入才能使用。下面计算了三个四元数的乘积：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt;Quaternions&#96;     （* This loads the package *）</span><br><span class="line">Quaternion[2, 1, 1, 3] ** Quaternion[2, 1, 1, 0] ** Quaternion[1, 1, 1, 1]    (* Be sure to use ** rather than * when multiplying quaternions *)</span><br></pre></td></tr></table></figure>

<p>　　计算结果为：Quaternion[-12, 4, 14, 2]</p>
<p>　　那么将Z-Y-X欧拉角（或RPY角：绕固定坐标系的X-Y-Z依次旋转$\alpha$,$\beta$,$\gamma$角）转换为四元数：</p>
<p>$$q=\begin{bmatrix}\cos\frac{\gamma}{2}\ 0\ 0\ \sin\frac{\gamma}{2}\end{bmatrix} \begin{bmatrix}\cos\frac{\beta}{2}\ 0\ \sin\frac{\beta}{2}\ 0\end{bmatrix} \begin{bmatrix}\cos\frac{\alpha}{2}\ \sin \frac{\alpha}{2}\ 0\ 0\end{bmatrix}=\begin{bmatrix}<br>\cos\frac{\alpha}{2}\cos\frac{\beta}{2}\cos\frac{\gamma}{2}+\sin\frac{\alpha}{2}\sin\frac{\beta}{2}\sin\frac{\gamma}{2}\<br>\sin\frac{\alpha}{2}\cos\frac{\beta}{2}\cos\frac{\gamma}{2}-\cos\frac{\alpha}{2}\sin\frac{\beta}{2}\sin\frac{\gamma}{2}\ \cos\frac{\alpha}{2}\sin\frac{\beta}{2}\cos\frac{\gamma}{2}+\sin\frac{\alpha}{2}\cos\frac{\beta}{2}\sin\frac{\gamma}{2}<br>\ \cos\frac{\alpha}{2}\cos\frac{\beta}{2}\sin\frac{\gamma}{2}-\sin\frac{\alpha}{2}\sin\frac{\beta}{2}\cos\frac{\gamma}{2}<br>\end{bmatrix}$$</p>
<p> 　根据上面的公式可以求出逆解，即由四元数$q=(q_0,q_1,q_2,q_3)$或$q=(w,x,y,z)$到欧拉角的转换为：</p>
<p>$$\begin{bmatrix}\alpha\ \beta\ \gamma\end{bmatrix} = \begin{bmatrix}<br>\arctan\frac{2(q_0q_1+q_2q_3)}{1-2(q_1^2+q_2^2)}\<br>\arcsin(2(q_0q_2-q_1q_3))\<br>\arctan\frac{2(q_0q_3+q_1q_2)}{1-2(q_2^2+q_3^2)}<br>\end{bmatrix}$$</p>
<p>　　由于arctan和arcsin的取值范围在$\frac{-\pi}{2}$和$\frac{\pi}{2}$之间，只有180°，而绕某个轴旋转时范围是360°，因此要使用**<a href="http://baike.baidu.com/link?url=-tnNm1Iop3YKgo3EKf4OpaAPSC6KsyMS3trChz3oL3fsTTqFsXt8Y6oX_anPYoMa8EO9tJ7eSRnK1LiuFF4Jma">atan2</a>**函数代替arctan函数：</p>
<p>$$\begin{bmatrix}\alpha\ \beta\ \gamma\end{bmatrix} = \begin{bmatrix}<br>atan2(2(q_0q_1+q_2q_3),1-2(q_1^2+q_2^2))\<br>\arcsin(2(q_0q_2-q_1q_3))\<br>atan2(2(q_0 q_3+q_1 q_2),1-2(q_2^2+q_3^2))<br>\end{bmatrix}$$</p>
<p>对于tan(θ) = y / x ：</p>
<p>　　θ = ATan(y / x)求出的θ取值范围是[-PI/2, PI/2]；</p>
<p>　　θ = ATan2(y, x)求出的θ取值范围是[-PI,  PI]。</p>
<ul>
<li><p>当 (x, y) 在第一象限, 0 &lt; θ &lt; PI/2</p>
</li>
<li><p>当 (x, y) 在第二象限 PI/2 &lt; θ≤PI</p>
</li>
<li><p>当 (x, y) 在第三象限, -PI &lt; θ &lt; -PI/2</p>
</li>
<li><p>当 (x, y) 在第四象限, -PI/2 &lt; θ &lt; 0</p>
<p>　将<a href="http://bediyap.com/programming/convert-quaternion-to-euler-rotations/">四元数转换为欧拉角</a>可以参考下面的代码。需要注意<strong>欧拉角有12种旋转次序</strong>，而上面推导的公式是按照Z-Y-X顺序进行的，所以有时会在网上看到不同的转换公式（因为对应着不同的旋转次序），在使用时一定要注意旋转次序是什么。比如ADAMS软件里就默认Body 3-1-3次序，即Z-X-Z欧拉角，而VREP中则按照X-Y-Z欧拉角旋转。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum RotSeq&#123;zyx, zyz, zxy, zxz, yxz, yxy, yzx, yzy, xyz, xyx, xzy,xzx&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/ContractedBlock.gif" alt="img"> View Code</p>
<p>　　 上面的代码存在一个问题，即奇异性没有考虑。下面看一种特殊的情况（参考<a href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/index.htm">Maths - Conversion Quaternion to Euler</a>）：假设一架飞机绕Y轴旋转了90°（俯仰角pitch=90），机头垂直向上，此时如何计算航向角和横滚角？</p>
<img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/890966-20170526171944435-256526740.png" alt="img" style="zoom:50%;">

<p>　　这时会发生自由度丢失的情况，即Yaw和Roll会变为一个自由度。此时再使用上面的公式根据四元数计算欧拉角会出现问题：</p>
<p>　　$\arcsin(2(q_0q_2-q_1q_3))$的定义域为$[-1,1]$，因此$(q_0q_2-q_1q_3)\in[-0.5, 0.5]$，当$q_0q_2-q_1q_3=0.5$时（在程序中浮点数不能直接进行等于判断，要使用合理的阈值），俯仰角$\beta$为90°，将其带入正向公式计算出四元数$(q_0,q_1,q_2,q_3)$，然后可以发现逆向公式中atan2函数中的参数全部为0，即出现了$\frac{0}{0}$的情况！无法计算。</p>
<p>　　$\beta=\pi/2$时，$\sin\frac{\beta}{2}=\cos\frac{\beta}{2}=0.707$，将其带入公式中有</p>
<p>$$q=\begin{bmatrix}w\ x\ y\ z\end{bmatrix}<br>\begin{bmatrix}<br>0.707(\cos\frac{\alpha}{2}\cos\frac{\gamma}{2}+\sin\frac{\alpha}{2}\sin\frac{\gamma}{2})\<br>0.707(\sin\frac{\alpha}{2}\cos\frac{\gamma}{2}-\cos\frac{\alpha}{2}\sin\frac{\gamma}{2})\<br>0.707(\cos\frac{\alpha}{2}\cos\frac{\gamma}{2}+\sin\frac{\alpha}{2}\sin\frac{\gamma}{2})\<br>0.707(\cos\frac{\alpha}{2}\sin\frac{\gamma}{2}-\sin\frac{\alpha}{2}\cos\frac{\gamma}{2})<br>\end{bmatrix}=<br>\begin{bmatrix}<br>0.707\cos\frac{\alpha-\gamma}{2}\<br>0.707\sin\frac{\alpha-\gamma}{2}\<br>0.707\cos\frac{\alpha-\gamma}{2}\<br>0.707\sin\frac{\alpha-\gamma}{2}<br>\end{bmatrix}$$</p>
<p>　　则$\frac{x}{w}=\frac{z}{y}=\tan\frac{\alpha-\gamma}{2}$，于是有</p>
<p>$$\alpha-\gamma = 2\cdot atan2(x,w)$$</p>
<p> 　通常令$\alpha=0$，这时$\gamma = -2\cdot atan2(x,w)$。可以进行验证：当四元数为(w,x,y,z)=(0.653,-0.271,0.653,0.271)时，根据这些规则计算出来的ZYX欧拉角为α=0°，β=90°，γ=45°</p>
<p><a href="http://quaternions.online/"><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/890966-20170526175726669-1601154856.png" alt="img"></a></p>
<p>　　当俯仰角为-90°，即机头竖直向下时的情况也与之类似，可以推导出奇异姿态时的计算公式。比较完整的四元数转欧拉角（Z-Y-X order）的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CameraSpacePoint QuaternionToEuler(Vector4 q) &#x2F;&#x2F; Z-Y-X Euler angles</span><br><span class="line">&#123;</span><br><span class="line">    CameraSpacePoint euler &#x3D; &#123; 0 &#125;;</span><br><span class="line">    const double Epsilon &#x3D; 0.0009765625f;</span><br><span class="line">    const double Threshold &#x3D; 0.5f - Epsilon;</span><br><span class="line"></span><br><span class="line">    double TEST &#x3D; q.w*q.y - q.x*q.z;</span><br><span class="line"></span><br><span class="line">    if (TEST &lt; -Threshold || TEST &gt; Threshold) &#x2F;&#x2F; 奇异姿态,俯仰角为±90°</span><br><span class="line">    &#123;</span><br><span class="line">        int sign &#x3D; Sign(TEST);</span><br><span class="line"></span><br><span class="line">        euler.Z &#x3D; -2 * sign * (double)atan2(q.x, q.w); &#x2F;&#x2F; yaw</span><br><span class="line"></span><br><span class="line">        euler.Y &#x3D; sign * (PI &#x2F; 2.0); &#x2F;&#x2F; pitch</span><br><span class="line"></span><br><span class="line">        euler.X &#x3D; 0; &#x2F;&#x2F; roll</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        euler.X &#x3D; atan2(2 * (q.y*q.z + q.w*q.x), q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z);</span><br><span class="line">        euler.Y &#x3D; asin(-2 * (q.x*q.z - q.w*q.y));</span><br><span class="line">        euler.Z &#x3D; atan2(2 * (q.x*q.y + q.w*q.z), q.w*q.w + q.x*q.x - q.y*q.y - q.z*q.z);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return euler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>　　在DirectXMath Library中有许多与刚体姿态变换相关的函数可以直接调用：</p>
<ul>
<li><p>四元数乘法：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.quaternion.xmquaternionmultiply(v=vs.85).aspx">XMQuaternionMultiply</a> method –Computes the product of two quaternions.</p>
</li>
<li><p>旋转矩阵转四元数：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.quaternion.xmquaternionrotationmatrix(v=vs.85).aspx">XMQuaternionRotationMatrix</a> method –Computes a rotation quaternion from a rotation matrix.</p>
</li>
<li><p>四元数转旋转矩阵：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.matrix.xmmatrixrotationquaternion(v=vs.85).aspx">XMMatrixRotationQuaternion</a> method – Builds a rotation matrix from a quaternion.</p>
</li>
<li><p>欧拉角转四元数：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.quaternion.xmquaternionrotationrollpitchyaw(v=vs.85).aspx">XMQuaternionRotationRollPitchYaw</a> method –Computes a rotation quaternion based on the pitch, yaw, and roll (Euler angles).</p>
</li>
<li><p>四元数转Axis-Angle：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.quaternion.xmquaterniontoaxisangle(v=vs.85).aspx">XMQuaternionToAxisAngle</a> method –Computes an axis and angle of rotation about that axis for a given quaternion.</p>
</li>
<li><p>欧拉角转旋转矩阵：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.matrix.xmmatrixrotationrollpitchyaw(v=vs.85).aspx">XMMatrixRotationRollPitchYaw method</a> –Builds a rotation matrix based on a given pitch, yaw, and roll (Euler angles).</p>
</li>
<li><p>Axis-Angle转旋转矩阵：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.matrix.xmmatrixrotationaxis(v=vs.85).aspx">XMMatrixRotationAxis</a> method –Builds a matrix that rotates around an arbitrary axis.</p>
</li>
<li><p>构造绕X/Y/Z轴的旋转矩阵：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.matrix.xmmatrixrotationx(v=vs.85).aspx?f=255&MSPPError=-2147217396">XMMatrixRotationX</a> method –Builds a matrix that rotates around the x-axis.(Angles are measured clockwise when looking along the rotation axis toward the origin)</p>
<p>　下面的代码中坐标系绕X轴旋转90°（注意这里不是按照右手定则的方向，而是沿着坐标轴向原点看过去以顺时针方式旋转，因此与传统的右手定则刚好方向相反），来进行变换：</p>
</li>
</ul>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/ContractedBlock.gif" alt="img"> View Code</p>
<p>　　结果如下图所示:</p>
<p><img src="/2021/02/23/%E3%80%90todo%E3%80%91%E6%97%8B%E8%BD%AC/890966-20170526093436138-366855659.png" alt="img"></p>
<p>参考：</p>
<p><a href="http://quaternions.online/">quaternions.online</a></p>
<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee415597(v=vs.85).aspx">DirectXMath Library Quaternion Functions</a></p>
<p><a href="http://bediyap.com/programming/convert-quaternion-to-euler-rotations/">Convert quaternion to euler rotations</a></p>
<p><a href="https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles">Conversion between quaternions and Euler angles</a></p>
<p><a href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/index.htm">Maths - Conversion Quaternion to Euler</a></p>
<p><strong><a href="http://cn.mathworks.com/help/robotics/gs/coordinate-systems-in-robotics.html">Coordinate Transformations in Robotics—MATLAB</a></strong></p>
<p><strong><em>Introduction to Robotics - Mechanics and Control.</em></strong> Chapter 2 Spatial descriptions and transformations</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/16/%E3%80%90%E5%AE%9E%E9%AA%8C%E7%9B%B8%E5%85%B3%E3%80%91/</url>
    <content><![CDATA[<h1 id="Kvaser"><a href="#Kvaser" class="headerlink" title="Kvaser"></a>Kvaser</h1><p><a href="https://github.com/astuff/kvaser_interface">https://github.com/astuff/kvaser_interface</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;?xml</span> <span class="string">version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;launch&gt;</span></span><br><span class="line">  <span class="string">&lt;arg</span> <span class="string">name=&quot;can_hardware_id&quot;</span> <span class="string">default=&quot;011683&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">  <span class="string">&lt;!--</span> <span class="string">&lt;arg</span> <span class="string">name=&quot;can_circuit_id&quot;</span> <span class="string">default=&quot;2&quot;</span> <span class="string">/&gt;</span> <span class="string">--&gt;</span></span><br><span class="line">  <span class="string">&lt;arg</span> <span class="string">name=&quot;can_bit_rate&quot;</span> <span class="string">default=&quot;500000&quot;</span> <span class="string">/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&lt;node</span> <span class="string">pkg=&quot;kvaser_interface&quot;</span> <span class="string">type=&quot;kvaser_can_bridge&quot;</span> <span class="string">ns=&quot;kvaser_channel_1&quot;</span> <span class="string">name=&quot;kvaser_can_bridge&quot;</span> <span class="string">output=&quot;screen&quot;&gt;</span></span><br><span class="line">    <span class="string">&lt;param</span> <span class="string">name=&quot;can_hardware_id&quot;</span> <span class="string">value=&quot;$(arg</span> <span class="string">can_hardware_id)&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">    <span class="string">&lt;param</span> <span class="string">name=&quot;can_circuit_id&quot;</span> <span class="string">value=&quot;1&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">    <span class="string">&lt;param</span> <span class="string">name=&quot;can_bit_rate&quot;</span> <span class="string">value=&quot;$(arg</span> <span class="string">can_bit_rate)&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">  <span class="string">&lt;/node&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&lt;node</span> <span class="string">pkg=&quot;kvaser_interface&quot;</span> <span class="string">type=&quot;kvaser_can_bridge&quot;</span> <span class="string">ns=&quot;kvaser_channel_2&quot;</span> <span class="string">name=&quot;kvaser_can_bridge&quot;</span> <span class="string">output=&quot;screen&quot;&gt;</span></span><br><span class="line">    <span class="string">&lt;param</span> <span class="string">name=&quot;can_hardware_id&quot;</span> <span class="string">value=&quot;$(arg</span> <span class="string">can_hardware_id)&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">    <span class="string">&lt;param</span> <span class="string">name=&quot;can_circuit_id&quot;</span> <span class="string">value=&quot;2&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">    <span class="string">&lt;param</span> <span class="string">name=&quot;can_bit_rate&quot;</span> <span class="string">value=&quot;$(arg</span> <span class="string">can_bit_rate)&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">  <span class="string">&lt;/node&gt;</span></span><br><span class="line"><span class="string">&lt;/launch&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h1><ol>
<li>kvaser 正确链接，接口：<ul>
<li>CHANEL 2 接 诊断口2  RT3000数据</li>
<li>CHANEL 3 接 诊断口4  V3上电和VCU读码盘转向盘数据</li>
</ul>
</li>
<li>上电，matlab/ros驱动<ul>
<li><em>matlab</em>仿真时间要调成真实时间，上电的时候断开紧急开关（按下）</li>
<li>ros驱动指令如下</li>
<li><em>todo问题</em>：roskvaser_powerUp没用</li>
</ul>
</li>
<li>连接以太网线和路由器<ul>
<li>交换机供电5v，——分线器可能电压不够，利用充电宝或者工控机</li>
</ul>
</li>
<li>连接RT3000和千寻服务<ul>
<li>当精度热机到要求的时候开始记录</li>
</ul>
</li>
<li>启动算法</li>
<li>录包<ul>
<li>点云没有记录下来</li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">kvaser驱动</span></span><br><span class="line">roslaunch kvaser_interface kvaser_can_bridge.launch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">控制v3上电程序</span></span><br><span class="line">rosrun lidar_percetion powerUp -i -m -d -g</span><br><span class="line"></span><br><span class="line">rosrun lidar_percetion kvaser_powerUp -i -m -d -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">雷达驱动</span></span><br><span class="line">roslaunch rslidar_sdk start.launch/start_three.launch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 感知算法</span></span><br><span class="line">roslaunch lidar_perception SLAM_and_Detection.launch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">record</span></span><br><span class="line">rosbag record  /chasis_speed /rt3000_pose /steering_angle_deg /rslidar_points /left/rslidar_points /right/rslidar_points /wheeling_count_fl_fr_rl_rr</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/16/%E3%80%90%E5%AE%9E%E9%AA%8C%E7%9B%B8%E5%85%B3%E3%80%91/image-20210124150913640.png" alt="image-20210124150913640"></p>
<p>运行一会会自动关闭</p>
<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ol>
<li>matplotlib 画图figure空白</li>
</ol>
<p>echo 3 &gt; /proc/sys/vm/drop_caches </p>
<p>echo $ DISPLAY=0.0</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/14/%E6%AF%95%E4%B8%9A%E5%89%8D%E8%BF%98%E6%83%B3%E5%AD%A6%E7%9A%84/</url>
    <content><![CDATA[<h2 id="待学清单"><a href="#待学清单" class="headerlink" title="待学清单"></a>待学清单</h2><ul>
<li>实验代码优化<ul>
<li>C++继承还没怎么用过</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/30/%E9%80%83%E7%A6%BB%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1/</url>
    <content><![CDATA[<p>先不考虑家乡在哪,我会如何选择?</p>
<h2 id="行业"><a href="#行业" class="headerlink" title="行业"></a>行业</h2><p>朝阳行业具有发财的可能性: 互联网公司</p>
<p>夕阳行业: 汽车行业, <strong>ADAS</strong>, 智能座舱也算是偏朝阳行业</p>
<h2 id="城市"><a href="#城市" class="headerlink" title="城市"></a>城市</h2><p>重庆,</p>
<p>上海: 跳槽的机会多</p>
<h2 id="公司地位-岗位门槛"><a href="#公司地位-岗位门槛" class="headerlink" title="公司地位+岗位门槛"></a>公司地位+岗位门槛</h2><ol>
<li><p>公司越大越好(大公司的定义要结合细分的行业,比如腾讯比美团规模大,但是在吃喝娱乐这个邻域美团才算更大的公司): </p>
<p>都是大公司.</p>
</li>
</ol>
<p>公司背书+项目履历+职位类型：门槛越高越好，技术&gt;产品&gt;运营&gt;行政销售</p>
<h2 id="领导sb"><a href="#领导sb" class="headerlink" title="领导sb"></a>领导sb</h2><h2 id="薪酬"><a href="#薪酬" class="headerlink" title="薪酬"></a>薪酬</h2>]]></content>
  </entry>
  <entry>
    <title>待整理文章</title>
    <url>/2020/12/18/%E5%BE%85%E6%95%B4%E7%90%86%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<ol>
<li>电子<strong>发烧</strong>产品</li>
<li>个人管理方法，时间健康兴趣管理</li>
<li>理财专区</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>磁盘读写结束后弹出提示</title>
    <url>/2020/07/10/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/%E5%BD%93%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E7%BB%93%E6%9D%9F%E5%90%8E%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="1-配置性能监控器监控项"><a href="#1-配置性能监控器监控项" class="headerlink" title="1. 配置性能监控器监控项"></a>1. 配置性能监控器监控项</h2><p><a href="https://www.skyarch.cn/blog/windows/monitor-perfmon-tool/">https://www.skyarch.cn/blog/windows/monitor-perfmon-tool/</a></p>
<p>常用监控对象和计数器:</p>
<p><a href="https://blog.csdn.net/snlei/article/details/54091275">https://blog.csdn.net/snlei/article/details/54091275</a></p>
<p><a href="https://www.jianshu.com/p/f4406c29542a">https://www.jianshu.com/p/f4406c29542a</a></p>
<p>我们使用**物理磁盘对象(PhysicalDisk Object)**下的Avg.Disk Write Queue Length(平均磁盘写队列长度)。</p>
<p>物理磁盘对象提供了有关物理磁盘I / O性能的信息。它的磁盘计数器与系统中的物理驱动器有关，并且只有当运行了diskper服务时，它才被激活。注意与<strong>逻辑磁盘对象</strong>进行区别。这个对象下的计数器如下所示：</p>
<p><strong>1.</strong> 磁盘读时间百分比(％Disk Read Time) 选中的物理磁盘忙于服务读请求总共用的时间的百分比。</p>
<p><strong>2.</strong> 磁盘写时间百分比(％Disk Write Time) 选中的物理磁盘忙于服务写请求总共用的时间的百分比。</p>
<p><strong>3.</strong> 磁盘时间百分比(％Disk Time) 选中的物理磁盘忙于服务读请求或写请求总共用的时间的百分比，是磁盘写时间百分比与磁盘读时间百分比的和。</p>
<p><strong>4.</strong> 空闲时间百分比(％Idle Time) 物理磁盘在采样时间间隔中处于空闲状态的时间百分比。</p>
<p><strong>5.</strong> 平均磁盘队列长度( Avg. Disk Queue Length) 在采样的时间间隔中，选中的物理磁盘读请求和写请求排队的平均数量。</p>
<p><strong>6.</strong> 平均磁盘读队列长度( Avg. Disk Read Queue Length) 在采样的时间间隔中，选中的物理磁盘读请求排队的平均数量。</p>
<p><strong>7.</strong> 平均磁盘写队列长度( Avg. Disk Write Queue Length) 在采样的时间间隔中，选中的物理磁盘写请求排队的平均数量。</p>
<p><strong>8.</strong> 平均磁盘秒数/读( Avg. Disk sec/Read) 从物理磁盘读数据的平均时间，以秒为单位。</p>
<p><strong>9.</strong> 平均磁盘秒数/写( Avg. Disk sec/Write) 向物理磁盘写数据的平均时间，以秒为单位。</p>
<p><strong>10.</strong> 平均磁盘秒数/传输( Avg. Disk sec/Transfer) 从物理磁盘进行传输的平均时间，以秒为单位。</p>
<p><strong>11.</strong> 磁盘读/秒(Disk Reads Bytes/sec) 物理磁盘上每秒读字节。</p>
<p><strong>12.</strong> 磁盘写/秒(Disk Writes Bytes/sec) 物理磁盘上每秒写字节。</p>
<p><strong>13.</strong> 磁盘读/秒(Disk Reads/sec) 物理磁盘上的读操作比率。</p>
<p><strong>14.</strong> 磁盘写/秒(Disk Writes/sec) 物理磁盘上的写操作比率。</p>
<p><strong>15.</strong> 磁盘传输/秒(Disk Transfers/sec) 物理磁盘上的读和写操作的比率。</p>
<h2 id="2-创建警报计划任务，关联监控数据收集器集"><a href="#2-创建警报计划任务，关联监控数据收集器集" class="headerlink" title="2. 创建警报计划任务，关联监控数据收集器集"></a>2. 创建警报计划任务，关联监控数据收集器集</h2><p><a href="https://www.cnblogs.com/yourstars/p/6505991.html">利用Win10计划任务 + 弹窗提醒</a></p>
<p><strong>弹窗提示</strong>：*.bat代码：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">start</span> mshta vbscript:msgbox(&quot;Go to work, stupid dog!!&quot;,<span class="number">0</span>,&quot;Sound from eval&quot;)(window.close)</span><br></pre></td></tr></table></figure>

<p>注意不要有中文和中文路径。</p>
<p><strong>发送邮件提示</strong>：SmtpMailSender通过命令行发送邮件，别用QQ邮箱，安全验证麻烦。</p>
<p>创建一个文本文件，命名为 perfalert.cmd，同样保存在 d:smtp 目录中，其内容格式为：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">smtpmailsender.exe -f &quot;发件人地址&quot; -t &quot;收件人地址&quot; -s &quot;邮件标题&quot; -b &quot;邮件正文&quot; -send</span><br></pre></td></tr></table></figure>

<p>其余步骤：<a href="https://www.skyarch.cn/blog/windows/monitor-perfmon-tool/">https://www.skyarch.cn/blog/windows/monitor-perfmon-tool/</a></p>
]]></content>
      <categories>
        <category>工具技能</category>
      </categories>
      <tags>
        <tag>win10磁盘监控</tag>
      </tags>
  </entry>
  <entry>
    <title>日常计算机小问题记录</title>
    <url>/2019/12/17/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="12-17"><a href="#12-17" class="headerlink" title="12.17"></a>12.17</h2><p>UBUNTU:<br>1.无法连接wifi，解决办法配置网卡<a href="https://blog.csdn.net/stay_zezo/article/details/80718369">https://blog.csdn.net/stay_zezo/article/details/80718369</a></p>
<p>2.vscode安装<br>sudo dpkg -i &lt;*.deb&gt;<br><a href="https://blog.csdn.net/weixin_43374723/article/details/84064644#1_Vscode_1">https://blog.csdn.net/weixin_43374723/article/details/84064644#1_Vscode_1</a></p>
<p>//todo<br>1.vscode关联hexo<br>2.Ubuntu安装ros,git<br>3.ubuntu安装hexo<br>学习：<br>1.师兄拟合算法修改<br>2.最大贴精度拟合撰写<br><img src="https://img-blog.csdn.net/20180720100435417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjbnRfMjAxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>工具技能</category>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>小问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记管理工具为知笔记/typora</title>
    <url>/2020/06/19/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/%E8%AE%B0%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Hexo网页文献分类"><a href="#Hexo网页文献分类" class="headerlink" title="Hexo网页文献分类"></a>Hexo网页文献分类</h2><p>-lovelife<br>-研究生学习笔记<br>-编程学习笔记<br>-工具技能收集<br>-科普常识收集</p>
<h2 id="ubuntu16-04工作环境优化"><a href="#ubuntu16-04工作环境优化" class="headerlink" title="ubuntu16.04工作环境优化"></a>ubuntu16.04工作环境优化</h2><p><a href="https://zhuanlan.zhihu.com/p/56253982">习惯配置知乎</a></p>
<ul>
<li>窗口栏项目跟随窗口</li>
<li>alt+tab优化Compizeconfig</li>
<li><a href="https://www.jianshu.com/p/f8f53be35512">Mac主题</a></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/68921091">软件推荐知乎</a></p>
<p><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu">deepin-wine安装软件Github</a></p>
<ol>
<li><strong>聊天工具</strong>：QQ/Tim/WeChat</li>
<li><strong>影音工具：</strong>网易云/百度网盘/迅雷极速版</li>
<li><strong>系统工具：</strong>indicator-sysmonitor，显示cpu内存网速等情况</li>
<li><strong>文档编辑:</strong> WPS, Typora+为知笔记,</li>
<li><strong>主题</strong>: MacOS</li>
</ol>
<h2 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h2><p><strong>Wiznote</strong>: 网络笔记本,一年60元,简洁无广告.可以写各种文档包括markdown.手机,win10,linux,web都可以用. 比OneNote方便,网速也快.我有一个网页所以好想并不需要,但是私密的东西是不能放在网页上的.100天试用,暂时还是不用这个,专注于自己的网页好啦.</p>
<img src="/2020/06/19/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/%E8%AE%B0%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95/lee/图片/icon/76c59a5bd832a4c3f74dd3b266b665fd.jpg" alt="76c59a5bd832a4c3f74dd3b266b665fd" style="zoom:10%;">

<p><strong>typora</strong>: 这个是真的理想中的md文档编辑器,不起网络服务器的功能,所以搭配上传到域名还挺好用.</p>
<p>​    </p>
]]></content>
      <categories>
        <category>工具技能</category>
        <category>笔记方法论</category>
      </categories>
      <tags>
        <tag>做笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MST最小生成树</title>
    <url>/2020/10/22/%E5%B8%B8%E8%AF%86%E5%BA%93/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>参考视频链接: <a href="https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=6207310363940342792">https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=6207310363940342792</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2020/10/22/%E5%B8%B8%E8%AF%86%E5%BA%93/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134619242.png" alt="image-20201022134619242" style="zoom: 67%;"><img src="/2020/10/22/%E5%B8%B8%E8%AF%86%E5%BA%93/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134724408.png" alt="image-20201022134724408"></p>
<p>树的三个特点, n个点至少需要n-1条边, 不能由环的出现</p>
<img src="/2020/10/22/%E5%B8%B8%E8%AF%86%E5%BA%93/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022134724408.png" alt="image-20201022134724408" style="zoom:67%;">

<p>最小的概念: 每条边都有相应的权重(可以是成本,距离等度量), 树中所有边的权重之和最小的方案为MST</p>
<a id="more"></a>

<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>有两种方法: Prime(寻找顶点) 和Kruskal(直接寻找边)</p>
<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><img src="/2020/10/22/%E5%B8%B8%E8%AF%86%E5%BA%93/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022135500215.png" alt="image-20201022135500215" style="zoom:67%;">

<ul>
<li>先将所有边按权重排序成列表</li>
<li>然后优先放入每条边判断是否成环</li>
<li>没有成环则加入MST; 若成环则放弃该边.</li>
</ul>
<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><img src="/2020/10/22/%E5%B8%B8%E8%AF%86%E5%BA%93/MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20201022140814900.png" alt="image-20201022140814900" style="zoom:67%;">

<p>以顶点为出发点, 每次选择两个集合(已选点集和未选点集)之间边权重最短的顶点加入已选集合,然后再以该顶点出发选择到未选集合权重最小的边. </p>
<p>需要三个列表,</p>
<ul>
<li>selected将顶点区分为两个集合:已选和未选</li>
<li>minDist, 保存与已选集合中顶点联通的边权重最小的值</li>
<li>parent, 保存minDist另一端的顶点编号</li>
</ul>
<p>三个步骤:</p>
<ol>
<li>更新列表, 更新所有与已选顶点集合相连通的顶点. 如果其边权重小于表中原来的值, 就更新minDist以及对应的parent顶点.</li>
<li>扫描minDist列表,选择最小的边的编号.</li>
<li>添加该边对应的顶点到已选点集. </li>
</ol>
]]></content>
      <categories>
        <category>常识库</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title>科学常识收集(一)</title>
    <url>/2019/12/13/%E5%B8%B8%E8%AF%86%E5%BA%93/%E7%A7%91%E5%AD%A6%E5%B8%B8%E8%AF%86%E6%94%B6%E9%9B%86(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="arg"><a href="#arg" class="headerlink" title="arg"></a><strong>arg</strong></h2><p>是变元（即自变量argument）的英文缩写。<br>arg min 就是使后面这个式子达到最小值时的变量的取值<br>arg max 就是使后面这个式子达到最大值时的变量的取值<br>例如 函数F(x,y):<br>arg  min F(x,y)就是指当F(x,y)取得最小值时，变量x,y的取值<br>arg  max F(x,y)就是指当F(x,y)取得最大值时，变量x,y的取值</p>
<h2 id="静态地图："><a href="#静态地图：" class="headerlink" title="静态地图："></a><strong>静态地图</strong>：</h2><p>可以去除激光雷达点云的大部分静态障碍物点，利用立方体表示区域。</p>
<h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化:"></a><strong>归一化</strong>:</h2><p>$$(x-min(x))/(max(x)-min(x))$$</p>
<h2 id="matlab画图"><a href="#matlab画图" class="headerlink" title="matlab画图"></a><strong>matlab画图</strong></h2><p>line([xmin,xmax],[ymin,ymax]); //可以画平行垂直的直线</p>
<h2 id="colorMap"><a href="#colorMap" class="headerlink" title="colorMap"></a>colorMap</h2><table>
<thead>
<tr>
<th align="center">颜色</th>
<th align="center">代号</th>
<th align="center">RGB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">red</td>
<td align="center">‘r’</td>
<td align="center">[1 0 0]</td>
</tr>
<tr>
<td align="center">green</td>
<td align="center">‘g’</td>
<td align="center">[0 1 0]</td>
</tr>
<tr>
<td align="center">blue</td>
<td align="center">‘b’</td>
<td align="center">[0 0 1]</td>
</tr>
<tr>
<td align="center">cyan</td>
<td align="center">‘c’</td>
<td align="center">[0 1 1]</td>
</tr>
<tr>
<td align="center">magenta</td>
<td align="center">‘m’</td>
<td align="center">[1 0 1]</td>
</tr>
<tr>
<td align="center">yellow</td>
<td align="center">‘y’</td>
<td align="center">[1 1 0]</td>
</tr>
<tr>
<td align="center">‘black’</td>
<td align="center">‘k’</td>
<td align="center">[1 1 1]</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>常识库</category>
      </categories>
      <tags>
        <tag>trips</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>科普常识收集</title>
    <url>/2019/12/25/%E5%B8%B8%E8%AF%86%E5%BA%93/%E7%A7%91%E6%99%AE%E5%B8%B8%E8%AF%86%E6%94%B6%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="四元素表示旋转"><a href="#四元素表示旋转" class="headerlink" title="四元素表示旋转"></a><strong>四元素表示旋转</strong></h1><h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a><strong>PCA</strong></h1><h1 id="最小二乘法与正太分布"><a href="#最小二乘法与正太分布" class="headerlink" title="最小二乘法与正太分布"></a><a href="https://www.matongxue.com/madocs/818.html">最小二乘法与正太分布</a></h1><p><img src="/2019/12/25/%E5%B8%B8%E8%AF%86%E5%BA%93/%E7%A7%91%E6%99%AE%E5%B8%B8%E8%AF%86%E6%94%B6%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89/MSQ.png"><br>中心极限定理,正太分布三个条件：独立随机变量，相加性.<br>如果误差的分布是正态分布(normal distribution)，那么最小二乘法得到的就是最有可能的值。</p>
<h1 id="分离轴定律"><a href="#分离轴定律" class="headerlink" title="分离轴定律"></a><strong>分离轴定律</strong></h1><h1 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h1><h1 id="滑移率悖论"><a href="#滑移率悖论" class="headerlink" title="滑移率悖论"></a><strong><a href="https://www.matongxue.com/madocs/2111/">滑移率悖论</a></strong></h1><h1 id="先验与后验"><a href="#先验与后验" class="headerlink" title="先验与后验"></a><strong>先验与后验</strong></h1><p>人的认识的基石是经验的积累。而经验的积累又分为：先验后验和超验。<br>后验指的是体验过后才知道的，比如菜是否好吃等。<br>先验是在体验之前就能知道的认识，比如人总是会死。<br>超验是超出体验外的，一般人无法共同体验，比如神话/情感等。</p>
<blockquote>
<p>后验的方式乍看之下最为真实可靠，其实不然。因为人的感官能力是不足的，常会受到遮蔽，受到视觉与听觉的欺骗，假如人的知识一切都要透过后验而来，那么人所知的将会非常的有限，而且往往只能知其然而不知其所以然。</p>
</blockquote>
<h1 id="参数和超参数hyper-parameter"><a href="#参数和超参数hyper-parameter" class="headerlink" title="参数和超参数hyper parameter"></a><strong>参数和超参数hyper parameter</strong></h1><ol>
<li>什么是参数<br>参数，也叫参变量，是一个变量。我们在研究当前问题的时候，关心某几个变量的变化以及它们之间的相互关系，其中有一个或一些叫自变量，另一个或另一些叫因变量。如果我们引入一个或一些另外的变量来描述自变量与因变量的变化，引入的变量本来并不是当前问题必须研究的变量，我们把这样的变量叫做参变量或参数。<br>在统计学中，描述总体特征的概括性数字度量，它是研究者想要了解的总体的某种特征值。总体未知的指标叫做参数。<br>在机器学习领域，参数还有自己独特的含义，由模型通过学习得到的变量，叫参数，比如权重w和偏置b。</li>
<li>什么是超参数<br>在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。</li>
<li>区别：参数是通过模型训练得到的，超参数是人为设定得到的。但是在识别准确度上要更好。那这两个模型训练得到的参数是有很大不同的。可控程度不同：超参数是人为设定，可控性高，参数与模型有关，得到的结果有时候与期望有差距，可控性较差。<h1 id="旋转坐标变换"><a href="#旋转坐标变换" class="headerlink" title="旋转坐标变换"></a><strong><a href="https://www.cnblogs.com/zhoug2020/p/7842808.html">旋转坐标变换</a></strong></h1></li>
</ol>
<h1 id="网申题目收集"><a href="#网申题目收集" class="headerlink" title="网申题目收集"></a><strong>网申题目收集</strong></h1><p><a href="http://www.360doc.com/content/17/1021/15/48674417_696917253.shtml">网申图形推理规律</a><br><a href="https://blog.csdn.net/u010189239/article/details/89288615?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">图形</a><br><a href="https://blog.csdn.net/wilsonpeng3/article/details/21469941?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">数字规律</a></p>
<p>牛客网你值得拥有</p>
]]></content>
      <categories>
        <category>常识库</category>
      </categories>
      <tags>
        <tag>trips</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>算法小知识（一）</title>
    <url>/2020/07/03/%E5%B8%B8%E8%AF%86%E5%BA%93/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="准确率，召回率"><a href="#准确率，召回率" class="headerlink" title="准确率，召回率"></a>准确率，召回率</h1><p><img src="/2020/07/03/%E5%B8%B8%E8%AF%86%E5%BA%93/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%9F%A5%E8%AF%86/image-20200711205519057.png" alt="image-20200711205519057"></p>
<p>1为正类，0为负类。</p>
<p>TP为true positive；FN为false negative.</p>
<ul>
<li>准确率(Accuracy)：预测正确的样本/总样本，（TP+TN）/all</li>
<li>精确率(precision)：实际为正类样本中，预测正确的比例，TP /（TP+FN）</li>
<li>召回率(Recall)：预测为正类样本中，实际正确的比例，TP /（TP+FP）</li>
</ul>
<h1 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h1><p><img src="https://img-blog.csdn.net/20170722202608058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVUVTVENfQzJfNDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
]]></content>
      <categories>
        <category>常识库</category>
      </categories>
      <tags>
        <tag>trips</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔10月20日</title>
    <url>/2020/10/21/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/1020%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="2020年10月21日"><a href="#2020年10月21日" class="headerlink" title="2020年10月21日"></a>2020年10月21日</h1><p>秋招就这样告一段落吧, 我必须好好准备一下自己的身体, 思想, 和专业知识去迎接社会的摧残。</p>
<a id="more"></a>

<h2 id="1-现状"><a href="#1-现状" class="headerlink" title="1 现状"></a>1 现状</h2><p>我现在每每努力一小会就觉得已经拼命了, 并且那一小会也总是不能集中注意力到重要的事情, 要么搞一些无关紧要的事情，要么就是刷手机去了。我真的努力不起来了，这也是我害怕去考公务员的原因吧？</p>
<p>另一个类似的现象就是每次开始工作的时候都要花一定时间去回顾上次干了什么，很多都忘记了，感觉到记性大不如前了。一个是可归结于工作不连续，时间过于零散造成的遗忘；另一方面就是记忆力真的下降了。大脑不用则退。</p>
<p>最近对这个道理突然很有感慨：平时这个技巧偷个懒，那个问题摸个油，看起来与别人差别不大，但是<strong>认真待事的态度</strong>简直太差地别，积累到最后就可以通过offer的质量和数量残酷的摆在自己眼前，让自己震惊。有人说，大学中加入各种社团和学生会就是为了没有太大代价的提前进入“小社会”捶打自己认真安排各种事务和处理各种人际的能力。我一直有察觉自己有一股无所谓、与世无争、随遇而安、淡然身外物、不斤斤计较的气，以前还挺引以为傲的，直到近年来才发觉ta已经越来越拖累自己了。这种刻意的反复的想法，潜移默化的在潜意识中为自己打上了这个标签，频率高了就可谓弄假成真。发展到现在这股气现在已经发展成为逃避麻烦、畏难、敷衍了事、对什么事都失去强烈的兴趣此般“黑紫色的邪恶的气”。</p>
<p>为什么这么说呢？举个例子，我真的很不明白为什么有人看个比赛能激动成那个样子，甚至是声泪俱下，我也有喜欢的队伍和比赛，但我顶多夸个666然后打住。或者说有人为了喜欢的姑娘那般投入时间和精力，那般愤怒那般快乐，而我和一个女生线上聊天都觉得折磨。<strong>我好像失去了什么</strong>。没有了强烈的情绪和兴趣，就连自己玩游戏也一副麻木的操作着，美其名曰娱乐至上。这种特质和我的另一个特点不谋而契合，那就是我做很多事情都是浮于表面，不能深入，不管是爱好还是专业知识。</p>
<p>此般种种现象都指向同一个问题，我仿佛失去了什么。<em>是爱的能力？</em> 爱自己，直面自己内心和情绪；爱一件事情，体会事物内部的细节；爱别人；爱生活。没有爱，是因为自己没有认真对待上述每一样。有人说，多大决心办多大事。下决心，就是下决心去认真对待并认真执行。而我这股气就是在阻止我认真的态度！一味的怕麻烦逃避敷衍也许可以生存下去，但决不能好好的生活。</p>
<h2 id="2分析"><a href="#2分析" class="headerlink" title="2分析"></a>2分析</h2><p>那么，是什么造成了我现在的困境呢？</p>
<p>知乎问，<a href="https://www.zhihu.com/question/422796779/answer/1507988868">人这一辈子，最不能透支是什么？ - 温水公爵的回答 - 知乎</a> 或许这个回答能帮助我看清楚一些上述问题根源。</p>
<blockquote>
<p>Imagine life as a game in which you are juggling some five balls in the air. You name them <strong>work, family, health, friends and spirit</strong> and you re keeping all of these in the air.You will soon understand that work is a rubber ball.If you drop it, it will bounce back. But the other four balls family, health, friends, and spirit are made of glass. If you drop one of these, they will be irrevocably scuffed, marked, nicked, damaged, or even shattered. They will never be the same. You must understand that and strive for balance in your life.</p>
</blockquote>
<h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><p>想要优质的物质和精神条件，就需要好好的利用时间。而在这之前是要有一个好好的身体。</p>
<p>现在我年轻气盛，想要做到健康，关键就在于：<strong>节欲</strong>。人与人之间的智力差别并不大，而造成我与别人差距这么大的原因就是身体。</p>
<p>纵欲的人，<strong>付出微小的代价就能收获很大的刺激</strong>(奶头乐），因而造成总是体力不支，精力不够，<em>做事总想赶紧完成，投入不够深</em>，<em>注意力不集中</em>，<em>长期记忆力变差</em>，别人在飞速学习的时候他就总需要休息。这种差距日积月累，在offer这个触发点上就清晰可见。</p>
<p>想要改善自己的身体状况，那就是节欲，熬夜的欲望，赖床的欲望，性欲，食欲……。</p>
<p>按时睡觉，早起吃早饭，男女之事不要过度，拒绝垃圾食品，拒绝抽烟喝酒，规律锻炼运动。</p>
<p>看起来简单，多年前我也总结出来了，但实行起来，尤为困难。最大的难点就是早起吃早饭以及性欲的规律了。调整回来这两点之后，坑定会为我提高精力，去认真对待其他事件。</p>
<h3 id="娱乐至死"><a href="#娱乐至死" class="headerlink" title="娱乐至死"></a>娱乐至死</h3><p>与上一个有异曲同工之处。奶头乐真正的危害是对于精神层面的。低代价的短期的高刺激满足感，正在一点点侵蚀掉我对于真正重要的低刺激的长期回报的事物的执行的动力。造成我努力一小会就觉得很拼命的错觉，行动力的上限条被很大程度削减了。特点，</p>
<p>另一方面，如今零碎化的信息正充斥着我的生活的方方面面，知乎、哔哩哔哩、微信公众号……，他们碎片化的高刺激的特点，并善于伪装成有用的特点，极大程度的吸走了属于我自己的注意力和时间。每个人每天的注意力集中的程度是有上限的。</p>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>书单完成时</title>
    <url>/2021/01/04/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E4%B9%A6%E5%8D%95%E5%AE%8C%E6%88%90%E6%97%B6/</url>
    <content><![CDATA[<p>kindle</p>
<ul>
<li>海边的卡夫卡</li>
<li>我们仨</li>
<li>解忧杂货店</li>
<li>月亮与六便士</li>
<li>绿山墙的安妮</li>
<li>小王子</li>
<li>自控力</li>
</ul>
<p>纸质</p>
<ul>
<li>当我跑步的时候我在想些什么</li>
<li><strong>C++ Primer</strong>!!!!</li>
</ul>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>句2</title>
    <url>/2019/12/10/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E5%A5%BD%E5%8F%A5/</url>
    <content><![CDATA[<p>总觉得日本的音乐、文学包括商品，都透露这一种柔腻和细致入微的日常感，切口很小，很平静，风轻云淡，让人舒服感动，像吹着海风一样仰望着天空畅想着美好又能脚踏实地<br>我们生活在不同的世界，你生活在一艘豪华的大船上，船上什么都有，有一辈子喝不完的美酒，还有许多跟你一样幸运登船的人。而我抓着一块浮木努力漂啊漂，海浪一波一波拍过来，怎么躲也躲不掉，随时都有被淹死的危险，还要担惊受怕有没有鲨鱼经。你还问我：为什么不抽空看看海上美丽的风景?<br>在小城市工作，就像收到一张五十年后的死亡通知； 而在大城市，则像是攥着一张虚构的藏宝图。<br>劳累过的人，才真正懂得自己想要的生活<br>比起考研与否，工作与否，其实选择并不重要，重要的是你做什么选择之后，能够全心全意不负自己的每一天，每一小时。知道自己未来要干嘛，知道自己要做什么一辈子，才会自律，会知道时间有限。<br> <img src="/2019/12/10/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E5%A5%BD%E5%8F%A5/asd.png"></p>
<p><strong>研究生</strong>:<br>“恭喜你对人类的知识有所创新，因此授予你这个学位。”<br><strong>问题取向</strong>。所有的精力、所有修课以及读的书里面都应该要有一个关注的焦点，而不能像大学那般漫无目标。<br>提出一个重要的问题，跨越一个重要的领域，将决定你未来的成败。<br>来自个人和老师、个人和同侪间密切的互动和学习是非常重要的。<br>每个人都要research，不断的一遍一遍再寻找，并进而使你的生活和学习成为一体。而我的生活和学习毫无疑问是彻底分开的。</p>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>时间管理</title>
    <url>/2020/03/22/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="日程表和待办事项"><a href="#日程表和待办事项" class="headerlink" title="日程表和待办事项"></a>日程表和待办事项</h2><p>经常使用日历和TODO这两个软件想要规划好自己的时间，但效果都很差，一是因为行动力差，但跟重要的原因是没有清楚他们的区别，对于有强迫症和重度纠结的我来讲，内心极度不稳。<br>想要成为一个热爱生活的人，必须利用好时间去好好的生，必须要对自己的每天24小时安排好卓什么事，只有做了想做的事情，才能成为想成为的人。</p>
<blockquote>
<p>“要么死，要么好好的活”   –《一个叫欧维的男人决定去死》</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/21914698/answer/459907860">https://www.zhihu.com/question/21914698/answer/459907860</a></p>
<a id="more"></a>
<ul>
<li><strong>日程表</strong><br>用来记录某个时间段一定会发生的事件，比如会议、球赛、约会等多人参加的约定。强调的事<strong>时间节点</strong></li>
<li><strong>TODO待办事项</strong><br>也叫任务清单，记录的是你想要做还没做的事，没有固定在某个时间段必须做，而是在<strong>deadline</strong>之前必须做。强调的是<strong>事情内容</strong></li>
<li>如果<strong>规律性事件</strong>，比如每天晚上11点肯定要看半小时书，就可以写到日程表中，安排其他事的时候就可以避开这段时间。</li>
</ul>
<h2 id="时间管理方法"><a href="#时间管理方法" class="headerlink" title="时间管理方法"></a>时间管理方法</h2><ul>
<li><p>工具：三星S9+</p>
</li>
<li><p>软件: 日历，TODO，提醒</p>
</li>
<li><p>目标：管理好daily schedule，培养好习惯</p>
</li>
<li><p><strong>实施</strong>：</p>
<ol>
<li><p>日程表：记录有<em>约定</em>的多人活动事件；记录自己<em>未来</em>确定的行程安排；记录<em>过去</em>的一些行程。</p>
</li>
<li><p>TODO：记录有dedline的工作、生活任务；或者想做的清单，比如购物清单，书单，愿望清单等等。</p>
</li>
<li><p>提醒：提醒一些自己容易忘掉的事情，比如晾衣服、取快递等</p>
</li>
<li><p>每晚睡前、或工作开始前，花10分钟管理一下自己的时间</p>
</li>
</ol>
</li>
<li><p>所有理论都需要实际行动支撑,不然假把式.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title>睡觉指南</title>
    <url>/2020/03/22/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%9D%A1%E8%A7%89%E5%9B%B0%E9%9A%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>总结自B站视频<a href="https://www.bilibili.com/video/BV1tV41127CQ?t=449"><strong>R90高效睡眠法</strong></a></p>
<h1 id="固定作息时间"><a href="#固定作息时间" class="headerlink" title="固定作息时间"></a>固定作息时间</h1><blockquote>
<ul>
<li>通常起床时间比进入工作状态时刻提前90min,或者1h也行. </li>
<li>然后倒推5个睡眠周期即7.5h推导出大致应睡着的时间.</li>
<li>然后睡前一小时开始准备入睡。 </li>
</ul>
</blockquote>
<p>按照上述公式，</p>
<table>
<thead>
<tr>
<th>9点进入工作</th>
<th>7点30~8点起床</th>
<th>0点～0点30睡着</th>
<th>23点～23点30准备入睡</th>
</tr>
</thead>
<tbody><tr>
<td>9点半进入工作</td>
<td>8点～8点30起床</td>
<td>0点30～1点睡着</td>
<td>23点30~12点准备入睡</td>
</tr>
</tbody></table>
<p>鉴于室友生活作息,12点半之前才能熄灯睡觉. 因此我反其道为之推导起床工作时间。</p>
<p>晚上<strong>0点30之前</strong>关掉手机和音乐酝酿睡觉。 <strong>8点和8点15</strong>起床铃铛</p>
<h1 id="做好前戏"><a href="#做好前戏" class="headerlink" title="做好前戏"></a>做好前戏</h1><h2 id="缩减体表体内温差"><a href="#缩减体表体内温差" class="headerlink" title="缩减体表体内温差"></a>缩减体表体内温差</h2><ul>
<li>睡前洗澡</li>
<li><strong>睡前泡脚</strong></li>
<li>舒缓运动</li>
</ul>
<p>睡前一小时进行。<strong>23点30</strong></p>
<h2 id="避免手机蓝光"><a href="#避免手机蓝光" class="headerlink" title="避免手机蓝光"></a>避免手机蓝光</h2><p>12点放下手机,或者看kindle</p>
<h2 id="放松身心"><a href="#放松身心" class="headerlink" title="放松身心"></a>放松身心</h2><ul>
<li><p>看无聊的书</p>
</li>
<li><p>冥想</p>
</li>
<li><p><strong>美国海军2分钟入眠</strong></p>
<p><img src="/2020/03/22/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%9D%A1%E8%A7%89%E5%9B%B0%E9%9A%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201011131654.jpg" alt="微信图片_20201011131654"></p>
</li>
</ul>
<ul>
<li>睡前在日记本上把所有想法捋捋清楚</li>
</ul>
<h2 id="调整睡姿"><a href="#调整睡姿" class="headerlink" title="调整睡姿"></a>调整睡姿</h2><p><strong>侧卧</strong>: 保证脊椎,颈椎和屁股在一条线上.</p>
<p><strong>平躺</strong>: 感受每个部位的受力,假装自己死掉啦</p>
<h1 id="布置睡觉环境"><a href="#布置睡觉环境" class="headerlink" title="布置睡觉环境"></a>布置睡觉环境</h1><ul>
<li><p>温度16~18℃. 凉爽通风. <em>無理だよ無理だよ</em></p>
</li>
<li><p>简单, 避光, 隔音. <em>無理だよ</em></p>
</li>
<li><p>床垫和枕头</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>睡觉</tag>
      </tags>
  </entry>
  <entry>
    <title>遇见百分百女孩</title>
    <url>/2019/12/19/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E9%81%87%E8%A7%81%E7%99%BE%E5%88%86%E7%99%BE%E5%A5%B3%E5%AD%A9/</url>
    <content><![CDATA[<img src="/2019/12/19/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E9%81%87%E8%A7%81%E7%99%BE%E5%88%86%E7%99%BE%E5%A5%B3%E5%AD%A9/遇见百分百女孩.jpg" alt="遇见百分百女孩" style="zoom:50%;">

<p>四月一个晴朗的早晨，在原宿后街，我同一个百分百女孩擦肩而过。</p>
<p>老实说，这女孩不见得有多漂亮，并不是很吸引人，穿着也不出众，脑后的头发还带有睡觉挤压的痕迹，年龄也不小了，应该快有30吧–严格地说来，恐怕很难称之为女孩。然而,在50米外我便一眼看出：她就是我的百分百女孩。看见她身影的那一瞬间，我的胸口受到地震一般的震颤，嘴里干得象沙沙作响的沙漠。</p>
<p>或许你也有你的百分百女孩。比如喜欢手脚纤细的女孩，喜欢眼睛大，手指绝对好看的女孩，或者不明所以地迷上慢慢吃东西的女孩。我当然也有自己的偏爱，在饭店时就曾看着邻桌一个女孩的鼻形发呆。但要明确勾勒出百分百女孩的形象，任何人都无法做到。我就绝对想不起她长有怎样的鼻子，甚至连是否有鼻子都已记不清楚。现在我所能记住的，只有她不是很漂亮这一点，事情真是不可思议。</p>
<p>“昨天，我在路上同一个百分百女孩擦肩而过。”我对一个人说。<br>“喔，”他应道，“她人可漂亮？”<br>“不，不是说这个。”<br>“那，是合你口味那种类型喽？”<br>“记不清了。眼睛长什么样啦，胸部是大是小啦，统统忘得一干二净。”<br>“莫名其妙啊！”<br>“是莫名其妙。”<br>“那么，”他显得兴味索然，“你干了什么？搭话了？还是跟踪了？”<br>“什么都没有做。”我说，“仅仅是擦肩而过。”</p>
<p>真的，仅仅是擦肩而过。<br>她由东往西，我从西向东，在四月里一个神清气爽的早晨。<br>我想和她说话，哪怕30分钟也好。我想知道她的一切，也想全盘托出自己。最重要的，是弄清到底是什么原因使我们有这样的命运，让我们在1981年4月一个晴朗的早晨，在原宿后街擦肩而过，这里面肯定充满着像和平时代的古老机器般温馨的秘密。说完了这些，我们可以找地方吃午饭，看伍迪.爱伦的影片，再顺路到宾馆里的酒吧喝点鸡尾酒什么的。弄得好，说不定还能同她睡上一觉。种种可能性在扣击着我的心扉。</p>
<p>我和她之间的距离只有十五六米了。问题是，我到底该如何向她搭话呢？</p>
<p>“你好！和我说说话可以吗？哪怕３０分钟也好。”<br>太傻气，简直象劝人买保险。<br>“请问，这一带有２４小时营业的洗衣店吗？”<br>一样的傻气，何况我连洗衣袋都没带！有谁能相信我的道白呢？<br>也许开门见山好些。“你好！你可是我的百分百女孩哟！”<br>不，不成，她不会相信我的表白。纵然相信，也未必愿意同我说话。她可能这样说：“即便我是你的百分百女孩，可是很抱歉，你不是我的百分百男孩呀。”这是很有可能的。假如真是这样，我肯定会被一下子打懵。这一打击说不定使我一蹶不振。我已３２岁，再也禁不起打击了，所谓上年纪归根结底便是这么一回事。我是在花店门前和她擦肩而过的，那暖暖的小小的气块儿触到了我的肌肤。柏油路面洒了水，周围荡漾着玫瑰花香。可我连向她打声招呼都做不到。她穿白毛衣，右手拿一个未贴邮票的四方信封。她给写了封信，你看她那样睡眼惺忪，说不定写了整整一个晚上。那四方信封里可能装有她全部的秘密。</p>
<p>走几步再回头时，她的身影早已消失在人群中。当然，今天我已完全清楚当时应怎样向她搭话。但不管怎么说，那道白实在太长，我肯定表达不好――就是这样，我想到的每次都不实用。<br>总之，这篇道白以“很久很久以前”开始，以“你不觉得这是个忧伤的故事吗”结束。<br>很久很久以前，有个地方有一个男孩和一个女孩。男孩十八岁，女孩十七岁。<br>男孩算不上英俊，女孩也不怎么漂亮，无非随处可见的孤独而平常的少男少女。但两人一直坚信世上某个地方一定存在百分之百适合自己的女孩和男孩。两人相信奇迹，而奇迹真的发生了。一天，两人在街头不期而遇。<br>“真巧！我一直在寻找你。也许你不相信，你就是我的百分百男孩。从头到脚都跟我想象的一模一样。简直像是在做梦。”两人坐在公园长椅上，手拉手，百谈不厌。两人已不再孤独，百分之百需求对方，也百分之百被对方需求。而百分之百需求对方和百分之百被对方需求是何等美妙的事情啊！这已是宇宙奇迹！</p>
<p>但两人心中掠过一个小小的，的确是小而又小的疑虑：梦想如此轻易成真是否真的就是好事？</p>
<p>交谈突然中断，男孩这样说道：“我说，再尝试一次吧！如果我们两人真是一对百分之百的恋人的话，肯定会有一天在哪里重逢。下次相遇时如果仍觉得对方百分之百，就马上在那里结婚，好么？</p>
<p>“好的。” 女孩回答。<br>于是两人分开，各奔东西。<br>不过说实在话，根本没有必要再尝试，这纯属多此一举。为什么呢？因为两人的的确确是一对百分之百的恋人，因为那的的确确是奇迹般的邂逅。但两人过于年轻，没办法知道这么多。于是无情的命运开始捉弄两人。</p>
<p>一年冬天，两人都染上了那年肆虐的恶性流感，在死亡线上徘徊几个星期后，过去的记忆丧失殆尽。事情也真是离奇，当两人睁眼醒来时，脑袋里犹如劳伦斯少年时代的贮币盒一样空空如也。但这对青年男女毕竟聪明豁达且极有毅力，经过不懈努力，终于再度获得了新的知识和新的情感，愉快地重返社会生活了。啊，我的上帝！这两人真是无可挑剔！他们又能够换乘地铁，能够在邮局寄快信了。并且分别体验了百分之七十五和百分之八十五的爱情。</p>
<p>如此来来往往，男孩32，女孩31岁了。时光以惊人的速度流逝。</p>
<p>四月一个晴朗的早晨，男孩为喝折价早咖啡沿原宿后街由西向东走，女孩为买快信邮票沿同一条街由东向西去，两人恰在路中间擦肩而过。失却记忆的微光刹那间照亮两颗心灵。</p>
<p>两人胸口陡然颤动，并且明白：<br>她就是我的百分百女孩。<br>他就是我的百分百男孩。</p>
<p>然而两人记忆的烛光实在过于微弱，两人的话语也不似十四年前那般清晰。结果连句话也没说便擦肩而过，径直消失在人群中，永远永远。<br>你不觉得这是个令人感伤的故事么？</p>
<p>是的，我本该这样向她搭话。</p>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>文章摘录</tag>
      </tags>
  </entry>
  <entry>
    <title>科普常识收集</title>
    <url>/2020/07/25/%E7%A0%94%E7%A9%B6%E7%94%9F/CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-距离变换"><a href="#1-距离变换" class="headerlink" title="1 距离变换"></a>1 距离变换</h2><p><a href="https://blog.csdn.net/trent1985/article/details/18081761">优秀链接</a>： </p>
<p>主要思想是通过表识空间点(目标点与背景点)距离的过程，最终将二值图像转换为灰度图像。边界模糊</p>
<p>假设一幅二值图像I，包含一个连通区域S，其中有目标集O和背景集B，距离图为D，则距离变换的公式:</p>
<p><img src="/2020/07/25/%E7%A0%94%E7%A9%B6%E7%94%9F/CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20201021204631120.png" alt="image-20201021204631120"></p>
<p>欧氏距离</p>
<p>曼哈顿距离（街区距离）</p>
<p>契比雪夫距离（棋盘距离）可以理解为国际象棋的王后的走法：</p>
<p><img src="/2020/07/25/%E7%A0%94%E7%A9%B6%E7%94%9F/CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/clip_image001.png"></p>
<p>倒角距离（chamfer）：优化二值图像的距离运算速度。</p>
<a id="more"></a>

<h2 id="2-边缘图像检测"><a href="#2-边缘图像检测" class="headerlink" title="2 边缘图像检测"></a>2 边缘图像检测</h2><h2 id="3-直方图处理"><a href="#3-直方图处理" class="headerlink" title="3 直方图处理"></a>3 直方图处理</h2><h2 id="4-检测库位内是否占据"><a href="#4-检测库位内是否占据" class="headerlink" title="4 检测库位内是否占据"></a>4 检测库位内是否占据</h2><ol>
<li>两条线之间的灰度直方图</li>
</ol>
<p><img src="/2020/07/25/%E7%A0%94%E7%A9%B6%E7%94%9F/CV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20201021204749083.png" alt="image-20201021204749083"></p>
<ol start="2">
<li>距离变换后的边缘图寻找垂直轮廓的直方图</li>
</ol>
]]></content>
      <categories>
        <category>研究生</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepPS</title>
    <url>/2020/07/13/%E7%A0%94%E7%A9%B6%E7%94%9F/DeepPS/</url>
    <content><![CDATA[<p>研究的问题–&gt;创新贡献–&gt;主要内容–&gt;结果–&gt;总结</p>
<h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><ul>
<li>引出: 视觉检测库位重要, 但是干扰因素多鲁棒性不好, 本文要解决这问题.</li>
</ul>
<h2 id="创新贡献"><a href="#创新贡献" class="headerlink" title="创新贡献"></a>创新贡献</h2><ol>
<li>DeepPS, 一个DCNN网络, 可以解决标记点的识别/ 分类.</li>
<li>建立了便于学习的数据集.</li>
</ol>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2>]]></content>
      <categories>
        <category>研究生</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>DeepPs</tag>
      </tags>
  </entry>
  <entry>
    <title>L-Shape_Fitting2</title>
    <url>/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/</url>
    <content><![CDATA[<p><em>Come from 《Efficient Rectangle Fitting of Sparse Laser Data for Robust On-Road Object Detection 2018，IV》,也是上篇论文的衍生文章。</em></p>
<h1 id="应用文献"><a href="#应用文献" class="headerlink" title="应用文献"></a>应用文献</h1><blockquote>
<p>F. U. Siddiqui, S. W. Teng, G. Lu, and M. Awrangjeb, “An improved building detection in complex sites using the lidar height variation and point density,” in International Conferenceon mage and Vision Computing New Zealand, 2013.</p>
</blockquote>
<p>generates a height map by using height threshold and extracts only <strong><em>parallel edges</em></strong> to fit a rectangle model.</p>
<h1 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h1><p>最新的研究方法（上一篇文献）在某种场景下deficient失效，作者针对这一场景进行优化，并拓展到凹形点云的拟合；此外并提出“更好”的一种判据。</p>
<a id="more"></a>

<h1 id="主要贡（chui）献（bi"><a href="#主要贡（chui）献（bi" class="headerlink" title="主要贡（chui）献（bi)"></a>主要贡（chui）献（bi)</h1><ol>
<li>优化了对凹形点云的拟合：<br>首先判断点云簇是不是凹的Concavity determination；利用k-Means方法把簇分割为几个簇分别拟合。从而拟合框占据空闲区域面积边缩小了。<br><img src="/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/concave.png"><center>concavity determination</center></li>
<li>提出一个新的拟合结果评估判据：<br>利用人工势场函数拟合距离d的分布直方图经验曲线（1360 clusters， 手动标记真值），自变量d是点到最近边的距离，d越小目标函数越大。计所有点的距离的函数值的和作为最终目标值函数。<br>作者认为真实点云是分布于轮廓附近而非BB，这也造成了 <strong><em>最大贴进度</em></strong> 判据的偏差。因此作者拟合的是轮廓框。<!-- more -->
<img src="/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/curve.png"><br><img src="/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/f.png"><br><img src="/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/%E4%BC%98%E5%8C%96.png"><br><img src="/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/CTAGC.png"><center>该判据中输入为旋转过的点云<em>p’</em>,轮廓框角点<em>B</em>; 输出判据值<em>Criterion</em></center></li>
</ol>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><ol>
<li>NUA（normalized unoverlapped area）：未重叠的面积与真值的比</li>
<li>角度误差</li>
<li>计算时间</li>
</ol>
<p><img src="/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/result1.png"><br><img src="/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/result2.png"><br><img src="/2019/12/13/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting2/result3.png"><br><strong>总的来看误差分析优势不大，完全可能是有意为之挤牙膏得到的。最大的贡献应该就是解决了多一种工况。此外对于精度的讨论也局限在角度，而没有位置误差的分析。但是经验曲线和针对特定工况问题发论文的角度值得借鉴</strong></p>
]]></content>
      <categories>
        <category>研究生</category>
        <category>LiDAR</category>
      </categories>
      <tags>
        <tag>L形状拟合</tag>
        <tag>点云</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>L-Shape-Fitting3</title>
    <url>/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/</url>
    <content><![CDATA[<p>From 《LiDAR-Based Object Tracking and Shape Estimation Using Polylines and Free-Space Information》<br><a href="https://ieeexplore.ieee.org/abstract/document/8593385#full-text-header">链接</a></p>
<h1 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h1><ol>
<li>将<strong>位姿信息估计</strong> 、<strong>多段线拟合的形状估计</strong> 二者结合同时推导跟踪车辆</li>
<li>对激光束点和传感器之间的 <strong>自由空间</strong> 利用起来，改进跟踪器。<br><img src="/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/1.gif"></li>
</ol>
<a id="more"></a>

<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><h2 id="状态跟踪-X-和形状估计-c-相互优化"><a href="#状态跟踪-X-和形状估计-c-相互优化" class="headerlink" title="状态跟踪(X)和形状估计(c)相互优化"></a>状态跟踪(X)和形状估计(c)相互优化</h2><p><img src="/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/2.gif"> <img src="/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/3.png"> <img src="/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/4.png"> <img src="/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/5.png"></p>
<h2 id="laser-scan-free-space-未占据的区域检测"><a href="#laser-scan-free-space-未占据的区域检测" class="headerlink" title="laser scan  free-space 未占据的区域检测"></a>laser scan  free-space 未占据的区域检测</h2><p><img src="/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/6.png"> <img src="/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/7.png"> <img src="/2019/12/16/%E7%A0%94%E7%A9%B6%E7%94%9F/L-Shape-Fitting3/8.png"></p>
<h1 id="主要结果"><a href="#主要结果" class="headerlink" title="主要结果"></a>主要结果</h1><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>方法看得不是很明白,他的重心不在怎么拟合,而是通过拟合形状与位姿信息最优化出跟踪信息.对自由空间的利用有空可以看看对泊车有什么启发</p>
]]></content>
      <categories>
        <category>研究生</category>
        <category>LiDAR</category>
      </categories>
      <tags>
        <tag>L形状拟合</tag>
        <tag>点云</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>L-ShapeFitting4</title>
    <url>/2019/12/25/%E7%A0%94%E7%A9%B6%E7%94%9F/L-ShapeFitting4/</url>
    <content><![CDATA[<h1 id="A-Fast-Ransac-Based-Approach-for-Computing-the-Orientation-of-Obstacles-in-Traffic-Scenes-2018-ICCP"><a href="#A-Fast-Ransac-Based-Approach-for-Computing-the-Orientation-of-Obstacles-in-Traffic-Scenes-2018-ICCP" class="headerlink" title="A Fast Ransac Based Approach for Computing the Orientation of Obstacles in Traffic Scenes 2018 ICCP"></a><a href="https://ieeexplore.ieee.org/abstract/document/8516642">A Fast Ransac Based Approach for Computing the Orientation of Obstacles in Traffic Scenes 2018 ICCP</a></h1><h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><blockquote>
<p>“最近，作为普通的1、2、4层和昂贵的64层激光雷达之间的中间解决方案，引入了16层或32层激光雷达传感器。”</p>
</blockquote>
<blockquote>
<p>D. Kim et al., “L-shape model switching-based precise motion tracking of moving vehicles using laser scanners”, IEEE Transactions on Intelligent Transportation Systems, vol. 19, no. 2, pp. 598-612, 2018.<br>依赖线束结构顺序L形状拟合，但是跟踪部分值得看“Tracking is further employed to smooth the results and to estimate dynamic features. ”<br>The rectangle fit is preferred if available. Tracking is then used for temporal filtering and smoothing.</p>
</blockquote>
<blockquote>
<p>X. Shen, S. Pendleton, M. H. Ang, “Efficient L-shape fitting of laser scanner data for vehicle pose estimation”, IEEE Conference on Robotics Automation and Mechatronics, pp. 173-178, 2015.<br>群集中的每个点都被视为枢轴（两条线的公共点），并且找到了最佳的一对线。<br>将要提出的方法不需要点的原始扫描顺序，也不需要分别为计算方向而对每个激光雷达层进行处理。因此，这是一种更通用的方法，适用于多层激光雷达</p>
</blockquote>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ol>
<li>低复杂度</li>
<li>RANSAC拟合到直角模型</li>
<li>占据面积准则选择最佳方向</li>
</ol>
<a id="more"></a>

<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p><img src="/2019/12/25/%E7%A0%94%E7%A9%B6%E7%94%9F/L-ShapeFitting4/1.png"></p>
<ol>
<li>输入，占据栅格图10cm检测障碍物ABB的框（绿色）</li>
<li>“可见边界”概念提出。<br> 就是将边缘点提取出来，利用射线追踪检查得到可见边界<br> <img src="/2019/12/25/%E7%A0%94%E7%A9%B6%E7%94%9F/L-ShapeFitting4/2.png">    </li>
<li>拟合垂直线模型RANSAC<br> 将提取出来的边界点拟合直线L1，再利用RANSAC选择其余点拟合L2<br> <img src="/2019/12/25/%E7%A0%94%E7%A9%B6%E7%94%9F/L-ShapeFitting4/3.png"></li>
<li>根据RANSAC的评分和未占据栅格的面积准则评估和验证最优方向<br> 在第一条线L的内部数上设置一个小的绝对阈值（= 8个像元），所以不适用于鸟瞰图小的物体。<br> 考虑只能观测到障碍物的一条边时的两种情况：<br>a. 该边具有很好的方向性，如建筑物/大车一边<pre><code> 解决办法：设定ransac拟合评分（即inlier的数目）阈值，大于这个阈值认为可靠度高。阈值的设定应当能够区别开车头的曲线和车辆侧方。</code></pre>
b. 该边不能很好的拟合，如小车车头<pre><code> 解决：当主方向线拟合的评分小于阈值，考虑次方向线的评分。若次方向依然不满足要求，则可以采取两个办法：①时间域跟踪滤波②根据拟合的框/ABB/视线方向框三者中未占据栅格的面积最小来选择最佳的主方向。</code></pre>
<img src="/2019/12/25/%E7%A0%94%E7%A9%B6%E7%94%9F/L-ShapeFitting4/4.png"></li>
</ol>
<h2 id="主要结果"><a href="#主要结果" class="headerlink" title="主要结果"></a>主要结果</h2><p><strong>时间：</strong><br>本方法：C++2.5GHz，0.2ms.<br>Lshape: C++ 1.6ms<br><strong>方向精度：</strong><br>选择了几个场景进行评估，第一个场景手动依据点云路沿估计真值。第二个场景在直的路上采的，默认真值为0°。<br>    <img src="/2019/12/25/%E7%A0%94%E7%A9%B6%E7%94%9F/L-ShapeFitting4/5.png">    <img src="/2019/12/25/%E7%A0%94%E7%A9%B6%E7%94%9F/L-ShapeFitting4/6.png">    </p>
<p>不足：<br>在近观测到车头和车尾情况下精度在4~6°，此外由于长方形拟合的局限性，对弯曲的栅栏等障碍物就不再适用。此时可以利用文献分享的西安交通大学的方法。<br><img src="/2019/12/25/%E7%A0%94%E7%A9%B6%E7%94%9F/L-ShapeFitting4/7.png"></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><pre><code>1. 占据栅格？or点云？--&gt;精度？or实时性？
2. 仅栅格聚类？or栅格拟合？
3. 这篇文章同我目前的预研究最为贴切，值得深思
4. 所有场景配备视频资料，很信服。
5. 利用跟踪进行部分误差修正。</code></pre>
<h1 id="An-Orientation-Corrected-Bounding-Box-Fit-Based-on-the-Convex-Hull-under-Real-Time-Constraints"><a href="#An-Orientation-Corrected-Bounding-Box-Fit-Based-on-the-Convex-Hull-under-Real-Time-Constraints" class="headerlink" title="An Orientation Corrected Bounding Box Fit Based on the Convex Hull under Real Time Constraints"></a><a href="https://ieeexplore.ieee.org/abstract/document/8500692/authors#authors">An Orientation Corrected Bounding Box Fit Based on the Convex Hull under Real Time Constraints</a></h1><h2 id="摘抄-1"><a href="#摘抄-1" class="headerlink" title="摘抄"></a>摘抄</h2><blockquote>
<p>基于点云的MODT问题经典处理思路是：<br>    1. 地面和障碍物分离<br>    2. 不同障碍物分割成类<br>    3. 簇拟合形状获取尺寸和位置信息<br>    4. 状态估计滤波器<br>Lshape的相关工作总结的挺好</p>
</blockquote>
<blockquote>
<p>P. Kmiotek and Y. Ruichek, “Representing and Tracking of Dynamics<br>Objects using Oriented Bounding Box and Extended Kalman Filter,”<br>in Proc. IEEE Intelligent Transportation Syst. Conf. (ITSC), 2008</p>
</blockquote>
<h2 id="主要贡献："><a href="#主要贡献：" class="headerlink" title="主要贡献："></a>主要贡献：</h2><ol>
<li>foucus on runtime</li>
<li>从凸包方法得到的点云加上旋转框（rotating calipers）得到初步的最小面积矩形。然后用了几种方法去做修正。<br>数学公式有点多解释又不清晰，感觉原理应该不难，就是故意整一堆数学模型复杂化又不说清楚。不想看了。</li>
</ol>
<h1 id="Tracking-of-Moving-Objects-from-a-Moving-Vehicle-Using-a-Scanning-Laser-Rangefinder"><a href="#Tracking-of-Moving-Objects-from-a-Moving-Vehicle-Using-a-Scanning-Laser-Rangefinder" class="headerlink" title="Tracking of Moving Objects from a Moving Vehicle Using a Scanning Laser Rangefinder"></a><a href="https://ieeexplore.ieee.org/document/1706758?arnumber=1706758&tag=1">Tracking of Moving Objects from a Moving Vehicle Using a Scanning Laser Rangefinder</a></h1><h2 id="摘抄-2"><a href="#摘抄-2" class="headerlink" title="摘抄"></a>摘抄</h2><blockquote>
<p>跟踪的主要步骤是：分割，特征提取，数据关联，卡尔曼滤波和跟踪验证<br>“在 [16] 中，采用加权最小二乘法去除离群点，将不完整的轮廓拟合到矩形模型中。考虑到遮挡问题，在 [16] 中同时进行了线拟合和直角角拟合，只有当角拟合明显好于线拟合时，才选择角拟合。”</p>
</blockquote>
<blockquote>
<p>试拟合后，最差的20％的点将被丢弃。我们还对密集采样的区域（由于距离扫描仪较近）减轻了点的权重。<br>The scanner can see at most two sides of the rectangle,<br>尝试将对象中心用作参考点被证明是徒劳的，因为很少能直接测量中心。</p>
</blockquote>
<h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>提到一些用于跟踪的卡尔曼滤波的方法值得参考：<br>    1. 用跟踪解决雷达稀疏效应造成的过分割和无效点，以及近处遮挡造成的分块<br>    2. 将噪声分成两部分：静态噪声和自适应噪声，分别由于硬件限制和分割拟合算法造成。<strong>其中自适应噪声用了前15次测量的预测值和观测值之间的残差的协方差矩阵作为噪音矩阵，再加上静态噪声的倍数确保下限。</strong>每次误差中心偏离零值过多再利用观测值重置。</p>
]]></content>
      <categories>
        <category>研究生</category>
        <category>LiDAR</category>
      </categories>
      <tags>
        <tag>L形状拟合</tag>
        <tag>点云</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SAT</title>
    <url>/2020/11/27/%E7%A0%94%E7%A9%B6%E7%94%9F/SAT/</url>
    <content><![CDATA[<p><img src="/2020/11/27/%E7%A0%94%E7%A9%B6%E7%94%9F/SAT/clip_image001.png"></p>
<p><img src="/2020/11/27/%E7%A0%94%E7%A9%B6%E7%94%9F/SAT/clip_image002.png" alt="img"></p>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>How to read a paper</title>
    <url>/2020/07/10/%E7%A0%94%E7%A9%B6%E7%94%9F/howtoreadapaper/</url>
    <content><![CDATA[<h2 id="编码格式UTF-8与中文"><a href="#编码格式UTF-8与中文" class="headerlink" title="编码格式UTF-8与中文"></a>编码格式UTF-8与中文</h2><h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><h2 id="《How-to-read-a-paper》"><a href="#《How-to-read-a-paper》" class="headerlink" title="《How to read a paper》"></a>《How to read a paper》</h2><h3 id="读什么"><a href="#读什么" class="headerlink" title="读什么"></a>读什么</h3><blockquote>
<p><strong>第一阶段是看论文中是否有感兴趣的东西。</strong>AI论文含有摘要，其中可能有内容的介绍，但是也有可能没有或者总结得不好，因此需要你跳读，这看一点那看一点，了解作者究竟做了些什么。内容目录（the table of contents）、结论部分（conclusion）和简介（introduction）是三个重点。如果这些方法都不行，就只好顺序快速浏览了。一旦搞清楚了论文的大概和创新点，就可以决定是否需要进行第二阶段了。</p>
<p><strong>第二阶段，要找出论文真正具有内容的部分。</strong>很多15页的论文可以重写为一页左右的篇幅；因此需要你寻找那些真正激动人心的地方，这经常隐藏于某个地方。（Key）论文作者从其工作中所发现的感兴趣的地方，未必是你感兴趣的，反之亦然。</p>
<p><strong>最后，如果觉得该论文确实有价值，返回去通篇精读。</strong>读论文时要牢记几个问题：“我应该如何利用该论文？”“真的像作者宣称的那样么？”“如果……会发生什么？”。理解论文得到了什么结论并不等同于理解了该论文。理解论文，就要了解论文的目的，作者所作的选择（很多都是隐含的），假设和形式化是否可行，论文指出了怎样的方向，论文所涉及领域都有哪些问题，作者的研究中持续出现的难点模式是什么，论文所表达的策略观点是什么，诸如此类。</p>
</blockquote>
<h3 id="记什么"><a href="#记什么" class="headerlink" title="记什么"></a>记什么</h3><p>思路：研究问题–&gt;创新点–&gt;解决方法–&gt;结果–&gt;总结</p>
<p>自己要思考精读一篇文献，</p>
<ul>
<li>文章研究的问题是什么？该问题的范畴是什么？进行了何种假设？</li>
<li>文章如何针对该问题进行解决的？创新之处在哪？</li>
<li>研究的具体方法是什么？用到了哪些工具手段？</li>
<li>结果如何？哪些得到了征明？</li>
<li>总结，可以参考和不足之处在哪？</li>
</ul>
<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2>]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>L-Shape fitting</title>
    <url>/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/</url>
    <content><![CDATA[<p>Come from《Efficient L-Shape Fitting for Vehicle Detection Using Laser Scanners》</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://zhuanlan.zhihu.com/p/89011097?utm_source=wechat_session&utm_medium=social&utm_oi=607673551159955456">范文</a></p>
<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>k-d树搜索组织点云，eucilid聚类，距离阈值是range的函数能够自适应。值得注意的是只使用了点云的xy坐标聚类。</p>
<h2 id="L-Shape拟合"><a href="#L-Shape拟合" class="headerlink" title="L-Shape拟合"></a>L-Shape拟合</h2><p>对于每个簇的拟合结果的性能用最小二乘法进行评估（与拟合优度有何不同？）。注意他这里计算所有点到矩形边的距离，据此将点分为p、q两拨，然后计算所有的平方差之和，作为目标函数。</p>
<img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/1.png" alt="1" style="zoom:80%;">



<a id="more"></a>

<p>θ是矩形框一条边的方向，按照0~90°空间进行搜索，注意搜索步长step如何设置？寻找到目标函数最小的作为拟合结果。<br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/2.png"><br>值得借鉴的是,她利用(sinθ,cosθ)单位向量来表示矩形的边比较方便,相比于用斜率k表示。总体这方法比较熟悉，与王宇辰的一样，只是选择最优的目标函数变化；同时，作者提供了3种各有优劣的判据：<strong>最小面积，最小距离（贴进度），最小平方误差</strong>3种方法，王宇辰采用的是样本到矩形角点距离和最小的判据。分别如下：<br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/3.gif" alt="Area Criterion"><center>Area Criterion</center><br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/4.gif"><center>Closeness Criterion</center><br>求得样本点到4边最小的距离的倒数<code>d=(min&#123;D1,D2&#125;)^-1</code>作为目标值，设置d0阈值限制分母很小的权重<br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/5.gif"><center>Variance Criterion</center><br>按照样本点距离两边的距离大小分为两拨E1/E2记录下每个点的最小距离，然后求方差之和</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/6.png"><br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/7.gif"><br>上面两张图看出来贴进度的判据好像最好<br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/8.gif"><br>不适用的场景如上,依然会受到后视镜/内部点等干扰影响拟合角度的精度.但是作者认为两种算法互相弥补,并且会在下一时刻得到纠正.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文章算法清晰,值得参考的点:</p>
<ol>
<li>用单位向量和点云在其的投影来表示矩形框及计算其目标函数，方便</li>
<li>多个优化标准相互弥补</li>
<li>衡量拟合结果好坏的标准。</li>
<li><strong>其中按照距离大小把点云分为两拨重新拟合的方法是否值得一试？</strong></li>
</ol>
<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><blockquote>
<p>Comparing poses among successive cycles also helps to find the target’s heading direction.</p>
</blockquote>
<h1 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h1><blockquote>
<p>[17]X. Shen, S. Pendleton, M. H. Ang, “Efficient L-shape fitting of laser scanner data for vehicle pose estimation”, IEEE Conference on Robotics Automation and Mechatronics, pp. 173-178, 2015.</p>
</blockquote>
<p>在文中，利用距离点的排序，即<strong>扫描序列的信息</strong>，有效地将这些点分割成两个互不相交的集合，然后将这两个集合的点分别拟合成两条正交直线，分别对应于小车的两条边;按照扫描序列迭代所有这些二维范围点，该算法搜索一个轴心点，并使用该轴心点生成这两个不相交集，即，在主元之前扫描的点集和在主元之后扫描的点集。</p>
<blockquote>
<p>[16]R. MacLachlan, C. Mertz, “Tracking of moving objects from a moving vehicle using a scanning laser range finder”, IEEE Intelligent Transportation Systems Conference, pp. 301-306, 2006.</p>
</blockquote>
<p>在[16]中，采用加权最小二乘法去除离群点，将不完整的轮廓拟合到矩形模型中。考虑到遮挡问题，在[16]中<strong>同时进行了线拟合和直角角拟合</strong>，只有当角拟合明显好于线拟合时，才选择角拟合。</p>
<h1 id="被引用文献"><a href="#被引用文献" class="headerlink" title="被引用文献"></a>被引用文献</h1><h2 id="《BoxNet深度学习2DBB》"><a href="#《BoxNet深度学习2DBB》" class="headerlink" title="《BoxNet深度学习2DBB》"></a>《BoxNet深度学习2DBB》</h2><p><a href="https://ieeexplore.ieee.org/abstract/document/8814058/authors#authors">BoxNet: A Deep Learning Method for 2D Bounding Box Estimation from Bird’s-Eye View Point Cloud，2019</a></p>
<h3 id="引用文献-1"><a href="#引用文献-1" class="headerlink" title="引用文献"></a>引用文献</h3><blockquote>
<p>D. Zermas, I. Izzat, N. Papanikolopoulos, “Fast <strong>segmentation</strong> of 3D point clouds: A paradigm on LiDAR data for autonomous vehicle applications”, IEEE International Conference on Robotics and Automation, 2017.</p>
</blockquote>
<blockquote>
<p>[15]H. Zhao, Q. Zhang, M. Chiba, R. Shibasaki, J. Cui, H. Zha, “Moving Object Classification using Horizontal Laser Scan Data”, IEEE International Conference on Robotics and Automation, 2009.<br>利用K-L变换提取两个主轴</p>
</blockquote>
<blockquote>
<p><strong>[17]D. Kim, K. Jo, M. Lee, M. Sunwoo, “L-shape model switching-based precise motion tracking of moving vehicles using laser scanners”, IEEE Transactions on Intelligent Transportation Systems, vol. 19, no. 2, 2018.</strong><br>使用点的有序信息将这些点迭代地聚类为两个正交的线段</p>
</blockquote>
<h3 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h3><p><strong>来源</strong>: 受到深度学习识别RGB车辆3DBB的启发,识别BEV中点云的2DBB.传统的方法要么需要有序点,要么计算开销大.<br><strong>IO</strong>: input|Points(x,y)<br>        output|[center_x,center_y,width,length,cos(2θ),sin(2θ)]’</p>
<h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><ol>
<li>主要区别在于二维包围盒拟合中不需要估计航向。为了避免-π和π的模糊性,作者使用<strong>the double-angle sinusoidal values</strong>cos(2θ)和sin(2θ)来表示角度,解决了网络学习的不连续性.</li>
<li>预测了点云均值的中心,提高bb位置精度.</li>
</ol>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>利用2w个Car类型样本训练<br><strong>评估指标</strong>: 中心位置误差,角度误差,Groudtruth 和BB 的重叠比例.<br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/2-1.gif"><center>平均误差比较</center><br>不足:行人的边界框要小得多，并且长宽比更接近1。因此，BEV点不能表示明确的主轴，并沿着该主轴可以明确定义人的朝向。<br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/2-3.gif"><br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/L-shape-fitting/2-2.gif"><center>IoU重叠部分更好,对扩展目标的原本尺寸估计更好</center><br>运行时间大约在7.36ms,下采样到512点</p>
<h2 id="《LATTE一个开源点云注释标签的工具》"><a href="#《LATTE一个开源点云注释标签的工具》" class="headerlink" title="《LATTE一个开源点云注释标签的工具》"></a>《LATTE一个开源点云注释标签的工具》</h2><p><a href="https://github.com/bernwang/latte">github</a><br><strong>思路</strong>：标注人员只需要点一下需要标注的物体附近，算法即刻运行画BB的算法，包括地面去除（平面拟合，奇异值分解求取最佳法向量）、DBSCAN聚类、搜索空间算法（前文）。<br><strong>总结</strong>：参考意义不大，但是如果考虑深度学习，这是一个好工具。</p>
<h2 id="《L形端点搜索和角点定位，2018-同济》"><a href="#《L形端点搜索和角点定位，2018-同济》" class="headerlink" title="《L形端点搜索和角点定位，2018 同济》"></a>《L形端点搜索和角点定位，2018 同济》</h2><p><a href="https://ieeexplore.ieee.org/abstract/document/8665265">An Efficient L-Shape Fitting Method for Vehicle Pose Detection with 2D LiDAR</a></p>
<h3 id="主要贡献-1"><a href="#主要贡献-1" class="headerlink" title="主要贡献"></a>主要贡献</h3><blockquote>
<p>·decomposes the L-Shape fitting problem into two steps: L-Shape vertexes searching and L-Shape corner point locating.<br>·highly computationally efficient<br>·robust enough and able to accommodate various situations.<br>·does not depend on the laser scanning sequential information</p>
</blockquote>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><p>the mean-shift &amp; DBSCAN</p>
<h4 id="L形拟合"><a href="#L形拟合" class="headerlink" title="L形拟合"></a>L形拟合</h4><p>有一个问题，文中过渡时说基于搜索空间的方法无法访问簇的序列/顺序，但这个算法不需要有序的点啊？<br>什么玩意，没什么想不到的东西，就字面那么简单！<br>最后就评估了下时间，matlab-6.2ms，算法不可信。</p>
]]></content>
      <categories>
        <category>研究生</category>
        <category>LiDAR</category>
      </categories>
      <tags>
        <tag>L形状拟合</tag>
        <tag>点云</tag>
        <tag>读书笔记</tag>
        <tag>标注工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Python深度学习笔记(一)</title>
    <url>/2020/07/13/%E7%A0%94%E7%A9%B6%E7%94%9F/python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<p>待整理:</p>
<ul>
<li>卷积层池化层</li>
<li>梯度下降</li>
<li>pytorch</li>
<li>numpy</li>
</ul>
<p>学习网站:B站莫烦python</p>
<p><code>namedtuple()</code>:是产生具有命名字段的元组的工厂函数</p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>点云处理优秀链接</title>
    <url>/2020/07/13/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://pointclouds.org/">PCL官网</a><br><a href="https://blog.csdn.net/xuezhisdc/article/details/51012300">PCL点云配准</a><br><a href="https://www.cnblogs.com/yhlx125/category/454932.html">点云笔记1</a><br><a href="https://blog.csdn.net/RNG_uzi_/article/details/90146844#7">点云笔记2</a><br><a href="https://scikit-learn.org/stable/modules/clustering.html">scikit-learn-基于python的机器学习项目</a></p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>这个最小二乘法的误差分析需要了解</p>
<blockquote>
<p>常见的平面拟合方法一般是最小二乘法。<strong>当误差服从正态分布时，最小二乘方法的拟合效果还是很好的，可以转化成PCA问题</strong><br>　当观测值的误差大于2倍中误差时，认为误差较大。采用最小二乘拟合时精度降低，不够稳健。<br>　提出了一些稳健的方法：有移动最小二乘法（根据距离残差增加权重）；采用2倍距离残差的协方差剔除离群点；迭代重权重方法(选权迭代法)。<br>　MainWindow中的平面拟合方法，调用了ccPlane的Fit方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>研究生</category>
        <category>LiDAR</category>
      </categories>
      <tags>
        <tag>PCL</tag>
        <tag>点云</tag>
      </tags>
  </entry>
  <entry>
    <title>点云处理算法综述</title>
    <url>/2020/09/07/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<p>自动驾驶对于检测算法有着比较特殊的要求：首先为了安全性考虑召回率要高，即不能漏检；其次因为检测到的物体是下游路径规划和运动决策算法的输入，这要求检测到的目标在连续帧中具有较好的稳定性，具体而言即在连续帧中检测到的同一个物体的类别、尺寸、位置和方向不能有剧烈的变化。与此同时因为激光点云的稀疏性，现有算法单用一帧点云数据无法在小物体、远处物体和被遮挡物体的检测上得到令人满意的结果。</p>
<p>开始考虑结合多种传感器数据的方法、结合多个激光雷达的方法以及结合连续多帧的方法。虽然在学术界的排行榜中现在最好的方法是基于深度学习的算法，但是在实际问题中数据的预处理、后处理等对最终结果有着至关重要的影响，而这些部分的算法往往需要根据数据和使用场景有针对性的设计。</p>
<h3 id="Range-Image-Graph"><a href="#Range-Image-Graph" class="headerlink" title="Range Image/Graph"></a>Range Image/Graph</h3><h3 id="VoxelNet"><a href="#VoxelNet" class="headerlink" title="VoxelNet"></a>VoxelNet</h3><p>将点云分布组织到体素网格中，再再鸟瞰图中应用深度学习框架。和二维图片检测相比VoxelNet不仅要给出物体中心的二维坐标和包围盒的长宽，还需要给出物体中心在Z轴的位置、物体的高度和物体在XY平面上的朝向。</p>
<p>缺点：体素太多的时候，会出现计算出错或者效率问题，一些学习框架不会考虑。三维卷积太消耗计算量无法实时。</p>
<p>类似的网络：pixorNet,pointNet++02</p>
<h3 id="多帧"><a href="#多帧" class="headerlink" title="多帧"></a>多帧</h3><p>Luo利用深度神经网络在鸟瞰图中通过连续帧的数据进行目标检测【20】。</p>
<p>其建立了一个“多入多出”的结构，即算法的输入是过去连续帧的鸟瞰图，而算法的输出是当前时刻和未来连续时刻的物体位置。Luo希望通过这种结构让网络不仅仅学习到物体在鸟瞰图中的形状，还可以学习到物体的速度、加速度信息。</p>
]]></content>
      <categories>
        <category>研究生</category>
        <category>LiDAR</category>
      </categories>
      <tags>
        <tag>小知识</tag>
        <tag>点云</tag>
      </tags>
  </entry>
  <entry>
    <title>顶会常关注优质文章,快乐科研</title>
    <url>/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/%E9%A1%B6%E4%BC%9A%E5%B8%B8%E5%85%B3%E6%B3%A8/</url>
    <content><![CDATA[<h2 id="机器人邻域"><a href="#机器人邻域" class="headerlink" title="机器人邻域"></a>机器人邻域</h2><ol>
<li>RSS（Robotics: Science and System）</li>
<li>IROS（IEEE\RSJ International Conference on Intelligent Robots and Systems）</li>
<li>ICRA（IEEE International Conference on Robotics and Automation）</li>
</ol>
<h2 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h2><ol>
<li>CVPR 国际计算机视觉与模式识别会议（CVPR）</li>
<li>ICCV 全称是 IEEE International Conference on Computer Vision，即国际计算机视觉大会</li>
<li>ECCV 全称是European Conference on Computer Vision(欧洲计算机视觉国际会议) ，两年一次，是计算机视觉三大会议（另外两个是ICCV和CVPR）之一。</li>
<li>ICPR</li>
</ol>
<h2 id="智能车邻域"><a href="#智能车邻域" class="headerlink" title="智能车邻域"></a>智能车邻域</h2><ol>
<li>IV Intelligent Vehicle Symposium</li>
<li>ITSVC 智能交通系统国际会议（Intelligent Transportation Systems Conference，简称ITSC）</li>
<li>ICVES</li>
</ol>
<h2 id="邂逅其他相关会议"><a href="#邂逅其他相关会议" class="headerlink" title="邂逅其他相关会议"></a>邂逅其他相关会议</h2><ol>
<li>IEEE International Conference on Robotics and Biomimetics (ROBIO)</li>
<li>New Energy &amp; Intelligent Connected Vehicle Technology Conference</li>
</ol>
<h2 id="学院要求"><a href="#学院要求" class="headerlink" title="学院要求"></a>学院要求</h2><ol>
<li>A类：SAE/ITSC/IV/JSAE/ICRA（机器人与自动化会议)</li>
<li>B类：ICIRA/ICON（自然语言处理会议）/ICCV<br><img src="/2019/12/12/%E7%A0%94%E7%A9%B6%E7%94%9F/%E9%A1%B6%E4%BC%9A%E5%B8%B8%E5%85%B3%E6%B3%A8/1.png"></li>
</ol>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>顶会</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake</title>
    <url>/2020/07/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="g-和cmake-make"><a href="#g-和cmake-make" class="headerlink" title="g++和cmake,make"></a>g++和cmake,make</h1><p><a href="http://blog.sina.com.cn/s/blog_74a459380102uxlz.html">学习链接</a></p>
<p>任何一个文本程序生成可执行文件的步骤都是:</p>
<ol>
<li>编辑器编写源代码,.cpp</li>
<li>编译器编译代码生成目标文件,.o文件</li>
<li>链接器链接各个目标文件,生成可执行文件,.exe</li>
</ol>
<p>由于很多cpp相互关联,一个一个编译就很麻烦,于是出现了利用makefile规则文件自动编译这些cpp. 但是makefile的编写也很麻烦,于是又出现了cmake工具自动编写makefile.</p>
<p>流程如下:</p>
<blockquote>
<p>源文件–&gt;CmakeLists–&gt;cmake–&gt;makefiles–&gt;make–&gt;.exe可执行文件.</p>
</blockquote>
<p>其中gcc和g++在make阶段编译和链接文件,g++在gcc的基础上默认关联了C++库。</p>
<h1 id="cmake一个helloworld实例"><a href="#cmake一个helloworld实例" class="headerlink" title="cmake一个helloworld实例"></a>cmake一个helloworld实例</h1><p><a href="https://www.cnblogs.com/haijian/p/12039160.html">https://www.cnblogs.com/haijian/p/12039160.html</a></p>
<img src="/2020/07/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/1365039-20191214155830875-1005241267.png" alt="1365039-20191214155830875-1005241267" style="zoom:50%;">

<h2 id="PCL点云库从入门到精通"><a href="#PCL点云库从入门到精通" class="headerlink" title="PCL点云库从入门到精通"></a>PCL点云库从入门到精通</h2><p>由于《PCL点云库从入门到精通》配套代码只有C++语言，不能直接用于ROS平台，遂可先在Ubuntu中编译学习。</p>
<ol>
<li>在source文件夹（含有cpp，CMake，pcd）中新建文件夹build：<code>cd source/;mkdir build/</code></li>
<li>编译source文件夹中的cpp代码：<code>cd build/; cmake ..</code></li>
<li>生成可执行文件：<code>make</code></li>
<li>运行可执行文件：`./execute_name</li>
</ol>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p><a href="https://cmake.org/cmake/help/v3.1/">官网教程</a></p>
<p> <a href="https://blog.csdn.net/AdamShan/article/details/82901295"><strong>ROS：依赖文件和环境</strong></a><br>  <a href="https://www.cnblogs.com/Jessica-jie/p/6520481.html"><strong>CMakeList详细解读</strong></a><br> 视频讲解的更加基础。<br> CMakeLists.txt文件是CMake构建系统的输入，在这里我们不会详细讨论CMake的写法（因为它本身可以很复杂），我们大致熟悉一下我们常用的CMake的语法：</p>
<p><code>SET(CMAKE_BUILD_TYPE Release)</code>: 指定编译类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) #指定可执行文件生成目录</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)#指定链接文件生成目录</span><br></pre></td></tr></table></figure>

<p><code>include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</code> : 添加头文件存放的目录</p>
<p><code>add_executable(helloworld src/helloworld.cpp src/main.cpp)</code>:选择要编译的程序文件</p>
<p><code>target_link_libraries(myProject a.cpp)</code>: 将二者链接起来</p>
<p><code>cmake_minimum_required：</code>需要的CMake的最低版本<br><code>project():</code>包的名称<br><code>find_package()</code> 查找建构是需要的其他 CMake/Catkin 包<br><code>add_message_files() add_service_files() add_action_files</code> 生成Message/Service/Action<br><code>generate_messages()</code> 调用消息生成<br><code>catkin_package()</code> 指定包的构建信息<br><code>add_library()/add_executable()/target_link_libraries()</code> 用于构建的库，可执行代码</p>
<p>同样的，在<code>CMakeList</code>中，我们通过<code>find_package</code>查找这三个包的路径，然后将三个包添加到 <code>CATKIN_DEPENDS</code>, 在使用pcl库前，需要将PCL库的路径链接，通过<code>link_directories( $ &#123;PCL_LIBRARY_DIRS&#125;)</code>来完成，并在最后的<code>target_link_libraries</code>中添加<code>$&#123;PCL_LIBRARIES&#125;</code>。</p>
<p> <code>package.xml</code>的内容很简单，实际上就是这个包的描述文件， <code>build_depend</code> 和 <code>run_depend</code> 两个描述符分别指定了程序包编译和运行的依赖项，通常是所用到的库文件的名称。 在这里我们指定了三个编译和运行时依赖项，分别是<code>roscpp</code>（编写C++ ROS节点），<code>sensor_msgs</code>（定义了激光雷达的msg），<code>pcl_ros</code>（连接ROS和pcl库）。</p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>C++编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Eigen学习笔记</title>
    <url>/2020/10/13/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Eigen%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<p>参考网站: <a href="https://zhuanlan.zhihu.com/p/36772345">https://zhuanlan.zhihu.com/p/36772345</a></p>
<p>官方教程: <a href="https://eigen.tuxfamily.org/dox/group__QuickRefPage.html">https://eigen.tuxfamily.org/dox/group__QuickRefPage.html</a></p>
<p>简单认识参考网站: <a href="https://zhuanlan.zhihu.com/p/36772345">https://zhuanlan.zhihu.com/p/36772345</a></p>
<p>细节学习个人博客: <a href="http://zhaoxuhui.top/blog/2019/08/21/eigen-note-1.html">http://zhaoxuhui.top/blog/2019/08/21/eigen-note-1.html</a></p>
<h1 id="CMake库中的声明"><a href="#CMake库中的声明" class="headerlink" title="CMake库中的声明"></a>CMake库中的声明</h1><p>Eigen库本身全是头文件，只需要将头文件包含到路径中即可。</p>
<h2 id="方法1-修改vscode环境配置"><a href="#方法1-修改vscode环境配置" class="headerlink" title="方法1 修改vscode环境配置"></a>方法1 修改vscode环境配置</h2><p><a href="%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/vscode%E9%85%8D%E7%BD%AEC++%E7%A8%8B%E5%BA%8F.md">vscode配置C++程序.md</a></p>
<h2 id="方法2-CMake工具"><a href="#方法2-CMake工具" class="headerlink" title="方法2 CMake工具"></a>方法2 CMake工具</h2><p>利用Cmake文件将包含路径写进去。</p>
<p><em>cmake也可以在vscode中利用cmake tool工具读入，自动包含路径，而无需再对vscode进行配置</em></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#寻找库Eigen</span></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="comment">#把库包含进去</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;EIGEN3_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="comment">#因为只有头文件，因此不需要target_link_libraries</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="矩阵和向量"><a href="#矩阵和向量" class="headerlink" title="矩阵和向量"></a>矩阵和向量</h1><h2 id="初始定义"><a href="#初始定义" class="headerlink" title="初始定义"></a>初始定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//started</span></span><br><span class="line">    <span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">1</span>) = m(<span class="number">1</span>,<span class="number">0</span>) + m(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//动态大小的矩阵</span></span><br><span class="line">    MatrixXd M1 = MatrixXd::Random(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    M1 = (M1 + MatrixXd::Constant(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1.2</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;M1= &quot;</span>&lt;&lt;M1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    v &lt;&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;v*M1 = &quot;</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;M1*v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//固定的矩阵</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">v2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    Matrix3d M2 = Matrix3d::Random();</span><br><span class="line">    M2 = M2 + Matrix3d::Constant(<span class="number">1.2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;M2*v2= &quot;</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;M2*v2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Matrix3d M3;</span><br><span class="line">    <span class="comment">//逗号初始化</span></span><br><span class="line">    M3 &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">        	<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,</span><br><span class="line">    		<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>;		</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵变换</span></span><br><span class="line">    MatrixXcf a = MatrixXcf::Random(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//定义2-by-2随机矩阵</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here is the matrix a\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//矩阵a</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here is the matrix a^T\n&quot;</span> &lt;&lt; a.transpose() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//a的转置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here is the matrix a^H\n&quot;</span> &lt;&lt; a.conjugate() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//a的共轭</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here is the matrix a^&#123;-1&#125;\n&quot;</span> &lt;&lt; a.inverse() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//a的逆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向量乘法</span></span><br><span class="line">    <span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">w</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dot product: &quot;</span> &lt;&lt; v.dot(w) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//向量点乘</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cross product:\n&quot;</span> &lt;&lt; v.cross(w) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//向量叉乘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><p><code>.colwise()</code>返回每一列的值.</p>
<p><code>.rowwise()</code> 返回每一行的值</p>
<h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><p><code>.col(),.row(),.size()</code>：获取列数行数和元素个数</p>
<p><code>.data()</code>: 返回矩阵首地址的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MatrixXd::Zeros(n,m);</span><br><span class="line">MatrixXd::Ones(n,m);</span><br><span class="line">MatrixXd::Identity(n,m);</span><br><span class="line">MatrixXd::LineSpaced(size,low,high)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Eigen</tag>
      </tags>
  </entry>
  <entry>
    <title>Eigen学习笔记(三)——Matlab对比</title>
    <url>/2020/10/27/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Eigen%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/</url>
    <content><![CDATA[<p>转载自: <a href="https://blog.csdn.net/xuezhisdc/article/details/54645238">https://blog.csdn.net/xuezhisdc/article/details/54645238</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考 - http://eigen.tuxfamily.org/dox/AsciiQuickReference.txt</span></span><br><span class="line"><span class="comment">// 一个关于Eigen的快速参考</span></span><br><span class="line"><span class="comment">// Matlab和Eigen的对应用法</span></span><br><span class="line"><span class="comment">// Main author: Keir Mierle</span></span><br><span class="line"><span class="comment">// 注释：张学志</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; A;               <span class="comment">// 固定大小的双精度矩阵，和Matrix3d一样。</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, Dynamic&gt; B;         <span class="comment">// 固定行数，列数为动态大小</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, Dynamic, Dynamic&gt; C;   <span class="comment">// 行数和列数都是动态大小，和MatrixXd一样。</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>, RowMajor&gt; E;     <span class="comment">// 行优先的矩阵（默认是列优先）</span></span><br><span class="line">Matrix3f P, Q, R;                     <span class="comment">// 3x3 的浮点型矩阵</span></span><br><span class="line">Vector3f x, y, z;                     <span class="comment">// 3x1 的浮点型矩阵（列向量）</span></span><br><span class="line">RowVector3f a, b, c;                  <span class="comment">// 1x3 的浮点型矩阵（行向量）</span></span><br><span class="line">VectorXd v;                           <span class="comment">// 动态大小的双精度列向量</span></span><br><span class="line"><span class="keyword">double</span> s;                            </span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="comment">// Eigen          // Matlab           // 注释</span></span><br><span class="line">x.size()          <span class="comment">// length(x)        // 向量的长度</span></span><br><span class="line">C.rows()          <span class="comment">// size(C,1)        // 矩阵的行数</span></span><br><span class="line">C.cols()          <span class="comment">// size(C,2)        // 矩阵的列数</span></span><br><span class="line">x(i)              <span class="comment">// x(i+1)           // 访问向量元素（Matlab的下标从1开始计数）</span></span><br><span class="line">C(i,j)            <span class="comment">// C(i+1,j+1)       // 访问矩阵元素</span></span><br><span class="line"></span><br><span class="line">A.resize(<span class="number">4</span>, <span class="number">4</span>);   <span class="comment">// 如果开启了断言，将会出现运行时错误。</span></span><br><span class="line">B.resize(<span class="number">4</span>, <span class="number">9</span>);   <span class="comment">// 如果开启了断言，将会出现运行时错误。</span></span><br><span class="line">A.resize(<span class="number">3</span>, <span class="number">3</span>);   <span class="comment">// 运行正常，矩阵的大小没有变化及。（A的行数和列数都是固定大小的）</span></span><br><span class="line">B.resize(<span class="number">3</span>, <span class="number">9</span>);   <span class="comment">// 运行正常，仅动态列数发生了变化。（B的列数是动态变化的）</span></span><br><span class="line">                  </span><br><span class="line">A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,     <span class="comment">// 初始化A。元素也可以是矩阵，先按列堆叠，再按行堆叠。</span></span><br><span class="line">     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,     </span><br><span class="line">     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;     </span><br><span class="line">B &lt;&lt; A, A, A;     <span class="comment">// B 是3个A水平排列</span></span><br><span class="line">A.fill(<span class="number">10</span>);       <span class="comment">// 将A的所有元素填充为10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen                                    // Matlab                       注释</span></span><br><span class="line">MatrixXd::Identity(rows,cols)               <span class="comment">// eye(rows,cols)               //单位矩阵</span></span><br><span class="line">C.setIdentity(rows,cols)                    <span class="comment">// C = eye(rows,cols)           //单位矩阵</span></span><br><span class="line">MatrixXd::Zero(rows,cols)                   <span class="comment">// zeros(rows,cols)             //全零矩阵</span></span><br><span class="line">C.setZero(rows,cols)                        <span class="comment">// C = zeros(rows,cols)         //全零矩阵</span></span><br><span class="line">MatrixXd::Ones(rows,cols)                   <span class="comment">// ones(rows,cols)              //全一矩阵</span></span><br><span class="line">C.setOnes(rows,cols)                        <span class="comment">// C = ones(rows,cols)          //全一矩阵</span></span><br><span class="line">MatrixXd::Random(rows,cols)                 <span class="comment">// rand(rows,cols)*2-1          //MatrixXd::Random 返回范围为(-1, 1)的均匀分布的随机数</span></span><br><span class="line">C.setRandom(rows,cols)                      <span class="comment">// C = rand(rows,cols)*2-1      //返回范围为(-1, 1)的均匀分布的随机数</span></span><br><span class="line">VectorXd::LinSpaced(size,low,high)          <span class="comment">// linspace(low,high,size)&#x27;     //返回size个等差数列，第一个数为low，最后一个数为high</span></span><br><span class="line">v.setLinSpaced(size,low,high)               <span class="comment">// v = linspace(low,high,size)&#x27; //返回size个等差数列，第一个数为low，最后一个数为high</span></span><br><span class="line">VectorXi::LinSpaced(((hi-low)/step)+<span class="number">1</span>,      <span class="comment">// low:step:hi                  //以step为步长的等差数列。((hi-low)/step)+1为个数</span></span><br><span class="line">                    low,low+step*(size<span class="number">-1</span>))  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Matrix 切片和块。下面列出的所有表达式都是可读/写的。</span></span><br><span class="line"><span class="comment">// 使用模板参数更快（如第2个）。注意：Matlab是的下标是从1开始的。</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab                        // 注释</span></span><br><span class="line">x.head(n)                          <span class="comment">// x(1:n)                        //前n个元素</span></span><br><span class="line">x.head&lt;n&gt;()                        <span class="comment">// x(1:n)                        //前n个元素</span></span><br><span class="line">x.tail(n)                          <span class="comment">// x(end - n + 1: end)           //倒数n个元素</span></span><br><span class="line">x.tail&lt;n&gt;()                        <span class="comment">// x(end - n + 1: end)           //倒数n个元素</span></span><br><span class="line">x.segment(i, n)                    <span class="comment">// x(i+1 : i+n)                  //切片</span></span><br><span class="line">x.segment&lt;n&gt;(i)                    <span class="comment">// x(i+1 : i+n)                  //切片</span></span><br><span class="line">P.block(i, j, rows, cols)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols) //块</span></span><br><span class="line">P.block&lt;rows, cols&gt;(i, j)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols) //块</span></span><br><span class="line">P.row(i)                           <span class="comment">// P(i+1, :)                     //第i行</span></span><br><span class="line">P.col(j)                           <span class="comment">// P(:, j+1)                     //第j列</span></span><br><span class="line">P.leftCols&lt;cols&gt;()                 <span class="comment">// P(:, 1:cols)                  //前cols列</span></span><br><span class="line">P.leftCols(cols)                   <span class="comment">// P(:, 1:cols)                  //前cols列</span></span><br><span class="line">P.middleCols&lt;cols&gt;(j)              <span class="comment">// P(:, j+1:j+cols)              //中间cols列</span></span><br><span class="line">P.middleCols(j, cols)              <span class="comment">// P(:, j+1:j+cols)              //中间cols列</span></span><br><span class="line">P.rightCols&lt;cols&gt;()                <span class="comment">// P(:, end-cols+1:end)          //后cols列</span></span><br><span class="line">P.rightCols(cols)                  <span class="comment">// P(:, end-cols+1:end)          //后cols列</span></span><br><span class="line">P.topRows&lt;rows&gt;()                  <span class="comment">// P(1:rows, :)                  //前rows行</span></span><br><span class="line">P.topRows(rows)                    <span class="comment">// P(1:rows, :)                  //前rows行</span></span><br><span class="line">P.middleRows&lt;rows&gt;(i)              <span class="comment">// P(i+1:i+rows, :)              //中间rows行</span></span><br><span class="line">P.middleRows(i, rows)              <span class="comment">// P(i+1:i+rows, :)              //中间rows行</span></span><br><span class="line">P.bottomRows&lt;rows&gt;()               <span class="comment">// P(end-rows+1:end, :)          //最后rows行</span></span><br><span class="line">P.bottomRows(rows)                 <span class="comment">// P(end-rows+1:end, :)          //最后rows行</span></span><br><span class="line">P.topLeftCorner(rows, cols)        <span class="comment">// P(1:rows, 1:cols)             //左上角块</span></span><br><span class="line">P.topRightCorner(rows, cols)       <span class="comment">// P(1:rows, end-cols+1:end)     //右上角块</span></span><br><span class="line">P.bottomLeftCorner(rows, cols)     <span class="comment">// P(end-rows+1:end, 1:cols)     //左下角块</span></span><br><span class="line">P.bottomRightCorner(rows, cols)    <span class="comment">// P(end-rows+1:end, end-cols+1:end) //右下角块</span></span><br><span class="line">P.topLeftCorner&lt;rows,cols&gt;()       <span class="comment">// P(1:rows, 1:cols)                 //左上角块</span></span><br><span class="line">P.topRightCorner&lt;rows,cols&gt;()      <span class="comment">// P(1:rows, end-cols+1:end)         //右上角块</span></span><br><span class="line">P.bottomLeftCorner&lt;rows,cols&gt;()    <span class="comment">// P(end-rows+1:end, 1:cols)         //左下角块</span></span><br><span class="line">P.bottomRightCorner&lt;rows,cols&gt;()   <span class="comment">// P(end-rows+1:end, end-cols+1:end) //右下角块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别说明：Eigen的交换函数进行了高度优化</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.row(i) = P.col(j);               <span class="comment">// R(i, :) = P(:, j)</span></span><br><span class="line">R.col(j1).swap(mat1.col(j2));      <span class="comment">// R(:, [j1 j2]) = R(:, [j2, j1]) //交换列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Views, transpose, etc;</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.adjoint()                        <span class="comment">// R&#x27;                    // 共轭转置</span></span><br><span class="line">R.transpose()                      <span class="comment">// R.&#x27; or conj(R&#x27;)       // 可读/写 转置</span></span><br><span class="line">R.diagonal()                       <span class="comment">// diag(R)               // 可读/写 对角元素</span></span><br><span class="line">x.asDiagonal()                     <span class="comment">// diag(x)               // 对角矩阵化</span></span><br><span class="line">R.transpose().colwise().reverse()  <span class="comment">// rot90(R)              // 可读/写 逆时针旋转90度</span></span><br><span class="line">R.rowwise().reverse()              <span class="comment">// fliplr(R)             // 水平翻转</span></span><br><span class="line">R.colwise().reverse()              <span class="comment">// flipud(R)             // 垂直翻转</span></span><br><span class="line">R.replicate(i,j)                   <span class="comment">// repmat(P,i,j)         // 复制矩阵，垂直复制i个，水平复制j个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四则运算，和Matlab相同。但Matlab中不能使用*=这样的赋值运算符</span></span><br><span class="line"><span class="comment">// 矩阵 - 向量    矩阵 - 矩阵      矩阵 - 标量</span></span><br><span class="line">y  = M*x;          R  = P*Q;        R  = P*s;</span><br><span class="line">a  = b*M;          R  = P - Q;      R  = s*P;</span><br><span class="line">a *= M;            R  = P + Q;      R  = P/s;</span><br><span class="line">                   R *= Q;          R  = s*P;</span><br><span class="line">                   R += Q;          R *= s;</span><br><span class="line">                   R -= Q;          R /= s;</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line"><span class="comment">// 逐像素操作Vectorized operations on each element independently</span></span><br><span class="line"><span class="comment">// Eigen                       // Matlab        //注释</span></span><br><span class="line">R = P.cwiseProduct(Q);         <span class="comment">// R = P .* Q    //逐元素乘法</span></span><br><span class="line">R = P.<span class="built_in">array</span>() * s.<span class="built_in">array</span>();     <span class="comment">// R = P .* s    //逐元素乘法（s为标量）</span></span><br><span class="line">R = P.cwiseQuotient(Q);        <span class="comment">// R = P ./ Q    //逐元素除法</span></span><br><span class="line">R = P.<span class="built_in">array</span>() / Q.<span class="built_in">array</span>();     <span class="comment">// R = P ./ Q    //逐元素除法</span></span><br><span class="line">R = P.<span class="built_in">array</span>() + s.<span class="built_in">array</span>();     <span class="comment">// R = P + s     //逐元素加法（s为标量）</span></span><br><span class="line">R = P.<span class="built_in">array</span>() - s.<span class="built_in">array</span>();     <span class="comment">// R = P - s     //逐元素减法（s为标量）</span></span><br><span class="line">R.<span class="built_in">array</span>() += s;                <span class="comment">// R = R + s     //逐元素加法（s为标量）</span></span><br><span class="line">R.<span class="built_in">array</span>() -= s;                <span class="comment">// R = R - s     //逐元素减法（s为标量）</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt; Q.<span class="built_in">array</span>();         <span class="comment">// R &lt; Q         //逐元素比较运算</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt;= Q.<span class="built_in">array</span>();        <span class="comment">// R &lt;= Q        //逐元素比较运算</span></span><br><span class="line">R.cwiseInverse();              <span class="comment">// 1 ./ P        //逐元素取倒数</span></span><br><span class="line">R.<span class="built_in">array</span>().inverse();           <span class="comment">// 1 ./ P        //逐元素取倒数</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sin</span>()                <span class="comment">// sin(P)        //逐元素计算正弦函数</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">cos</span>()                <span class="comment">// cos(P)        //逐元素计算余弦函数</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">pow</span>(s)               <span class="comment">// P .^ s        //逐元素计算幂函数</span></span><br><span class="line">R.<span class="built_in">array</span>().square()             <span class="comment">// P .^ 2        //逐元素计算平方</span></span><br><span class="line">R.<span class="built_in">array</span>().cube()               <span class="comment">// P .^ 3        //逐元素计算立方</span></span><br><span class="line">R.cwiseSqrt()                  <span class="comment">// sqrt(P)       //逐元素计算平方根</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sqrt</span>()               <span class="comment">// sqrt(P)       //逐元素计算平方根</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">exp</span>()                <span class="comment">// exp(P)        //逐元素计算指数函数</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">log</span>()                <span class="comment">// log(P)        //逐元素计算对数函数</span></span><br><span class="line">R.cwiseMax(P)                  <span class="comment">// max(R, P)     //逐元素计算R和P的最大值</span></span><br><span class="line">R.<span class="built_in">array</span>().max(P.<span class="built_in">array</span>())       <span class="comment">// max(R, P)     //逐元素计算R和P的最大值</span></span><br><span class="line">R.cwiseMin(P)                  <span class="comment">// min(R, P)     //逐元素计算R和P的最小值</span></span><br><span class="line">R.<span class="built_in">array</span>().min(P.<span class="built_in">array</span>())       <span class="comment">// min(R, P)     //逐元素计算R和P的最小值</span></span><br><span class="line">R.cwiseAbs()                   <span class="comment">// abs(P)        //逐元素计算R和P的绝对值</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">abs</span>()                <span class="comment">// abs(P)        //逐元素计算绝对值</span></span><br><span class="line">R.cwiseAbs2()                  <span class="comment">// abs(P.^2)     //逐元素计算平方</span></span><br><span class="line">R.<span class="built_in">array</span>().abs2()               <span class="comment">// abs(P.^2)     //逐元素计算平方</span></span><br><span class="line">(R.<span class="built_in">array</span>() &lt; s).select(P,Q );  <span class="comment">// (R &lt; s ? P : Q)                             //根据R的元素值是否小于s，选择P和Q的对应元素</span></span><br><span class="line">R = (Q.<span class="built_in">array</span>()==<span class="number">0</span>).select(P,A) <span class="comment">// R(Q==0) = P(Q==0) R(Q!=0) = P(Q!=0)         //根据Q中元素等于零的位置选择P中元素</span></span><br><span class="line">R = P.unaryExpr(ptr_fun(func)) <span class="comment">// R = arrayfun(func, P)     // 对P中的每个元素应用func函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reductions.</span></span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="comment">// Eigen                  // Matlab                 //注释</span></span><br><span class="line">R.minCoeff()              <span class="comment">// min(R(:))              //最小值</span></span><br><span class="line">R.maxCoeff()              <span class="comment">// max(R(:))              //最大值</span></span><br><span class="line">s = R.minCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i); //计算最小值和它的位置</span></span><br><span class="line">s = R.maxCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i); //计算最大值和它的位置</span></span><br><span class="line">R.sum()                   <span class="comment">// sum(R(:))              //求和（所有元素）</span></span><br><span class="line">R.colwise().sum()         <span class="comment">// sum(R)                 //按列求和</span></span><br><span class="line">R.rowwise().sum()         <span class="comment">// sum(R, 2) or sum(R&#x27;)&#x27;  //按行求和</span></span><br><span class="line">R.prod()                  <span class="comment">// prod(R(:))                 //累积</span></span><br><span class="line">R.colwise().prod()        <span class="comment">// prod(R)                    //按列累积</span></span><br><span class="line">R.rowwise().prod()        <span class="comment">// prod(R, 2) or prod(R&#x27;)&#x27;    //按行累积</span></span><br><span class="line">R.trace()                 <span class="comment">// trace(R)                   //迹</span></span><br><span class="line">R.all()                   <span class="comment">// all(R(:))                  //是否所有元素都非零</span></span><br><span class="line">R.colwise().all()         <span class="comment">// all(R)                     //按列判断，是否该列所有元素都非零</span></span><br><span class="line">R.rowwise().all()         <span class="comment">// all(R, 2)                  //按行判断，是否该行所有元素都非零</span></span><br><span class="line">R.any()                   <span class="comment">// any(R(:))                  //是否有元素非零</span></span><br><span class="line">R.colwise().any()         <span class="comment">// any(R)                     //按列判断，是否该列有元素都非零</span></span><br><span class="line">R.rowwise().any()         <span class="comment">// any(R, 2)                  //按行判断，是否该行有元素都非零</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点积，范数等</span></span><br><span class="line"><span class="comment">// Eigen                  // Matlab           // 注释</span></span><br><span class="line">x.norm()                  <span class="comment">// norm(x).         //范数（注意：Eigen中没有norm(R)）</span></span><br><span class="line">x.squaredNorm()           <span class="comment">// dot(x, x)        //平方和（注意：对于复数而言，不等价）</span></span><br><span class="line">x.dot(y)                  <span class="comment">// dot(x, y)        //点积</span></span><br><span class="line">x.cross(y)                <span class="comment">// cross(x, y)      //交叉积，需要头文件 #include &lt;Eigen/Geometry&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 类型转换</span><br><span class="line"><span class="comment">// Eigen                  // Matlab             // 注释</span></span><br><span class="line">A.cast&lt;<span class="keyword">double</span>&gt;();         <span class="comment">// double(A)          //变成双精度类型</span></span><br><span class="line">A.cast&lt;<span class="keyword">float</span>&gt;();          <span class="comment">// single(A)          //变成单精度类型</span></span><br><span class="line">A.cast&lt;<span class="keyword">int</span>&gt;();            <span class="comment">// int32(A)           //编程整型</span></span><br><span class="line">A.real();                 <span class="comment">// real(A)            //实部</span></span><br><span class="line">A.imag();                 <span class="comment">// imag(A)            //虚部</span></span><br><span class="line"><span class="comment">// 如果变换前后的类型相同，不做任何事情。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：Eigen中，绝大多数的涉及多个操作数的运算都要求操作数具有相同的类型</span></span><br><span class="line">MatrixXf F = MatrixXf::Zero(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">A += F;                <span class="comment">// 非法。Matlab中允许。（单精度+双精度）</span></span><br><span class="line">A += F.cast&lt;<span class="keyword">double</span>&gt;(); <span class="comment">// 将F转换成double，并累加。（一般都是在使用时临时转换）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen 可以将已存储数据的缓存 映射成 Eigen矩阵</span></span><br><span class="line"><span class="keyword">float</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line">Vector3f::Map(<span class="built_in">array</span>).fill(<span class="number">10</span>);            <span class="comment">// create a temporary Map over array and sets entries to 10</span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">Matrix2i <span class="title">mat2x2</span><span class="params">(data)</span></span>;                    <span class="comment">// 将 data 复制到 mat2x2</span></span><br><span class="line">Matrix2i::Map(data) = <span class="number">2</span>*mat2x2;           <span class="comment">// 使用 2*mat2x2 覆写data的元素 </span></span><br><span class="line">MatrixXi::Map(data, <span class="number">2</span>, <span class="number">2</span>) += mat2x2;      <span class="comment">// 将 mat2x2 加到 data的元素上 (当编译时不知道大小时，可选语法)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解线性方程组 Ax = b。结果保存在x中。      Matlab: x = A \ b.</span></span><br><span class="line">x = A.ldlt().solve(b));  <span class="comment">// A sym. p.s.d.    #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.llt() .solve(b));  <span class="comment">// A sym. p.d.      #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.lu()  .solve(b));  <span class="comment">// 稳定，快速       #include &lt;Eigen/LU&gt;</span></span><br><span class="line">x = A.qr()  .solve(b));  <span class="comment">// No pivoting.     #include &lt;Eigen/QR&gt;        //Eigen 3.3.2中没有？</span></span><br><span class="line">x = A.svd() .solve(b));  <span class="comment">// 稳定，慢速       #include &lt;Eigen/SVD&gt;       //Eigen 3.3.2中没有？</span></span><br><span class="line"><span class="comment">// .ldlt() -&gt; .matrixL() and .matrixD()                         //?</span></span><br><span class="line"><span class="comment">// .llt()  -&gt; .matrixL()                                        //?</span></span><br><span class="line"><span class="comment">// .lu()   -&gt; .matrixL() and .matrixU()                         //?</span></span><br><span class="line"><span class="comment">// .qr()   -&gt; .matrixQ() and .matrixR()                         //?</span></span><br><span class="line"><span class="comment">// .svd()  -&gt; .matrixU(), .singularValues(), and .matrixV()     //?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征值问题</span></span><br><span class="line"><span class="comment">// Eigen                          // Matlab</span></span><br><span class="line">A.eigenvalues();                  <span class="comment">// eig(A);</span></span><br><span class="line"><span class="function">EigenSolver&lt;Matrix3d&gt; <span class="title">eig</span><span class="params">(A)</span></span>;     <span class="comment">// [vec val] = eig(A)</span></span><br><span class="line">eig.eigenvalues();                <span class="comment">// diag(val)          //特征值，向量形式</span></span><br><span class="line">eig.eigenvectors();               <span class="comment">// vec                //特征向量，矩阵形式</span></span><br><span class="line"><span class="comment">// 对于自伴矩阵（Hermitian矩阵或对称矩阵），使用SelfAdjointEigenSolver&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Eigen</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab小知识记录</title>
    <url>/2020/03/23/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Matlab%E5%B0%8F%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>当然详细的内容参照官网文档，这里记录一些常用的或通常误解的。</p>
<h1 id="固定步长和变步长"><a href="#固定步长和变步长" class="headerlink" title="固定步长和变步长"></a>固定步长和变步长</h1><ol>
<li>一般情况下，减小步长大小将提高结果的准确性，但会增加系统仿真所需的时间。</li>
<li>可变步长求解器会改变仿真期间的步长大小：当模型状态快速变化时，减小步长大小以提高准确性；当模型状态缓慢变化时，增加步长大小以避免执行不必要的时间步。计算步长大小会增加每个步长的计算开销，但可以减少对具有<em>快速变化的状态或分段连续状态的模型</em>维护指定级别的准确性所需的总时间步数，从而缩短仿真时间。</li>
</ol>
<h1 id="Matlab-funtction模块"><a href="#Matlab-funtction模块" class="headerlink" title="Matlab funtction模块"></a>Matlab funtction模块</h1><ol>
<li><strong>%#codegen</strong>：在function 头的下一行增加%#codegen符号，其作用是为了使静态代码分析器Code Analyzer 诊断代码并提示用户对可能在代码生成的过程中导致错误的违规写法进行修正。<br>此模块自带此功能，不用特地声明</li>
<li>内部语言因为要编译成C，因此MATLAB Function内部的M语言<strong>变量</strong>必须要给定初始值及其维度，变量类型及其虚实性，不支持变维度变量</li>
<li>对于每次调用该函数块时需要循环使用的变量，可申明为<strong>persistent</strong>变量。注意：与global不同的是其只能在函数内部被识别，申明时为空，需要初始化赋值。</li>
<li>其可以调用大部分工具箱的函数，支持的函数列表见<code>&gt;&gt;doc C/C++ 代码生成支持的函数和对象 - 按类别排列 </code>，但是Matlab Function输出不支持高级别的Class，比如pointCloud类，会报错：<blockquote>
<p>A top-level output parameter containing a class is not supported in MATLAB Function Block. Output parameter ‘pointCd’ contains a class.</p>
</blockquote>
</li>
<li><strong>Ports and Data Manager</strong>:<br>输出变量长度如果不同时刻会变化，应将其Size属性设置为Variable size，并在前面写下size的上限值。<br><img src="/2020/03/23/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Matlab%E5%B0%8F%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/1.png"></li>
<li>也不能把某个工具箱的类变量作为输出，C语言不符合</li>
<li>C默认float是single精度，而m语言默认是double类型，精度高但是占内存。可以用<code>a=single(a)</code>转换，或者Type Conversion模块转换数据格式。</li>
</ol>
<h1 id="prescan仿真问题记录"><a href="#prescan仿真问题记录" class="headerlink" title="prescan仿真问题记录"></a>prescan仿真问题记录</h1><ol>
<li>构造pointCloud函数一旦放到Matlab Function中就报错，说输入的矩阵不是M by 3的形式，但事实就是M*3。断开prescan单独拎出去就可以，真是奇了怪了？干脆不用point Cloud工具箱了，直接写聚类这些。</li>
</ol>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV学习笔记</title>
    <url>/2020/07/07/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/OpenCV/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a><strong><a href="https://opencv.org/releases/">下载</a></strong></h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong><a href="https://opencv.org/releases/">安装</a></strong></h2><p>异常记录未解决：</p>
<p>在步骤：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig  </span><br><span class="line"><span class="keyword">export</span> PKG_CONFIG_PATH  </span><br></pre></td></tr></table></figure>

<p>保存bash.bashrc时候提示不支持。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>open source computer vision library</p>
</blockquote>
<p><code>cv::Point2f = cv::Point_&lt;float&gt;;</code></p>
<h2 id="编译c-cpp"><a href="#编译c-cpp" class="headerlink" title="编译c/cpp"></a>编译c/cpp</h2><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>Opencv</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>PCL入门(一)</title>
    <url>/2019/12/17/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/PCL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>PCL在windows中配置环境十分麻烦，相反在ros中非常方便。<br><strong>学习资料</strong>:<br><a href="http://pointclouds.org/documentation/tutorials/">http://pointclouds.org/documentation/tutorials/</a></p>
<p><a href="https://blog.csdn.net/qq_42367689/article/details/104358046">工作空间配置实例</a></p>
<h2 id="PCL：点云数据格式bin转pcd"><a href="#PCL：点云数据格式bin转pcd" class="headerlink" title="PCL：点云数据格式bin转pcd"></a><a href="https://blog.csdn.net/qq_40297851/article/details/85274563#commentBox">PCL：点云数据格式bin转pcd</a></h2><p>注意cMakeList.txt中变量名和路径的统一. 在ROS中表示点云的数据结构有 pcl::PointCloud &lt; T &gt;, 而msg中常用pcl::PointCloud2. 他们之间的转换使用命令<code>pcl::fromROSMsg</code> 和 <code>pcl::toROSMsg</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PCDReader reader;</span><br><span class="line">reader.read&lt;pcl::PointXYZ&gt; (<span class="string">&quot;/home/lijie/bin2pcd_ws/src/sor_filter/src/table_scene_lms400.pcd&quot;</span>, *cloud);</span><br><span class="line">pcl::io::loadPCDFile (<span class="string">&quot;/home/lijie/catkin_ws/src/pcd_load/13.pcd&quot;</span>, cloud);</span><br></pre></td></tr></table></figure>

<h2 id="PCL：PCD文件拼接"><a href="#PCL：PCD文件拼接" class="headerlink" title="PCL：PCD文件拼接"></a><a href="https://blog.csdn.net/ethan_guo/article/details/80110023"><strong>PCL：PCD文件拼接</strong></a></h2><h2 id="PCL：下采样和地面过滤"><a href="#PCL：下采样和地面过滤" class="headerlink" title="PCL：下采样和地面过滤"></a><a href="https://blog.csdn.net/AdamShan/article/details/82901295"><strong>PCL：下采样和地面过滤</strong></a></h2><h2 id="数据集的读取和滤波处理"><a href="#数据集的读取和滤波处理" class="headerlink" title="数据集的读取和滤波处理"></a><a href="https://www.cnblogs.com/li-yao7758258/p/6651326.html">数据集的读取和滤波处理</a></h2><p><strong>Q&amp;A:</strong>  </p>
<ol>
<li>在一个package/src中建立两个*.cpp节点,分别实现数据的读取和发布、数据的预处理两个功能。<br>需要修改CMakeLists.txt文件。projectName是package的名字而不是节点名，将原本生成可执行文件命令和链接目标命令中的<code>$&#123;PROJECT_NAME&#125;_node</code>（即节点名）修改为你的节点名（建议与*.cpp一致或添加*_node）如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ## Declare a C++ executable</span><br><span class="line"> ## With catkin_make all packages are built within a single CMake context</span><br><span class="line"> ## The recommended prefix ensures that target names across packages don&#39;t collide</span><br><span class="line">add_executable(**pcd_load_node**  src&#x2F;pcd_load.cpp )</span><br><span class="line">target_link_libraries(pcd_load_node $&#123;catkin_LIBRARIES&#125; )</span><br><span class="line"></span><br><span class="line">add_executable(pcd_pub_node  src&#x2F;pcd_pub.cpp )</span><br><span class="line">target_link_libraries(pcd_pub_node $&#123;catkin_LIBRARIES&#125; )</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在建立数据读取和发布节点<strong>pcd_pub.cpp</strong>时：<br>注意点云数据格式转换：<code>pcl::toROSMsg(pcl::PointXYZI, sensor_msgs::PointCloud2)</code>, <code>pcl::formROSMsg( )</code>,他们包含于                <code>pcl_conversions/pcl_conversions.h</code>头文件中。发布到topic中时若需要在rviz中显示，这需要fix_frame命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">topic.header.frame_id&#x3D;&quot;velodyne&quot;;&#x2F;&#x2F;是后面rviz的 fixed_frame</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在建立数据预处理节点<strong>pcd_load.cpp</strong>时：<br>需要注意的依然是数据格式问题：订阅器查询时会调用回调函数（filter），将topic中的msg传递过去，所以输入是PointCloud2类型引用。因为各个滤波器的输入是指针而非点云数据，所以应该转换为指针：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);</span><br><span class="line">pcl::fromROSMsg(*cloud, *scan_ptr);</span><br></pre></td></tr></table></figure>
<p>其中<code>new pcl::PointCloud&lt;pcl::PointXYZI&gt;（scan）</code>用于初始化指针指向scan类所在地址，也可不申明指向对象。</p>
</li>
<li><p>使用直通滤波器时，要分别进行x，y，z方向的输入设置，依然为指针。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pcl::PassThrough&lt;pcl::PointXYZI&gt; pass;</span><br><span class="line">pass.setInputCloud(pcd_filtered_ptr);</span><br><span class="line">pass.setFilterFieldName(&quot;x&quot;);</span><br><span class="line">pass.setFilterLimits(-10.0,10.0);</span><br><span class="line">pass.filter(*pcd_filtered_ptr);</span><br><span class="line"></span><br><span class="line">pass.setInputCloud(pcd_filtered_ptr);</span><br><span class="line">pass.setFilterFieldName(&quot;y&quot;);</span><br><span class="line">pass.setFilterLimits(-5.0,5.0); </span><br><span class="line">pass.filter(*pcd_filtered_ptr); </span><br><span class="line">std::cerr &lt;&lt; &quot;Cloud after RoIfiltering: &quot; &lt;&lt; std::endl;</span><br><span class="line">std::cerr &lt;&lt; *pcd_filtered_ptr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="地面分割："><a href="#地面分割：" class="headerlink" title="地面分割："></a>地面分割：</h2><p>Ray Ground Filter的路面过滤方法。<br><a href="https://blog.csdn.net/HHH_go_/article/details/83148472">SAC_RANSAC分割地面</a></p>
<h2 id="PCL-cluster"><a href="#PCL-cluster" class="headerlink" title="PCL/cluster"></a>PCL/cluster</h2><p> 找问题真的很费时间，一些没遇见过的小错误就很难发现。记录一下。</p>
<h3 id="1-欧式聚类实操"><a href="#1-欧式聚类实操" class="headerlink" title="1. 欧式聚类实操"></a>1. 欧式聚类实操</h3><p> 体素网格下采样尺寸太小，数据量太大，Integer indices would overflow. 指针溢出。<br> 但若网格尺寸太大，聚类的<code>ec.setClusterTolerance (0.01)</code>公差比它小则聚类数量为0。</p>
<h3 id="2-投影到平面"><a href="#2-投影到平面" class="headerlink" title="2.投影到平面"></a>2.投影到平面</h3><p> <a href="http://pointclouds.org/documentation/tutorials/project_inliers.php#project-inliers">点击查看教程</a><br> 由于通常是投影到xy平面可以使用循环代码：cloud_cluster是点云的指针.<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; cloud_cluster-&gt;points.size(); ++i)</span><br><span class="line">     cloud_cluster-&gt;points[i].z&#x3D;0; </span><br></pre></td></tr></table></figure></p>
<h3 id="3-提取边界"><a href="#3-提取边界" class="headerlink" title="3.提取边界"></a>3.提取边界</h3><p>Q1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[pcl::BoundaryEstimation::initCompute] The number of points in the input dataset (23798) differs from the number of points in the dataset containing the normals (884)!</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 地面分割代码块</span><br><span class="line">#include&lt;ros&#x2F;ros.h&gt;</span><br><span class="line">#include&lt;pcl&#x2F;point_cloud.h&gt;</span><br><span class="line">#include&lt;pcl_conversions&#x2F;pcl_conversions.h&gt;</span><br><span class="line">#include&lt;sensor_msgs&#x2F;PointCloud2.h&gt;</span><br><span class="line">#include&lt;pcl&#x2F;io&#x2F;pcd_io.h&gt;</span><br><span class="line"></span><br><span class="line">int  main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  ros::init (argc, argv, &quot;pcd_pub_node&quot;); </span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt; cloud;</span><br><span class="line">  sensor_msgs::PointCloud2 input;</span><br><span class="line"> </span><br><span class="line">  pcl::io::loadPCDFile (&quot;&#x2F;home&#x2F;lijie&#x2F;catkin_ws&#x2F;src&#x2F;pcd_load&#x2F;13.pcd&quot;, cloud); </span><br><span class="line">  pcl::toROSMsg(cloud,input);</span><br><span class="line"></span><br><span class="line">  input.header.frame_id&#x3D;&quot;velodyne&quot;;   &#x2F;&#x2F;是后面rviz的 fixed_frame</span><br><span class="line">  ros::Publisher pcl_pub &#x3D; nh.advertise&lt;sensor_msgs::PointCloud2&gt; (&quot;pcd_input&quot;, 10);</span><br><span class="line">  </span><br><span class="line">  ros::Rate r(1);</span><br><span class="line">  while(ros::ok())</span><br><span class="line">  &#123;</span><br><span class="line">	  pcl_pub.publish(input);</span><br><span class="line">	  ros::spinOnce();</span><br><span class="line">	  r.sleep();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;ros&#x2F;ros.h&gt;</span><br><span class="line">#include&lt;pcl&#x2F;point_cloud.h&gt;</span><br><span class="line">#include&lt;pcl_conversions&#x2F;pcl_conversions.h&gt;</span><br><span class="line">#include&lt;sensor_msgs&#x2F;PointCloud2.h&gt;</span><br><span class="line">#include&lt;pcl&#x2F;io&#x2F;pcd_io.h&gt;&#x2F;&#x2F;which contains the required definitions to load and store point clouds to PCD and other file formats.</span><br><span class="line">#include&lt;pcl&#x2F;filters&#x2F;statistical_outlier_removal.h&gt;</span><br><span class="line">#include &lt;pcl&#x2F;point_types.h&gt;</span><br><span class="line">#include&lt;pcl&#x2F;filters&#x2F;voxel_grid.h&gt;</span><br><span class="line"></span><br><span class="line">ros::Publisher pcl_pub;</span><br><span class="line"></span><br><span class="line">void filter (const sensor_msgs::PointCloud2ConstPtr&amp; cloud)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; pcl::PointCloud&lt;pcl::PointXYZ&gt; scan;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);</span><br><span class="line">  pcl::fromROSMsg(*cloud, *scan_ptr);</span><br><span class="line">  std::cerr &lt;&lt; &quot;Cloud before filtering: &quot; &lt;&lt; std::endl;</span><br><span class="line">  std::cerr &lt;&lt; *scan_ptr&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  pcl::VoxelGrid&lt;pcl::PointXYZI&gt; vg;&#x2F;&#x2F;体素滤波</span><br><span class="line">  vg.setLeafSize (0.1,0.1,0.1);</span><br><span class="line">  vg.setInputCloud(scan_ptr);   &#x2F;&#x2F;输入为指针!!!!</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; pcl::PointCloud&lt;pcl::PointXYZ&gt; pcd_filtered;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcd_filtered_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);</span><br><span class="line">  vg.filter (*pcd_filtered_ptr);</span><br><span class="line">  std::cerr &lt;&lt; &quot;Cloud after filtering: &quot; &lt;&lt; std::endl;</span><br><span class="line">  std::cerr &lt;&lt; *pcd_filtered_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZI&gt; sor; &#x2F;&#x2F;Kmeans滤波,参数临近点数目和距离阈值</span><br><span class="line">  sor.setInputCloud(pcd_filtered_ptr);</span><br><span class="line">  sor.setMeanK (20);</span><br><span class="line">  sor.setStddevMulThresh(1.0);</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt; pcd_filtereded;</span><br><span class="line">  sor.filter (*pcd_filtered_ptr);</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 filter_output;</span><br><span class="line">  pcl::toROSMsg(*pcd_filtered_ptr, filter_output);</span><br><span class="line">  pcl_pub.publish (filter_output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line">  ros::init (argc, argv, &quot;pcd_fileter_node&quot;); &#x2F;&#x2F;初始化</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  ros::Subscriber sub &#x3D; nh.subscribe (&quot;pcd_input&quot;, 5, filter);</span><br><span class="line">  pcl_pub &#x3D; nh.advertise&lt;sensor_msgs::PointCloud2&gt; (&quot;pcl_fileter_output&quot;, 5);</span><br><span class="line">  </span><br><span class="line">  ros::spin();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>编程学习</category>
        <category>PCL</category>
      </categories>
      <tags>
        <tag>PCL</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab-Compiler</title>
    <url>/2020/03/20/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/matlab-Compiler/</url>
    <content><![CDATA[<p>使用simulink或者coder常常需要C++的编译器，经常因为版本等问题报错。</p>
<h1 id="matlab不同模块需要的编译器版本"><a href="#matlab不同模块需要的编译器版本" class="headerlink" title="matlab不同模块需要的编译器版本"></a>matlab不同模块需要的编译器版本</h1><p> <a href="https://ww2.mathworks.cn/support/requirements/previous-releases.html">https://ww2.mathworks.cn/support/requirements/previous-releases.html</a><br> vc2012版本真的很低了，建议MINGW</p>
<h1 id="MINGW安装配置"><a href="#MINGW安装配置" class="headerlink" title="MINGW安装配置"></a>MINGW安装配置</h1><ol>
<li><a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.3.0/">MINGW官网下载6.3版本</a></li>
<li>下载安装教程 <a href="https://tieba.baidu.com/p/5487544851?pv=1">https://tieba.baidu.com/p/5487544851?pv=1</a><br>下载好了直接解压即可</li>
<li>注意不要把路径安装在带有中文字符和空格的文件夹下，尤其是<strong>program files</strong></li>
<li>环境变量：系统变量path中添加mingw路径（这是在电脑中添加C环境）；<br> 新建系统变量：MW_MINGW64_LOC，C:\MinGW<br> <code> setenv(&#39;MW_MINGW64_LOC&#39;,&#39;C:\mingw64\bin&#39;)</code> 这个好像就是matlab命令行中添加环境变量</li>
<li>在matlab命令行中： <code>mex -setup</code> 查看编译器</li>
</ol>
<p>​    </p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>编译器</tag>
        <tag>MINGW</tag>
      </tags>
  </entry>
  <entry>
    <title>Python深度学习笔记(一)</title>
    <url>/2020/07/13/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<p>待整理:</p>
<ul>
<li>卷积层池化层</li>
<li>梯度下降</li>
<li>pytorch</li>
<li>numpy</li>
</ul>
<p>学习网站:B站莫烦python</p>
<p><code>namedtuple()</code>:是产生具有命名字段的元组的工厂函数</p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【Eigen】变换矩阵</title>
    <url>/2020/10/28/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E3%80%90Eigen%E3%80%91%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>库函数主要学习链接: <a href="http://zhaoxuhui.top/blog/2019/08/21/eigen-note-4.html">http://zhaoxuhui.top/blog/2019/08/21/eigen-note-4.html</a></p>
<p>官方:<a href="https://eigen.tuxfamily.org/dox/classEigen_1_1Transform.html">https://eigen.tuxfamily.org/dox/classEigen_1_1Transform.html</a></p>
<p>理论学习 古月居：<a href="https://www.guyuehome.com/4463">https://www.guyuehome.com/4463</a> 比较清晰</p>
<h1 id="旋转平移"><a href="#旋转平移" class="headerlink" title="旋转平移"></a>旋转平移</h1><p><a href="http://zhaoxuhui.top/blog/2019/09/03/eigen-note-4.html#23d%E6%97%8B%E8%BD%AC">学习blog链接</a></p>
<p><code>#include &lt;Eigen/Gometry&gt;</code></p>
<h2 id="2D旋转"><a href="#2D旋转" class="headerlink" title="2D旋转"></a>2D旋转</h2><p><strong>Rotation2D</strong>类, 构造参数可以输入</p>
<ul>
<li>旋转角度, <em>注意：顺时针为正,逆时针为负值.</em></li>
<li>2*2旋转矩阵, </li>
<li>另一个Rotation2D类.  </li>
</ul>
<p>成员函数:</p>
<ul>
<li><code>.cast()</code>, 可以将Rotation2Df对象与Rotation2Dd对象类型相互转换</li>
<li><code>.angle()</code>, 返回旋转角</li>
<li><code>.matrix()</code>, 返回旋转矩阵</li>
<li><code>.toRotationMatrix()</code>, 将当前Rotation2D对象转变为2*2矩阵</li>
<li><code>.fromRotationMatrix()</code>, 输入矩阵, 构建Rotation2D对象.</li>
<li><code>.inverse()</code>, 相反方向旋转</li>
</ul>
<h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p><strong>Translation</strong>类，可调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Translation&lt;<span class="keyword">float</span>,<span class="number">2</span>&gt;(tx, ty);</span><br><span class="line"><span class="function">Trasnlation2f <span class="title">t</span><span class="params">(<span class="number">1.0</span>,<span class="number">2.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.x()</code>: 获取平移的x分量</li>
<li><code>.vector()  &amp;  .translation()</code>: 获取平移向量，可用[]索引</li>
<li><code>.inverse()</code>: 逆方向平移</li>
</ul>
<h2 id="3D-旋转"><a href="#3D-旋转" class="headerlink" title="3D 旋转"></a>3D 旋转</h2><h3 id="角轴"><a href="#角轴" class="headerlink" title="角轴"></a>角轴</h3><p><strong>AngleAxis</strong>类，可调用AngleAxisf</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AngleAxisd <span class="title">theta</span><span class="params">(<span class="number">45</span>/<span class="number">180</span>*M_PI, Vector3d::UnitZ())</span></span>;</span><br><span class="line"><span class="comment">// 第一个输入角度，第二个输入参数进行归一化</span></span><br></pre></td></tr></table></figure>





<h1 id="Transform变换"><a href="#Transform变换" class="headerlink" title="Transform变换"></a>Transform变换</h1><p>空间变换的详细概念参见文章开始的链接学习比较清晰。<a href="http://zhaoxuhui.top/blog/2019/09/03/eigen-note-4.html#1%E7%AD%89%E8%B7%9D%E5%8F%98%E6%8D%A2">secret Land</a></p>
<p>常见的包括等距变换(Isometry)、仿射变换(Affine)、射影变换(Prospective)等Eigen已经预定义好了相关类，下面进行介绍。其中欧式变换又称等距变换，刚体变换，它不会改变变换对象的自身属性。</p>
<blockquote>
<p>等距变换(Isometry Transform)可以看作是维持任意两点距离不变的仿射变换，也称做欧氏变换、刚体运动，在实际场景中使用比较多。</p>
</blockquote>
<p>因此我们俯视图中的坐标系变换可以考虑使用isometry</p>
<h2 id="Isometry"><a href="#Isometry" class="headerlink" title="Isometry"></a>Isometry</h2><p>在Eigen中已经内置好了一些常用的等距变换可以直接调用，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** \ingroup Geometry_Module */</span></span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">float</span>,<span class="number">2</span>,Isometry&gt; Isometry2f;</span><br><span class="line"><span class="comment">/** \ingroup Geometry_Module */</span></span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">float</span>,<span class="number">3</span>,Isometry&gt; Isometry3f;</span><br><span class="line"><span class="comment">/** \ingroup Geometry_Module */</span></span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">double</span>,<span class="number">2</span>,Isometry&gt; Isometry2d;</span><br><span class="line"><span class="comment">/** \ingroup Geometry_Module */</span></span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">double</span>,<span class="number">3</span>,Isometry&gt; Isometry3d;</span><br></pre></td></tr></table></figure>

<p>构造方法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector2f <span class="title">tr</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">   Isometry2f T = Isometry2f::Identity();</span><br><span class="line">   T.translate(tr);</span><br><span class="line">   T.rotate(<span class="number">1.2</span>*<span class="number">3.1415926</span>/<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;T.matrix\n&quot;</span>&lt;&lt;T.matrix()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;T.rotation\n&quot;</span>&lt;&lt;T.rotation()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;T.translate:\n&quot;</span>&lt;&lt;T.translation()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   Vector3f state_X = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;result:\n &quot;</span>&lt;&lt;T.matrix()*state_X&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>该库函数2D平移旋转的思路是：</p>
<img src="/2020/10/28/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E3%80%90Eigen%E3%80%91%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/image-20201113143644546.png" alt="image-20201113143644546" style="zoom:67%;">

<p>该代码中，我们现在要将O’坐标系变换到新的坐标系O（即点不动，求取P点在新坐标系下的坐标）：先将O’平移到O，再旋转O’坐标轴与O重合。</p>
<p>*<em>平移向量<code>tr</code>**的取值是在</em>世界坐标系下*平移的量，正负号与世界坐标系一致，即向负半轴移动平移量为正。（原因，我改变旋转的角度rotate后，不改变tr值，输出结果不变，所以可以看出平移量并不是O在O’下的坐标），并不是通常的坐标变换过程中待求坐标系O原点在O‘坐标系下的坐标的负方向。因此我们没有定义世界坐标系时并不能使用。</p>
<p><strong>旋转向量</strong>，坐标轴顺时针转为正。<em>区别于坐标点的转移符号，坐标系的顺时针旋转即相当于点的逆时针旋转，所以这里顺时针旋转为负</em></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Eigen</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习视觉算法杂碎</title>
    <url>/2020/07/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9D%82%E7%A2%8E/</url>
    <content><![CDATA[<h1 id="准确率，召回率"><a href="#准确率，召回率" class="headerlink" title="准确率，召回率"></a>准确率，召回率</h1><img src="/2020/07/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9D%82%E7%A2%8E/image-20200711205519057.png" alt="price" style="zoom:200%;">

<p>1为正类，0为负类。</p>
<p>TP为true positive；FN为false negative.</p>
<ul>
<li>准确率(Accuracy)：预测正确的样本/总样本，（TP+TN）/all</li>
<li>精确率(precision)：实际为正类样本中，预测正确的比例，TP /（TP+FN）</li>
<li>召回率(Recall)：预测为正类样本中，实际正确的比例，TP /（TP+FP）</li>
</ul>
<h1 id="回归和分类"><a href="#回归和分类" class="headerlink" title="回归和分类"></a>回归和分类</h1><p>回归：对数值型连续随机变量的进行预测并建模的监督学习方法，例如股价走势，成绩变化。</p>
<p>分类：对离散型随机变量进行分析建模预测的监督学习方法，如图像识别，邮件过滤。</p>
<h1 id="什么是卷积层，池化层"><a href="#什么是卷积层，池化层" class="headerlink" title="什么是卷积层，池化层"></a>什么是卷积层，池化层</h1><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>数学上卷积的定义：</p>
<img src="/2020/07/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9D%82%E7%A2%8E/v2-d3df01f12b869d431c65f97ad307508f_r.jpg" alt="preview" style="zoom:67%;">

<p>具体的案例可以思考，两颗骰子的点数和为4的概率？而在图像识别领域，称图像内核filter与图像的滑动运算为“卷积”，在于二者运算时下标和为1，与卷积公式一致：</p>
<pre><code>                                         ![img](深度学习杂碎/img.png)</code></pre>
<p>传统的图像处理是对单个像素处理，失去了事物的连续性特征。而采用卷积的操作，对一片多个像素同时处理。这样更能理解卷积。</p>
<p><strong>卷积层</strong>：这一层指代上述的用filter与图像滑动运算的操作，以获取不同filter运算得到的不同特征图输入网络学习。</p>
<img src="/2020/07/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9D%82%E7%A2%8E/v2-c07b0cd8ff717304cf5aff547e7b8c8c_b.webp" style="zoom:67%;">



<h2 id="图像内核，filter"><a href="#图像内核，filter" class="headerlink" title="图像内核，filter"></a>图像内核，filter</h2><p>有趣的互动链接：<a href="https://setosa.io/ev/image-kernels/">https://setosa.io/ev/image-kernels/</a></p>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>上诉的卷积操作都是线性运算，不足以模拟非线性的过程，因此对每个神经元进行激活函数的操作，使得更加复杂。</p>
<p>常见的激活函数：</p>
<ul>
<li>tanh,sigmoid函数f(x) = 1/(1+exp(x))</li>
<li>ReLU函数使用更广泛：f(x)=max{0,x}</li>
</ul>
<h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><img src="/2020/07/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9D%82%E7%A2%8E/20170416212122301" alt="这里写图片描述" style="zoom:60%;">

<p>简单理解一下就是对特征图进行压缩降低维度的操作。其滑动的步长和窗口的尺寸一样，因此不会重叠，与卷积有差别。主要目的是将特征突出，将非特征变得更暗淡。</p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>trips</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Github学习笔记</title>
    <url>/2020/06/15/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Github%E7%9B%B8%E5%85%B3/Github%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="github操作指令"><a href="#github操作指令" class="headerlink" title="github操作指令"></a>github操作指令</h1><p><a href="https://www.runoob.com/manual/git-guide/">简明教程</a></p>
<p><a href="https://git-scm.com/docs">完整教程</a></p>
<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<h1 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h1><ol>
<li>工作区: 当前电脑下的工作目录空间</li>
<li>index区: .git文件夹中,保存所有改动目录文件的索引</li>
<li>HEAD: 本地master，保存最新提交（commit）的版本。</li>
<li>oringin/仓库：远端服务器存储的工作空间<br> <img src="/2020/06/15/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Github%E7%9B%B8%E5%85%B3/Github%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="1"></li>
</ol>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="创建仓"><a href="#创建仓" class="headerlink" title="创建仓"></a>创建仓</h2><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init  <span class="comment">#初始化本地仓库</span></span></span><br></pre></td></tr></table></figure>

<h2 id="提交改动"><a href="#提交改动" class="headerlink" title="提交改动"></a>提交改动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add. #add all files of workspace工作区添加到index暂存区目录</span><br><span class="line">git commit -m &quot;add files&quot; #将暂存区的索引最新版本提交commit到本地的HEAD master，并记录此次commit消息的名称为“add files”</span><br><span class="line">git push #将本地master的最新文档push到Github远端的master上保存实现同步</span><br><span class="line">git status</span><br><span class="line">git log --oneline #查看历史记录简洁信息</span><br><span class="line">git commit -am &quot;修改...&quot; #跳过git add步骤</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><img src="/2020/06/15/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Github%E7%9B%B8%E5%85%B3/Github%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201005163204478.png" alt="image-20201005163204478" style="zoom: 50%;">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch newbranchname</span><br><span class="line">git branch #查看分支</span><br><span class="line">git checkout branchname #切换到分支</span><br><span class="line">git checkout -b newbranchname #新建分支并切换过去</span><br><span class="line">git merge branchname #合并分支到master</span><br><span class="line">git branch -d (name) #删除分支</span><br><span class="line">git push origin &lt;newbranchname&gt; #push到远端服务器，否则远端看不见</span><br></pre></td></tr></table></figure>

<h3 id="克隆分支实例"><a href="#克隆分支实例" class="headerlink" title="克隆分支实例"></a>克隆分支实例</h3><p>远程仓库中分支post保存了所有我的文章, 我需要克隆该分支到本地.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone url_of_github_rep</span><br><span class="line">git init</span><br><span class="line">git branch -a #显示所有本地和远程的分支</span><br><span class="line">git checkout -b my_blog origin/post #将远程分支origin/post关联到本地新建的分支my_blog</span><br></pre></td></tr></table></figure>

<h3 id="新建本地和远程分支实例"><a href="#新建本地和远程分支实例" class="headerlink" title="新建本地和远程分支实例"></a>新建本地和远程分支实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b my_branch #新建本地分支</span><br><span class="line">git push origin my_branch #将本地分支推送到远程</span><br><span class="line">git branch --set-upstream-to = origin/my_branch #将本地分支与远程分支关联起来</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure>



<h2 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h2> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull #获取(fetch)远端相联系的分支的最新改动,并合并(merge)到本地工作目录</span><br><span class="line">git merge &lt;branchName&gt; #合并远端分支到当前分支,会产生冲突,必须自己修改</span><br><span class="line">git add &lt;filename&gt; #改完之后提交,表示合并成功</span><br></pre></td></tr></table></figure>

<h2 id="Github问题"><a href="#Github问题" class="headerlink" title="Github问题"></a>Github问题</h2><p>有两种连接远程仓库的模式,一个是Http,每次修改都要输入帐号密码<a href="http://github.com;一个是ssh,将本地计算机的锁和钥匙添加到账户里面就不用每次输入了/">http://github.com；一个是SSH,将本地计算机的锁和钥匙添加到账户里面就不用每次输入了</a>.<br>但是在clone仓库的时候就要选择相应的方式<a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#111;&#109;</a>:xiaozhenc/rep<br><a href="https://www.jianshu.com/p/c9aa544a11d3">https://www.jianshu.com/p/c9aa544a11d3</a><br>为了避免每次push都输密码,可以生成SSH钥匙和锁<br>ssh-keygen -t rsa -C “<a href="mailto:&#101;&#109;&#x61;&#105;&#x6c;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#101;&#109;&#x61;&#105;&#x6c;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a>“</p>
<h3 id="git-clone慢"><a href="#git-clone慢" class="headerlink" title="git clone慢"></a>git clone慢</h3><p><code> env | grep -i proxcy</code></p>
]]></content>
      <categories>
        <category>工具技能</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS入门</title>
    <url>/2019/12/17/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/ROS%E7%9B%B8%E5%85%B3/ROS%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>官方学习文档：<a href="http://wiki.ros.org/">http://wiki.ros.org/</a></p>
<p>很好的学习视频：<a href="https://www.bilibili.com/video/BV1zt411G7Vn?t=104&amp;p=21">https://www.bilibili.com/video/BV1zt411G7Vn?t=104&amp;p=21</a></p>
<p>很好的学习论坛古月居：<a href="https://www.guyuehome.com/">https://www.guyuehome.com/</a></p>
<h2 id="ROS准备"><a href="#ROS准备" class="headerlink" title="ROS准备"></a>ROS准备</h2><p><a href="http://wiki.ros.org/kinetic/Installation/Ubuntu">安装ROS</a><br><a href="https://www.cnblogs.com/huangjianxin/p/6347416.html">建立ROS工作空间</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src</span><br><span class="line">cd ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace    <span class="comment">//初始化生成cmake文件</span></span><br><span class="line">cd ~/catkin_ws</span><br><span class="line">catkin_make              <span class="comment">// 编译生成可执行文件</span></span><br><span class="line">source devel/setup.barsh <span class="comment">// 刷新环境变量</span></span><br></pre></td></tr></table></figure>

<p><strong>后面进行package创建时，当加入了新的package编译完成后，也要进行source刷新环境变量，否则会出现找不到“package XXX not found” 的问题</strong><br>用下面指令将其写入文件中，避免每次打开终端都需要刷新工作环境：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;source my_ws/devel/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>可以查看系统包含的package路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">echo $ROS_PACKAGE_PATH</span><br></pre></td></tr></table></figure>

<h2 id="ROS概念"><a href="#ROS概念" class="headerlink" title="ROS概念"></a>ROS概念</h2><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a><strong>参考资料</strong>:</h4><p> <a href="https://blog.csdn.net/AdamShan/article/details/79653378">https://blog.csdn.net/AdamShan/article/details/79653378</a>  </p>
<blockquote>
<p>建议将 ROS 接口节点（订阅，发布）和算法结点分开。<br>  <a href="https://www.bilibili.com/video/av24585414/?p=5">MOOC ROS入门视频：</a></p>
</blockquote>
<h4 id="ROS目录结构"><a href="#ROS目录结构" class="headerlink" title="ROS目录结构"></a>ROS目录结构</h4><p>  node, master, topic, subscribe, publisher,msg<br> <img src="https://img-blog.csdnimg.cn/20190424195935783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_5,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc5NDczMw==,size_5,color_FFFFFF,t_20" alt="ROS工程结构" style="zoom:50%;"></p>
<blockquote>
<p>ROS的软件使用package（包）进行组织，包下通常包含一下内容：<br><code>/src</code>: 源代码<br><code>/msg</code>: 定义一些message<br><code>/srv</code>: 定义一些service<br><code>/launch</code>：包含用于启动节点的launch file<br><code>/config</code>：包含配置文件<br><code>/test</code>: Unit/ROS tests<br><code>/include/package_name</code>: C++ include头文件<br><code>/doc</code>：包含文档文件<br><code>package.xml</code>: package 信息<br><code>CMakeLists.txt</code>: CMake构建文件</p>
</blockquote>
<h2 id="ROS项目操作"><a href="#ROS项目操作" class="headerlink" title="ROS项目操作"></a>ROS项目操作</h2><h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><p> roslaunch 启动master和多个node程序<br> <code>roslaunch [pkg_name] [file_name.launch]</code></p>
<p>rostopic<br><code>rostopic list</code> 列出当前所有topic<br> <code>rostopic info / topic_name</code> 显示某个topic属性<br> <code>rostopic echo / topic_name</code>显示某个topic内容<br> <code>rostopic pub /topic_name ...</code> 向某个topic发布内容</p>
<p>rosmsg<br><code>rosmsg list</code>列出系统上所有消息msg<br><code>rosmsg show /msg_name</code> 显示某个消息msg内容</p>
<p><code>rostopic echo [topic]</code> 打印topic详细信息<br><code>rqt_gragh</code> 查看节点图</p>
<h2 id="编译实例"><a href="#编译实例" class="headerlink" title="编译实例"></a><strong>编译实例</strong></h2><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a><a href="https://blog.csdn.net/AdamShan/article/details/79882668">Hello world</a></h3><p><strong>流程：</strong></p>
<p>创建工作空间 <code>mkdir catkin_ws/src/</code><br>创建 <code>catkin_create_pkg package_name depend1 depend2 depend3(pcl_ros roscpp sensor_msgs)</code><br>创建节点node  <code>*.cpp</code><br>修改<strong>CMakeList</strong> 和 <strong>package.xml</strong><br>编译 <code>catkin_make</code>, <code>source /devel/setup.bash</code><br>终端命令:<code>roscore</code>; <code>rosrun package node</code>; <code>rosrun rviz rviz;</code><br>其他常用命令:<code>rosnode list</code>; <code>rostopic list</code>; <code>roscd</code></p>
<p><strong>代码</strong>:<br> <code>ros::Rate</code>循环刷新频率10HZ<br> <code>ros::ok()</code>节点运行结束这返回false<br> <code>ros::spin(); ros::spinOnce()</code>不断查询订阅的话题，执行回调函数<br> <code>Logging</code> 不推荐使用std::cout</p>
<h2 id="CmakeList"><a href="#CmakeList" class="headerlink" title="CmakeList"></a>CmakeList</h2><p> <a href="https://blog.csdn.net/AdamShan/article/details/82901295"><strong>ROS：依赖文件和环境</strong></a><br> <a href="https://www.cnblogs.com/Jessica-jie/p/6520481.html"><strong>CMakeList详细解读</strong></a><br> 视频讲解的更加基础。<br> CMakeLists.txt文件是CMake构建系统的输入，在这里我们不会详细讨论CMake的写法（因为它本身可以很复杂），我们大致熟悉一下我们常用的CMake的语法：</p>
<p><code>cmake_minimum_required：</code>需要的CMake的最低版本<br><code>project():</code>包的名称<br><code>find_package()</code> 查找建构是需要的其他 CMake/Catkin 包<br><code>add_message_files() add_service_files() add_action_files</code> 生成Message/Service/Action<br><code>generate_messages()</code> 调用消息生成<br><code>catkin_package()</code> 指定包的构建信息<br><code>add_library()/add_executable()/target_link_libraries()</code> 用于构建的库，可执行代码</p>
<p>同样的，在<code>CMakeList</code>中，我们通过<code>find_package</code>查找这三个包的路径，然后将三个包添加到 <code>CATKIN_DEPENDS</code>, 在使用pcl库前，需要将PCL库的路径链接，通过<code>link_directories( $ &#123;PCL_LIBRARY_DIRS&#125;)</code>来完成，并在最后的<code>target_link_libraries</code>中添加<code>$&#123;PCL_LIBRARIES&#125;</code>。</p>
<p> <code>package.xml</code>的内容很简单，实际上就是这个包的描述文件， <code>build_depend</code> 和 <code>run_depend</code> 两个描述符分别指定了程序包编译和运行的依赖项，通常是所用到的库文件的名称。 在这里我们指定了三个编译和运行时依赖项，分别是<code>roscpp</code>（编写C++ ROS节点），<code>sensor_msgs</code>（定义了激光雷达的msg），<code>pcl_ros</code>（连接ROS和pcl库）。</p>
]]></content>
      <categories>
        <category>工具技能</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习笔记</title>
    <url>/2020/10/05/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/ROS%E7%9B%B8%E5%85%B3/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h1><p>可以启动多个节点, 并传入节点需要的参数变量等. 同时也不需要先启动roscore了. </p>
<h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span> = <span class="string">&quot;lidar_perception&quot;</span> <span class="attr">type</span> = <span class="string">&quot;slot_detection&quot;</span> <span class="attr">name</span> = <span class="string">&quot;detecting slots&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> = <span class="string">&quot;slot_width&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.7&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;thershold_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;lidar_perception&quot;</span> <span class="attr">type</span>=<span class="string">&quot;slot_detection&quot;</span> <span class="attr">arg</span>=<span class="string">&quot;$&#123;arg threshold_length&#125;&quot;</span> <span class="attr">name</span> &quot;<span class="attr">detection</span> <span class="attr">slots</span>&quot; /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>标签node</strong>表示运行包pkg, 中的可执行cpp文件type (若使用py脚本需要添加.py后缀), 然后将这个节点的ROS名字取为name. 还可以添加需要传入的变量参数,用arg传入. </p>
<p><strong>标签param</strong>表示定义一些参数名及其值. <strong>rosparam</strong>可以传入参数文件中所有参数.</p>
<p><strong>标签arg</strong>定义launch内部使用的变量参数,可供其他使用.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;slot_detection/thresh_l&quot;</span> <span class="attr">to</span>=<span class="string">&quot;thresh_l&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$&#123;dirname&#125;/other.launch&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>标签remap</strong>重新定义topic(或其他?)所有资源的名字, </p>
<p><strong>标签include</strong>嵌套使用另外一个launch文件.</p>
<a id="more"></a>

<h1 id="订阅-发布接口编写"><a href="#订阅-发布接口编写" class="headerlink" title="订阅/发布接口编写"></a>订阅/发布接口编写</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;std_msg/Strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    ros::init(argc,argv,<span class="string">&quot;listener&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Subscriber subscriber = </span><br><span class="line">        nh.subscribe(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>,callback);</span><br><span class="line">    <span class="comment">//ros::Publisher publiser = </span></span><br><span class="line">    <span class="comment">//  nh.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;,1);</span></span><br><span class="line">    <span class="comment">// publisher.publish(msg1);</span></span><br><span class="line">    ros::spin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具技能</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>launch</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode调试运行cpp程序</title>
    <url>/2020/10/12/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/ROS%E7%9B%B8%E5%85%B3/vscode%E9%85%8D%E7%BD%AEC++%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>与文档”vscode调试运行ROS程序.md”相似,本文档简单讲讲不使用Cmake配置C++/gcc环境.以简单程序调用Eigen库为例.</p>
<h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mypg.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Eigen::MatrixXd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line">    m(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line">    m(<span class="number">1</span>,<span class="number">1</span>) = m(<span class="number">1</span>,<span class="number">0</span>) + m(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h1><p>先要将文档编译成可执行文件,但是需要链接Eigen库头文件,可利用<code>gcc -I</code>指令在终端编译</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc -I /usr/include/eigen3/ mypg.cpp -o mypg</span><br></pre></td></tr></table></figure>

<h2 id="Task-json"><a href="#Task-json" class="headerlink" title="Task.json"></a>Task.json</h2><p>而在vscode中, 可按<code>ctrl+shift+b</code>或F7编译. <code>ctrl+shift+P</code>输入Task指令生成<em>task.json</em>, 修改task.json中的编译相关参数. 该文件相当于吧命令行中输入的所有参数预先保存下来，以后每次编译的时候就会来这里读取需要的参数。json只是一个字典类型文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//命名</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/g++&quot;</span>,		<span class="comment">//终端运行的指令</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [ <span class="comment">//此项是上述命令G++的参数列表</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/*.cpp&quot;</span>,</span><br><span class="line">                <span class="comment">//&quot;$&#123;workspaceFolder&#125;/src/*.cpp&quot;,	//填写需要编译的目标cpp文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,               </span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">                <span class="comment">//生成的可执行文件存放的目录</span></span><br><span class="line">                <span class="comment">//$&#123;fileDirname&#125;当前工作目录; $&#123;fileBasenameNoExtension&#125;以活动文件名为基础的没有扩展名的可执行文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-stdlib=libc++&quot;</span>,	<span class="comment">//这两句是默认的编译器C++98更改为C++11</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;-I&quot;</span>,   <span class="comment">//头文件链接目录.实践证明不好用,在c_cpp_properties中includePath设置更好.ctrl+shift+p配置C/C++.</span></span><br><span class="line">                <span class="string">&quot;/usr/include/eigen3/&quot;</span>，</span><br><span class="line">                <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span> <span class="comment">//the task runner&#x27;s current working directory on startup</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><p>虽然上述可以编译了，但是我们发现vscode自身并没有链接上eigen库, 代码下不会有红色波浪线提示找不到文件，因此需要配置C/C++ Configrations链接起来，写代码时方便跳转查看。</p>
<p><code>ctrl+shift+P</code>调出<em>C/C++ Configrations.</em> 在includePath中添加包含路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;default&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/include/eigen3/&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;gnu11&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以编译了,<code>ctrl+shift+B</code>. 生成相应的可执行文件<code>mypg.exe</code></p>
<h1 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h1><p>按F5自动生成调试用的<strong>launch.json</strong>文档.</p>
<p>要清楚调试是基于生成的可执行文件*.exe才能调试, 因此在先没有可执行文件情况下需要设置<strong>preLaunchTask</strong>为自己的编译任务的名字. </p>
<p>可以定义多个调试器, 以运行不同的cpp和参数调试.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,<span class="comment">//注意可执行文件的后缀</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>工具技能</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统安装注意</title>
    <url>/2019/12/15/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Ubuntu%E7%9B%B8%E5%85%B3/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/suifenghahahaha/article/details/79710023#%E4%BA%B2%E6%B5%8Bdell%E7%AC%94%E8%AE%B0%E6%9C%ACUEFI%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%94%B5%E8%84%91%E5%AE%89%E8%A3%85Win10%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F">较好的教程</a></p>
<h1 id="Wanted：安装Ubuntu到有一个不能删除的分区的移动硬盘上，并能在不同电脑上使用该系统"><a href="#Wanted：安装Ubuntu到有一个不能删除的分区的移动硬盘上，并能在不同电脑上使用该系统" class="headerlink" title="Wanted：安装Ubuntu到有一个不能删除的分区的移动硬盘上，并能在不同电脑上使用该系统"></a>Wanted：安装Ubuntu到有一个不能删除的分区的移动硬盘上，并能在不同电脑上使用该系统</h1><p>看上面的教程时候注意区别legacy和UEFI启动的不同。也就是挂载分区时候，是否选择/boot分区，里面具体的差别请仔细看作者的案例，其两种启动方式都进行了介绍。</p>
<h1 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h1><ol>
<li>直接在硬盘前面上分配出150G的 <strong>“未分配”</strong> 空间，再去Ubuntu划分挂载等空间，出现此问题：</li>
</ol>
<p><strong>问题1：提示“分配到/的分区/dev/sdax开始于xxxx字节,使用磁盘的最小对齐,这可能造成非常差的性能…”</strong></p>
<blockquote>
<p>我们必须要对移动硬盘进行分区，因为直接用隐藏分区进行安装会出现分区未对齐的错误，导致安装失败。（我试了其他系统好像只有乌班图会出现此情况）.<br>这里推荐diskgenius，我是分了一个500M的引导区，200G的根分区，其他正常存储区。（显示就是D盘E盘F盘等），格式化并4K对齐。</p>
</blockquote>
<ol start="2">
<li><p>接下来的操作：下载DiskGenius软件，对前150G的未分配空间建立需要的分区，但是无法旋转逻辑分区或者扩展分区。<strong>问题二</strong></p>
<blockquote>
<p>分区表：<br>EFI系统分区 | 1G<br>Swap交换空间 | 6G<br>EXT4格式（挂载根目录/） | 140G<br>引导文件选择EFI分区。</p>
</blockquote>
</li>
<li><p>未解决逻辑分区问题直接安装Ubuntu,安装成功，但是<em>不能在legacy BIOS电脑中打开系统。</em> <strong>问题三</strong></p>
</li>
<li><p>尝试能否在UEFI系统中打开。都不能打开。</p>
</li>
<li><p>安装/boot的传统方式失败，报错boot内存不能小于1M？？我不是给了2G吗</p>
</li>
<li><p>将磁盘从GPT转换到MBR，发现原有分区可以转换为逻辑分区</p>
<blockquote>
<p>MBR一个磁盘只有1个扩展分区，逻辑分区在扩展分区以下</p>
</blockquote>
</li>
</ol>
<p>还是没成功，提示问题是 <em>no operation System</em> 该尝试的都试过了，总之问题遗留于此，日后有闲情再解决，太浪费时间了。</p>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><ol>
<li>本想在之前的硬盘中添加一个空闲区，以安装Legacy启动的UBuntu系统，这样在Legacy和UEFI启动的两个电脑上都能使用。但是分区这些都太麻烦了，还和硬盘的格式GPT/MBR啥的相关，总之一堆错误，我选择放弃，不如备份，<strong>完全格式化硬盘</strong> 省时间。</li>
<li>尝试了 Legacy 启动的Ubuntu系统是可以在UEFI电脑打开的，需要 <strong>在BIOS界面设置启动Legacy</strong> 。其实他俩最大的差别就是能否支持快速开机。</li>
</ol>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>我在机械硬盘里面安装了个win10，也是历经挫折，最后格式化了整块硬盘是最快的方法，强烈推荐非专家这么干。<br>然后用之前在固态中安装的基于传统legacy启动的Ubuntu可以在两台电脑都打开。</p>
<p><strong>华硕2014年笔记本：</strong></p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">launch CSM</td>
<td align="center">enable</td>
<td align="center">CSM 兼容性支持模块,使系统兼容UEFI</td>
</tr>
<tr>
<td align="center">Lauch PXE opROM</td>
<td align="center">disenable</td>
<td align="center">PXE网络服务器,通过网络启动电脑,一直关闭</td>
</tr>
</tbody></table>
<p>实验下来两快硬盘里面系统的启动要去<code>Boot&gt;&gt;hard Drive BBS Priorities</code>里面选择优先级.<br><strong>联想2019年小新:</strong><br>这就简单很多了，设置好<code>Boot Mod &gt;&gt; legacy surpport</code> <code>legacy first</code>即可。开机之前插上Ubuntu即可。只是由于每次正常开机都会去先寻找legacy，因此会慢10s </p>
]]></content>
      <categories>
        <category>工具技能</category>
      </categories>
      <tags>
        <tag>Linux安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04</title>
    <url>/2021/01/02/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Ubuntu%E7%9B%B8%E5%85%B3/Ubuntu18.04%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Ubuntu-16-04"><a href="#Ubuntu-16-04" class="headerlink" title="Ubuntu 16.04"></a>Ubuntu 16.04</h1><h2 id="移动硬盘-Ubuntu-系统安装"><a href="#移动硬盘-Ubuntu-系统安装" class="headerlink" title="移动硬盘 Ubuntu 系统安装"></a>移动硬盘 Ubuntu 系统安装</h2><p><a href="https://www.jaylee.top/2019/12/15/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F/">16.04见这篇文章</a></p>
<p><a href="https://www.jianshu.com/p/54d9a3a695cc">18.04安装参考</a></p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>/ (根目录) &gt;&gt; / (home目录) &gt;&gt; ~ (当前用户目录) &gt;&gt; /下载 /桌面等</p>
<h2 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h2><p>命令格式:</p>
<blockquote>
<p>command  [-options]  [parameter]<br>sudo加在命令前面表示以管理员身份执行,如:<br>sudo apt install/remove/upgrade *<br>sudo apt-get update /upgrade<br>cd (change directory) 相对/绝对路径(~ /)      cd .. 返回上层目录<br>ls (list)/ll<br>rm (remove)  删除之后无法恢复<br>clear<br>mkdir</p>
</blockquote>
<a id="more"></a>

<h1 id="操作系统准备"><a href="#操作系统准备" class="headerlink" title="操作系统准备"></a>操作系统准备</h1><h2 id="安装到移动硬盘"><a href="#安装到移动硬盘" class="headerlink" title="安装到移动硬盘"></a>安装到移动硬盘</h2><p>inference:<a href="https://www.jianshu.com/p/54d9a3a695cc">https://www.jianshu.com/p/54d9a3a695cc</a></p>
<p>哎,在这种争分夺秒的毕业之际,我竟然也愿意花一个周六来玩这种东西,当作休息好啦. 不过18.04真香.</p>
<p>我是在新买的SSD中安装系统, 步骤还简单, 就是EFI安装的引导文件我放在了新建的系统的efi分区中了,导致win10每次都默认自己优先启动,所以每次都必须去F12界面选择要进入的系统.</p>
<ol>
<li>制作启动盘: 把下载下来的ios文件打开,复制所有文件内容到格式化的新U盘中就好了.</li>
<li>修改BIOS启动顺序, 让USB先运行, 重启进入U盘里的系统</li>
<li>安装Ubuntu18.04: 最主要的是分区, efiz主分区100M, /根目录主分区30G, /home目录逻辑分区70G, 引导文件放在了新建的efi分区上</li>
<li>即可.</li>
</ol>
<h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><ol>
<li>chrome</li>
<li>typora</li>
<li>网易云</li>
<li>vscode/插件</li>
<li>git/hexo</li>
</ol>
<h2 id="安装ROS-Melodic"><a href="#安装ROS-Melodic" class="headerlink" title="安装ROS Melodic"></a>安装ROS Melodic</h2><p>18.04Ubuntu不能装Kinetic了, 版本不对.未来可能会有一些驱动不支持</p>
<p>官网：<a href="http://wiki.ros.org/melodic/Installation/Ubuntu#Installation-1">http://wiki.ros.org/melodic/Installation/Ubuntu#Installation-1</a></p>
<h2 id="安装VPN"><a href="#安装VPN" class="headerlink" title="安装VPN"></a>安装VPN</h2><p>我使用的是socketpro软件: <a href="https://www.socketprohc.com/">https://www.socketprohc.com</a></p>
<p>按照帮助文档中的指示进行安装编译, 每次启动的时候使用nohup**&amp;代码让他后台运行.</p>
<blockquote>
<p><a href="https://www.socketprohc.com/hc/zh-cn/articles/360022001091-%E5%AE%89%E8%A3%85Linux%E5%AE%A2%E6%88%B7%E7%AB%AF">socketPro 使用手册</a></p>
<p><a href="https://www.cnblogs.com/kaituorensheng/p/3980334.html">开启vpn指令</a></p>
</blockquote>
<blockquote>
<ol>
<li>即使关闭终端也可以后台进行:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup ss-local -c ~/socketpro/HK2.json &amp;</span><br></pre></td></tr></table></figure>

<p> 打开网络代理;</p>
<ol start="2">
<li><p>显示后台进程: <code>ps -aux | grep &quot;HK2.json&quot;</code></p>
</li>
<li><p>kill pid(进程号)</p>
</li>
<li><p>关闭网络代理</p>
</li>
</ol>
</blockquote>
<h2 id="安装proxychains"><a href="#安装proxychains" class="headerlink" title="安装proxychains"></a>安装proxychains</h2><p><a href="https://blog.popkx.com/Ubuntu-install-proxychains-let-terminal-using-socks5-proxy-speed-up-downloading/">https://blog.popkx.com/Ubuntu-install-proxychains-let-terminal-using-socks5-proxy-speed-up-downloading/</a></p>
<p>代理网络, 加速终端下载。</p>
<p>用curl测试一直连不上服务器。也不知道proxychains有没有发挥作用，反正在费时慢速的命令前加上proxychains就可以使用了，心里作用感觉还行。</p>
<h1 id="编程环境准备"><a href="#编程环境准备" class="headerlink" title="编程环境准备"></a>编程环境准备</h1><h2 id="安装Ceres-Solver"><a href="#安装Ceres-Solver" class="headerlink" title="安装Ceres-Solver"></a>安装Ceres-Solver</h2><p><a href="https://www.jianshu.com/p/e5b03cf22c80">入门百科</a></p>
<p><a href="http://ceres-solver.org/features.html">官方文档</a></p>
<p>简单了解一下这是谷歌使用多年的用于求解非线性优化问题的库,在激光雷达SLAM算法中广泛被使用. 了解以下即可. 算法分为三步骤: </p>
<ol>
<li>最优函数 </li>
<li>构建待求解优化问题</li>
<li>配置求解器参数</li>
</ol>
<h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CMake &gt;3.5 version:</span></span><br><span class="line">sudo apt-get install cmake</span><br><span class="line"><span class="meta">#</span><span class="bash"> google-glog + gflags 用于记录有关内存分配和解决方案各个部分所消耗的时间，内部错误条件等的详细信息</span></span><br><span class="line">sudo apt-get install libgoogle-glog-dev libgflags-dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> BLAS &amp; LAPACK</span></span><br><span class="line">sudo apt-get install libatlas-base-dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> Eigen3  &gt; 3.3 version: </span></span><br><span class="line">sudo apt-get install libeigen3-dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> SuiteSparse and CXSparse (optional)</span></span><br><span class="line">sudo apt-get install libsuitesparse-dev</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tar zxf ceres-solver<span class="number">-2.0</span><span class="number">.0</span>.tar.gz</span><br><span class="line">mkdir ceres-bin</span><br><span class="line">cd ceres-bin</span><br><span class="line">cmake ../ceres-solver<span class="number">-2.0</span><span class="number">.0</span></span><br><span class="line">make -j3</span><br><span class="line">make test</span><br><span class="line"># Optionally install Ceres, it can also be exported <span class="keyword">using</span> CMake which</span><br><span class="line"><span class="meta"># allows Ceres to be used without requiring installation, see the documentation</span></span><br><span class="line"><span class="meta"># for the EXPORT_BUILD_DIR option for more information.</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="安装ntcan驱动"><a href="#安装ntcan驱动" class="headerlink" title="安装ntcan驱动"></a>安装ntcan驱动</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0NTY1MjMyMA==&mid=2247483734&idx=1&sn=d34b05930faad591ab406f6980ef496d&chksm=fb68ea59cc1f634f059997a5df4d72245cf12482f3630387385f27bc857d8aac4bd34d6b6eac&mpshare=1&scene=1&srcid=0802y9aLyMoG1fLqLAmFckg8&sharer_sharetime=1564725138547&sharer_shareid=217e32ecaea6b07e5e13a33b8b664e23&exportkey=AUuW4VYfF46FRgrTQd9RpDY=&pass_ticket=3eWdTXq9a/0BR3GcSkFk2tt4qKx/Rz3S6sUoOxcRmtXezeazDVg8+TmBGR12YNPo&wx_header=0#rd">公众号连接</a></p>
<p>下载连接: <a href="http://esdshanghai.com/esd_download.html">http://esdshanghai.com/esd_download.html</a></p>
<p>自己电脑上调试只需要安装ntcan的头文件和源文件库即可,即文中的567步.</p>
<p>或者直接在CMake中注释掉can节点</p>
]]></content>
      <categories>
        <category>工具技能</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode下调试运行ROS程序</title>
    <url>/2020/06/17/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/ROS%E7%9B%B8%E5%85%B3/vscode%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CROS%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>vscode编辑器下调试ROS程序配置,主要利用Cmake工具编译,配置好.vscode/下的设置文件*.json</p>
<p><a href="https://vector-of-bool.github.io/docs/vscode-cmake-tools/index.html">阅读vscode官方插件cmake tools说明文档</a></p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote>
<p>选择kit。Kit是一组工具包，包括编译器、链接器等其他工具，如gcc,clang等</p>
</blockquote>
<blockquote>
<p>variant。有4种，debug,release是其中两种。</p>
</blockquote>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>vscode安装插件：ROS, C/C++, C++ Intellisense, CMake Rools,<br>终端中打开vscode当前目录<code>code .</code>，会自动生成‘.vscode’文件夹,里面包含两个.json配置文件:</p>
<blockquote>
<p>c_cpp_properties.json 主要是ROS插件生成,用于识别配置ros相关头文件等<br>settings.json vscode编辑器设置文档</p>
</blockquote>
<p>通过另一个配置文件task.json, 这里可以直接在vscode进行catkin_make。ctrl+shift+P调出vscode的命令行，输入Task:Config default task生成*.json文件。修改其内容见链接内容，主要是配置catkin_make或者g++编译的参数。<br>编译后出现compile_commands.json，<br><code>catkin_make -DCMAKE_EXPORT_COMPILE_COMMANDS=Yes</code><br>这个文件可以帮助我们关联编译所需要的文件路径，需要添加在c_cpp_properties.json里面”compileCommond”配置中<br><code>&quot;compileCommands&quot;:&quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;</code></p>
<h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">//c_cpp_properties.json</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;browse&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;databaseFilename&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;limitSymbolsToIncludedHeaders&quot;</span>:<span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/opt/ros/kinetic/include/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/include/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ROS&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;gcc-x64&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;gnu11&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;configurationProvider&quot;</span>: <span class="string">&quot;ms-vscode.cmake-tools&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;compileCommands&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;</span></span><br><span class="line">            <span class="comment">//上述两行可解决找不到ros.h的类似问题</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="task-json"><a href="#task-json" class="headerlink" title="task.json"></a>task.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">//task.json chen</span></span><br><span class="line">	<span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;label&quot;</span>: <span class="string">&quot;catkin_make&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;catkin_make&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">				<span class="string">&quot;-j4&quot;</span>,</span><br><span class="line">				<span class="string">&quot;-DCMAKE_BUILD_TYPE=Release&quot;</span>,</span><br><span class="line">				<span class="string">&quot;-DCMAKE_EXPORT_COMPILE_COMMANDS=Yes&quot;</span>,</span><br><span class="line">				<span class="string">&quot;-DCMAKE_CXX_STANDARD=14&quot;</span></span><br><span class="line">			],</span><br><span class="line">			</span><br><span class="line">			<span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">				<span class="string">&quot;$catkin-gcc&quot;</span></span><br><span class="line">			],</span><br><span class="line">			<span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">//task from Bilibili</span></span><br><span class="line">	<span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;source /opt/ros/kinetic/setup.bash &amp;&amp; catkin_make -DCMAKE_BUILD_TYPE=Debug&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">			<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">				<span class="string">&quot;$catkin-gcc&quot;</span></span><br><span class="line">			],</span><br><span class="line">			<span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">        <span class="comment">//定义多个编译器命令release</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;label&quot;</span>:<span class="string">&quot;release&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;command&quot;</span>:<span class="string">&quot;source /opt/ros/kinetic/setup.bash &amp;&amp; catkin_make -DCMAKE_BUILD_TYPE=Release&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">				<span class="string">&quot;$catkin-gcc&quot;</span></span><br><span class="line">			],</span><br><span class="line">			<span class="attr">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上就可以和在终端中一样运行程序了。但是想要设置断点对程序进行调试debug则需要更多配置，生成debug版本的可执行程序。<br>后话：实际上还是会提示找不到ros.h.是不是ws目录必须在～下？</p>
<h2 id="调试-launch-json"><a href="#调试-launch-json" class="headerlink" title="调试 launch.json"></a>调试 launch.json</h2><blockquote>
<p>GDB调试器是调试C++代码的神器，ROS项目本质上也是一个ROS项目，因此也可以用GDB进行调试<br>在vscode里面已经继承了GDB调试器，我们需要做的就是配置launch.json文件</p>
</blockquote>
<p>点击左侧工具栏调试按钮，自动生成launch.json.</p>
<p><a href="https://www.bilibili.com/video/BV1Ft411M7Uk">B站视频链接</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb)Launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/devel/lib/tutorials/talker&quot;</span>, </span><br><span class="line">            <span class="comment">//修改，将需要调试的节点在编译后生成的可执行文件的路径添加</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span>,<span class="comment">//若没有修改就不需要每次都编译.也可以每次调试前先catkin_make</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>工具技能</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu常用问题记录</title>
    <url>/2020/10/10/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Ubuntu%E7%9B%B8%E5%85%B3/ubuntu%E5%B8%B8%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="开机启动VPN脚本"><a href="#开机启动VPN脚本" class="headerlink" title="开机启动VPN脚本"></a>开机启动VPN脚本</h1><p>每次开机都要设置鼠标灵敏度和打开ssVPN操作,不如让这两行命令开机启动,省事.</p>
<p>1.在<code>/etc/init.d/</code>文件夹下添加一个脚本文件vpn_open.sh, </p>
<p>脚本格式如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:          vpn_open.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start:    <span class="variable">$local_fs</span> <span class="variable">$network</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop:     <span class="variable">$local_fs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:      0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description: open vpn service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description:       open vpn service HK2.json</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line">nohup ss-local -c /home/lee/socketpro/HK2.json &amp;</span><br><span class="line">xset m 2</span><br></pre></td></tr></table></figure>

<p>2.将这个脚本添加到开机启动的服务中.<a href="https://blog.csdn.net/MakerCloud/article/details/81257953?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">参考链接</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x vpn_open.sh #设置权限</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将脚本添加到启动脚本,90为优先级,数值越高优先级越低</span></span><br><span class="line">cd /etc/init.d/</span><br><span class="line">sudo update-rc.d start_test.sh defaults 90</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除服务方法</span></span><br><span class="line">cd /etc/init.d</span><br><span class="line">sudo update-rc.d -f start_test.sh remove</span><br></pre></td></tr></table></figure>

<h1 id="设置鼠标速度"><a href="#设置鼠标速度" class="headerlink" title="设置鼠标速度"></a>设置鼠标速度</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xset m N #N为速度,2即可</span><br></pre></td></tr></table></figure>

<h1 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown lee:lee rslidar_sdk/ -R</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具技能</category>
      </categories>
      <tags>
        <tag>Ubuntu小操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo&amp;github blog搭建指南</title>
    <url>/2019/12/11/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/Hexo%E5%86%99%E6%96%87%E7%AB%A0%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Hexo-Github搭建"><a href="#Hexo-Github搭建" class="headerlink" title="Hexo.Github搭建"></a>Hexo.Github搭建</h1><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a><a href="https://zhuanlan.zhihu.com/p/98782798">安装nodejs</a></h2><p>然后还需要把.bash_profile添加到~/.bashrc文件中,不然每次启动终端都要重新source.</p>
<p><code>echo &quot;source my_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p>
<p><em>20201108更新：</em>上述版本老了，最新简单的方法参见如下：</p>
<p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz    // 下载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xf  node-v10.9.0-linux-x64.tar.xz       // 解压</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> node-v10.9.0-linux-x64/                  // 进入解压目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./bin/node -v                               // 执行node命令 查看版本</span></span><br><span class="line">v10.9.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接：</span></span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/software/nodejs/bin/npm   /usr/local/bin/ </span><br><span class="line">sudo ln -s /usr/software/nodejs/bin/node   /usr/local/bin/</span><br></pre></td></tr></table></figure>

<h2 id="github-Hexo搭建网站参考网站"><a href="#github-Hexo搭建网站参考网站" class="headerlink" title="github*Hexo搭建网站参考网站"></a><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NzIyMzkzNw==&mid=2247483933&idx=1&sn=83025d4b28a2e942b6f6b03afc307e00&chksm=c0745e73f703d765db3a6fc24f438dbf080be564519ed0e9e059f2d05aa11b4ebc41fcdb54e8&mpshare=1&scene=1&srcid=1210QbJ1A3cFhvwTDCBTIVWS&sharer_sharetime=1575974630035&sharer_shareid=a4c679dca6b53ec07fadfa65af7fab43&key=0a80781bf411d282ec9c5a01050c4c3eba63b706a005d47211f2b926a021225b4545d93fc647ceb9d5fee91b844fc26ebdce801bde5251ddea6b944447e21208eb782c7952010ca3124eca4eb7c97abe&ascene=1&uin=MjcyNzI2MjU4Mw==&devicetype=Windows+10&version=62070158&lang=zh_CN&exportkey=ASlhsjxzEp1NOdoiRSaztPc=&pass_ticket=ohJ2OLzSmGjm11lix78IW3eQC8Pyc5Jkqa+w52NrKcem6YVv7i/fQ7Er4Sfm7KAQ">github*Hexo搭建网站参考网站</a></h2><p><code>npm install -g hexo-cli</code></p>
<ol>
<li><p>可能提示找不到hexo命令,环境变量没有设置好.</p>
<p>参考连接学习哪些方法可以写入环境变量: <a href="https://blog.csdn.net/lixiaoguang20/article/details/53814020">https://blog.csdn.net/lixiaoguang20/article/details/53814020</a></p>
</li>
<li><p>还提示我”TypeError, “StartWith”****”这种问题, 查明是nodejs的版本不对,去官网下载最新的安装.</p>
</li>
</ol>
<h2 id="优秀博文"><a href="#优秀博文" class="headerlink" title="优秀博文"></a>优秀博文</h2><p><a href="https://io-oi.me/tech/hexo-next-optimization/">https://io-oi.me/tech/hexo-next-optimization/</a></p>
<a id="more"></a>

<h2 id="Github添加SSH-key"><a href="#Github添加SSH-key" class="headerlink" title="Github添加SSH-key"></a>Github添加SSH-key</h2><p>要将本地的库推送到github远程仓库中必须首先生成本地的密钥并添加到github账号中。</p>
<p><a href="https://www.cnblogs.com/syw20170419/p/10732826.html">https://www.cnblogs.com/syw20170419/p/10732826.html</a></p>
<h1 id="Hexo-Blog文章撰写"><a href="#Hexo-Blog文章撰写" class="headerlink" title="Hexo Blog文章撰写"></a>Hexo Blog文章撰写</h1><ol>
<li>在<code>source/_posts</code>文件夹下面建立 .md新文档。</li>
<li>使用的markdown是一种程序化的写文章语言，方便放代码块</li>
<li>md语法参考文章<a href="./markDown%E4%B9%A6%E5%86%99%E6%8C%87%E5%8D%97.md">markdown书写指南</a></li>
<li>插入图片最好的方法，在<code>/_post</code>下面建立同名文件夹<code>hexo n mdName</code>,将图片放入该文件夹下。</li>
</ol>
<h1 id="Hexo发布到网页"><a href="#Hexo发布到网页" class="headerlink" title="Hexo发布到网页"></a>Hexo发布到网页</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<p><code>hexo clean</code> 删除public缓存<br><code>hexo g</code>生成<br><code>hexo s</code>本地服务器<br><code>hexo d</code>部署到github，deploy<br><code>sh deploy.sh</code> 一键部署</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="Github站点配置"><a href="#Github站点配置" class="headerlink" title="Github站点配置"></a>Github站点配置</h1><p>hexo提供了很多主题: <a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><ol>
<li>Next主题,黑白那种:<a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html">https://theme-next.js.org/docs/advanced-settings/custom-files.html</a></li>
<li>Sakura二次元主题:<a href="https://docs.hojun.cn/sakura/docs/#/home">https://docs.hojun.cn/sakura/docs/#/home</a></li>
<li>diaspora二次元主题:<a href="https://github.com/Fechin/hexo-theme-diaspora">https://github.com/Fechin/hexo-theme-diaspora</a></li>
</ol>
<h2 id="按更新时间排序文章"><a href="#按更新时间排序文章" class="headerlink" title="按更新时间排序文章"></a>按更新时间排序文章</h2><blockquote>
<p>我用的 VSCode 写博客，所以选择了这个工具 <a href="https://marketplace.visualstudio.com/items?itemName=jsynowiec.vscode-insertdatestring">Insert Date String</a>。安装好后，OS X 按 <code>⇧ + ⌘ + I</code>，Windows 和 Linux 按 <code>Ctrl + Shift + I</code>，即可插入当前时间了，体验很爽的！</p>
<p>有了修改时间，我们再修改默认配置文件就能实现按 updated 排序了，如下。</p>
<p>找到主配置文件 <code>_config.yml</code>，然后修改 <code>index_generator</code> 的 <code>order_by</code> 为 <code>-updated</code> 即可:</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Home page setting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> path: Root path <span class="keyword">for</span> your blogs index page. (default = <span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> per_page: Posts displayed per page. (0 = <span class="built_in">disable</span> pagination)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -updated</span><br></pre></td></tr></table></figure>
<p>最方便的方法:下载<code>hexo-generator-index-plus</code>,去官网搜索.</p>
<h2 id="修改主页摘要"><a href="#修改主页摘要" class="headerlink" title="修改主页摘要"></a>修改主页摘要</h2><ol>
<li>方法一<br>在文中添加分隔符:<code>&lt;!--more--&gt;</code></li>
<li>方法二<br>在文章头部添加description:这是描述</li>
<li>方法三<br>自动生成摘要.在主题配置文件中加<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>工具技能</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2019/12/10/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/markDown%E4%B9%A6%E5%86%99%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><p>Markdown基本语法链接: <a href="http://xianbai.me/learn-md/article/syntax/links.html">http://xianbai.me/learn-md/article/syntax/links.html</a></p>
<a id="more"></a>

<ol>
<li>引用图片<code>![pngName](blabla.png)</code><img src="/2019/12/10/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/markDown%E4%B9%A6%E5%86%99%E6%8C%87%E5%8D%97/test.JPG" alt="test" style="zoom:50%;"></li>
<li>插入超链接<br>“[超链接] (<a href="https://www.jianshu.com/p/191d1e21f7ed)&quot;">https://www.jianshu.com/p/191d1e21f7ed)&quot;</a></li>
<li>句子前添加符号”&gt;”</li>
</ol>
<blockquote>
<p>这是引用的内容 </p>
</blockquote>
<ol start="6">
<li>*<em>加粗两对</em>星号**</li>
<li>嵌入式代码<code>单行代码,一对反单引号</code></li>
<li>多行代码, “<strong>```C++</strong>“</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">三个反单引号成对</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>表格</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">| 标题1|标题2|</span><br><span class="line">|---|---|</span><br><span class="line">|内容1|内容二|</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="公式语法"><a href="#公式语法" class="headerlink" title="公式语法"></a>公式语法</h1><p>参考链接：<a href="https://www.cnblogs.com/hzcya1995/p/13308012.html">https://www.cnblogs.com/hzcya1995/p/13308012.html</a></p>
]]></content>
      <categories>
        <category>工具技能</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>CXX学习整理</title>
    <url>/2020/10/11/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/C++%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>C++学习主要内容</p>
<ul>
<li>数据结构</li>
<li>指针与引用</li>
<li>类和对象</li>
<li>继承与重载与多态</li>
<li>函数</li>
<li>模板库</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 知识点</title>
    <url>/2020/05/14/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/CXX%E4%BB%A3%E7%A0%81%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;() </span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unodered_map&lt;<span class="keyword">char</span> <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c:J)</span><br></pre></td></tr></table></figure>

<h2 id="p-x-lt-18-0f-表示18是浮点数而非int"><a href="#p-x-lt-18-0f-表示18是浮点数而非int" class="headerlink" title="-p.x &lt; 18.0f`表示18是浮点数而非int"></a>-p.x &lt; 18.0f`表示18是浮点数而非int</h2><h2 id="emplace"><a href="#emplace" class="headerlink" title="emplace"></a>emplace</h2><p>C++11中vector添加emplace_front,emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。可以提高插入运算的效率</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">const</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">float</span> &amp; <span class="title">Area</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _area; &#125;</span><br></pre></td></tr></table></figure>

<p>第一个const修饰的是引用的内容为常量不能修改</p>
<p>第二个const修饰的是类成员函数，申明该函数为访问函数, 确保成员函数不修改被调用对象的值_area。如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。</p>
<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CXX学习笔记(一)</title>
    <url>/2020/06/28/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/CXX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="友元函数friends"><a href="#友元函数friends" class="headerlink" title="友元函数friends"></a>友元函数friends</h2><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>每个成员函数通过this指针指向自己这个对象/类. 把搭建的类/对象理解成一栋房子,我们在屋内时候不能看到整个房屋,但是this就相当于房子的门牌号, 代替自己房子的地址.</p>
<p>往往自己在些类的时候,正在构建的类没有具体的对象,但需要用到其他成员函数的时候,可以用this-&gt;function调用.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        rect(<span class="keyword">int</span> h, <span class="keyword">int</span> w)</span><br><span class="line">        &#123;</span><br><span class="line">            hight = h;</span><br><span class="line">            width = w;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">aera</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hight*width;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(rect B)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;aera &gt; B.aera();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> hight;</span><br><span class="line">    	<span class="keyword">int</span> width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><code>class A : public B</code></p>
<p>A为派生类(子类)derive, B为基类(父类)base</p>
<p>A类公有继承B类(public), 即A类可以访问B类所有公有和保护的成员(public,protect),但不能访问B类的私有成员.</p>
<h2 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a><a href="https://www.runoob.com/w3cnote/cpp-virtual-functions.html">虚函数和纯虚函数</a></h2><p><strong>虚函数</strong>: 基类函数最前面添加<code>virtual</code>指令, 父类中定义了虚函数的一种实现方式,子类中可以存在与之同名同参数同返回值的成员函数,并给出<em>不同的实现</em>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数允许派生类不同的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;foo();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!因此输出显示&quot;B::foo() is called&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>纯虚函数</strong>: 当父类是一种抽象类,比如动物,是无法定义一个具体的对象实例的,因此不能得到其animalType. 所以定义一个纯虚函数,让子类(比如大象)自己去定义编写.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">animalType</span><span class="params">()</span> </span>= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>作用就是规范类的接口.</p>
<p><em>注意的是有纯虚函数定义的类是不能初始化实例对象的.而虚函数是必须要有定义的,否则会报错.</em></p>
<h1 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;;<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio&gt;</span></span></span><br><span class="line">	<span class="built_in">printf</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;x=%d&quot;</span>,&amp;x); <span class="comment">//从键盘读取数据付给地址内的变量x的，&amp;取地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	</span></span></span><br><span class="line">	gets();</span><br><span class="line">	getline();<span class="comment">//相比与CIN,此函数只以回车为结束.</span></span><br><span class="line">	<span class="built_in">puts</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math&gt;</span></span></span><br><span class="line">	<span class="built_in">cos</span>();<span class="built_in">exp</span>();<span class="built_in">fabs</span>();<span class="built_in">log</span>();<span class="built_in">pow</span>();<span class="built_in">sqrt</span>();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>头文件用双引号 表示优先在当前文件夹目录下寻找；尖括号表示直接去系统指定文件夹寻找。</p>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#difine PI 3.141592653</span></span><br></pre></td></tr></table></figure>

<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a><a href="https://www.cnblogs.com/challenger-vip/p/3386819.html">条件编译</a></h2><p><code>#ifndef，#define，#endif</code></p>
<p>ifndef: if not define. 实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> x                 <span class="comment">//先测试x是否被宏定义过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x</span></span><br><span class="line">   程序段<span class="number">1b</span>labla~    <span class="comment">//如果x没有被宏定义过，定义x，并编译程序段 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>   </span></span><br><span class="line">　　程序段<span class="number">2b</span>labla~　　 <span class="comment">//如果x已经定义过了则编译程序段2的语句，“忽视”程序段 1</span></span><br></pre></td></tr></table></figure>

<p>主要目的是防止头文件的重复编译和包含。避免多个cpp文件都包含同一个h文件时，全局变量被重定义的错误。</p>
<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><h2 id="default，-delete"><a href="#default，-delete" class="headerlink" title="=default，=delete"></a><code>=default，=delete</code></h2><p><a href="https://www.cnblogs.com/lsgxeva/p/7787438.html">参考链接</a></p>
<p>四类特殊的成员函数：构造函数、析构函数、拷贝构造函数、拷贝赋值函数。负责类的对象的创建、初始化、销毁、和拷贝。</p>
<p>C++11 标准引入了一个新特性：”=default”函数。程序员只需在函数声明后加上“=default;”，就可将该函数声明为 “=default”函数，编译器将为显式声明的 “=default”函数自动生成函数体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;=default&quot;函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X2() = <span class="keyword">default</span>; <span class="comment">//Inline defaulted 默认构造函数</span></span><br><span class="line">    X2(<span class="keyword">const</span> X&amp;);</span><br><span class="line">    X2&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;);</span><br><span class="line">    ~X2() = <span class="keyword">default</span>;  <span class="comment">//Inline defaulted 析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X2::X2(<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">//Out-of-line defaulted 拷贝构造函数</span></span><br><span class="line">X2&amp; X2::<span class="keyword">operator</span>= (<span class="keyword">const</span> X2&amp;) = <span class="keyword">default</span>;   <span class="comment">//Out-of-line defaulted  拷贝赋值操作符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了能够让程序员显式的禁用某个函数，C++11 标准引入了一个新特性：&quot;=delete&quot;函数。程序员只需在函数声明后上“=delete;”，就可将该函数禁用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X3();</span><br><span class="line">    X3(<span class="keyword">const</span> X3&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 声明拷贝构造函数为 deleted 函数</span></span><br><span class="line">    X3&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X3 &amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝赋值操作符为 deleted 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include<functional></functional></h2><p><a href="https://www.jianshu.com/p/f191e88dcc80">链接一</a></p>
<p><a href="https://blog.csdn.net/shuilan0066/article/details/82788954">链接二</a></p>
<h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h3><blockquote>
<ul>
<li><p>定义格式：std::function&lt;函数返回值类型（函数输入参数类型）&gt;。</p>
</li>
<li><p>std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为回调函数使用。它比普通函数指针更加的灵活和便利。</p>
</li>
</ul>
</blockquote>
<p>它是一类函数的模板，给具有相同输入输出类型的函数或方法重命名，需要传入这个函数，同时需要说明&lt;返回值(输入参数)&gt;，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f = functionname_add();</span><br></pre></td></tr></table></figure>

<p>对于类成员函数的替代如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i + j;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> T <span class="title">AddT</span><span class="params">(T i, T j)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i + j;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">AddN</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i + j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这几个函数都是int(int,int)类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、 类静态函数</span></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f = &amp;Computer::Add;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//2、 类静态模板函数</span></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; ft = &amp;Computer::AddT&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ft(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//成员函数绑定  需要构造类对象</span></span><br><span class="line">	Computer c;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//3、 成员函数 需使用bind,将类对象地址 &amp;c 绑定上</span></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; fN = <span class="built_in">std</span>::bind(&amp;Computer::AddN, &amp;c, placeholders::_1, placeholders::_2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fN(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//4、普通函数， 也可以这样调用  个人觉得这个比 bind 麻烦，不建议</span></span><br><span class="line">	<span class="built_in">std</span>::function &lt;<span class="keyword">int</span>(<span class="keyword">const</span> Computer ＆, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; fN2 = &amp;Computer::AddN;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fN2(c,<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h3><p>参见链接二。</p>
<blockquote>
<p>std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：</p>
</blockquote>
<blockquote>
<ul>
<li>将可调用对象和其参数绑定成一个防函数；</li>
<li>只绑定部分参数，减少可调用对象传入的参数。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line"><span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind (my_divide,_1,<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;               </span><br></pre></td></tr></table></figure>

<p>第一个参数是函数，被隐式转换为了函数指针，</p>
<p>第二个参数_1表示占位符，std::placeholders::__1</p>
<p>第三个参数便是输入值double y为2</p>
<h3 id="std-transform"><a href="#std-transform" class="headerlink" title="std::transform"></a>std::transform</h3><p><a href="http://c.biancheng.net/view/623.html">http://c.biancheng.net/view/623.html</a></p>
<p>它可以将一个或两个数组中对应的每个元素单独拎出来执行运算。</p>
<p>一元函数情况下包含3个参数：</p>
<ul>
<li>数组</li>
<li>输出的存储数组</li>
<li>函数/匿名函数</li>
</ul>
<p>二元函数情况下包括5个参数：</p>
<ul>
<li><p>第一个变量的数组的开始</p>
</li>
<li><p>第一个变量的数组的结束</p>
</li>
<li><p>第二个变量的数组</p>
</li>
<li><p>输出的保存数组</p>
</li>
<li><p>处理函数/匿名函数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CXX学习笔记（二）</title>
    <url>/2020/07/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/CXX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<p>对于书籍《数据结构与算法分析——C++语言描述第四版》的学习笔记</p>
<h1 id="指针pointor和引用-amp"><a href="#指针pointor和引用-amp" class="headerlink" title="指针pointor和引用&amp;"></a>指针pointor和引用&amp;</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><code>IntCell *m</code>是关于m的申明，m是指针变量，指向一个IntCell对象，m的值是指向对象的地址，此时尚未初始化。</p>
<p>初始化（动态创建）：</p>
<p><code>m = new Intcell();</code></p>
<p><code>m = new Intcell&#123;&#125;;//C++11</code></p>
<p><code>m = new Intcell;</code></p>
<p>当通过new操作符分配地址的对象不再被引用时候，必须进行delete进行垃圾回收，否则指针所占用的内存将会一直被丢失得不到利用知道程序终止。</p>
<p><code>delete m</code></p>
<h2 id="amp-取地址操作符，引用"><a href="#amp-取地址操作符，引用" class="headerlink" title="&amp; 取地址操作符，引用"></a>&amp; 取地址操作符，引用</h2><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><ul>
<li><p>给复杂的名称取别名</p>
<p><code>auto &amp; List = theLists[myhash(x,theLists.size())]</code></p>
<p>这样对List进行操作就是对原对象进行操作，若不加引用则是对拷贝对象进行操作，原内容并无变化。</p>
</li>
<li><p>范围for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让arr数组中每个变量加1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> X:arr)</span><br><span class="line">    ++X;		<span class="comment">//不可行,x拷贝了每一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x:arr)</span><br><span class="line">    ==x;		<span class="comment">//可行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>避免不必要的拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = findMax(arr);</span><br><span class="line"><span class="keyword">auto</span> &amp;x = findMax(arr);<span class="comment">//没有对数组中的最大值进行拷贝</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;<span class="comment">//x,y,str都是左值,2,hello是右值</span></span><br><span class="line"><span class="built_in">string</span> &amp; bad = <span class="string">&quot;hello&quot;</span>;<span class="comment">//错误,此乃左值引用,&quot;hello&quot;为不可修改的右值</span></span><br><span class="line"><span class="built_in">string</span> &amp;&amp; good = <span class="string">&quot;hello&quot;</span>;<span class="comment">//合法</span></span><br></pre></td></tr></table></figure>

<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>对于输入到函数的参数对象：</p>
<blockquote>
<p>对于小的不该被函数改变的对象,可以采取<strong>传值调用.</strong></p>
<p>对于大的不该被函数改变的复制代价昂贵的对象,应采取<strong>传常量引用调用</strong></p>
<p>对于所有可以被函数改变的对象,应该采取<strong>传引用调用</strong>.</p>
</blockquote>
<p>常用的传值调用将实参复制到形参,对于大的对象效率低,且不能改变实参。而采用传引用调用就可以在函数内部改变传入的实参，且不会复制代价。若输入参数不希望改变且较大，这使用传常量引用调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">randomItem</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; arr)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h2><p>传值返回。</p>
<p>传常量引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Largetype &amp; randomItem2（<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Largetype&gt; &amp; arr)</span><br><span class="line">&#123;...&#125;</span><br><span class="line">Largetype a = randomItem(vec);<span class="comment">//返回值发生了复制</span></span><br><span class="line">Largetype b = randomItem2(vec);<span class="comment">//复制</span></span><br><span class="line">Largetype &amp; c =randomItem2(vec);<span class="comment">//没有复制</span></span><br></pre></td></tr></table></figure>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="初始化表列："><a href="#初始化表列：" class="headerlink" title="初始化表列："></a>初始化表列：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">：membervalue&#123;initalValue&#125;&#123;&#125;<span class="comment">//比如数据成员为const型，因此只能在初始化表列中初始化。</span></span><br></pre></td></tr></table></figure>

<h2 id="explicit构造函数"><a href="#explicit构造函数" class="headerlink" title="explicit构造函数"></a>explicit构造函数</h2><p>英文原意“明确的不含糊的”，为了申明隐式的类型转换是不可行的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">IntCell</span><span class="params">(<span class="keyword">int</span> initialValue = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    	: membervalue</span>&#123;initalValue&#125;&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">const</span>	<span class="comment">//常成员函数，访问函数，表示不改变对象数据成员</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> membervalue;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span>	<span class="comment">//修改函数，可修改数据成员，但是不能改变常对象。</span></span></span><br><span class="line"><span class="function">    </span>&#123;membervalue = x;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> membervalue;</span><br></pre></td></tr></table></figure>

<p>举例explicit的作用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IntCell N;</span><br><span class="line">N = <span class="number">20</span>; 	<span class="comment">//类型不匹配，但是C++隐式类型转换会先创建临时IntCell对象，再赋值给N。</span></span><br><span class="line"><span class="comment">//而添加explicit后就会指出这个问题</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数类型"><a href="#构造函数类型" class="headerlink" title="构造函数类型"></a>构造函数类型</h2><p>当数据成员为指针类型时，默认的几类构造函数将不起作用，他们只是对指针地址进行了<strong>浅拷贝</strong>,而我们需要的是对指向的内容进行<strong>深拷贝</strong>,因此需要自己写:</p>
<ul>
<li><p>析构函数</p>
</li>
<li><p>复制构造函数</p>
</li>
<li><p>移动构造函数</p>
</li>
<li><p>拷贝赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IntCell &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> IntCell &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">        *membervalue  = *rhs.membervalue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>移动复制</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++知识点学习笔记(一)</title>
    <url>/2020/05/14/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/CXX%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="2020年5月"><a href="#2020年5月" class="headerlink" title="2020年5月"></a>2020年5月</h1><h2 id="源文件和头文件"><a href="#源文件和头文件" class="headerlink" title="源文件和头文件"></a><a href="https://www.cnblogs.com/xxcn/p/10930105.html">源文件和头文件</a></h2><p>.cpp文件通过<code>#include .h</code>直接一字不差的引用头文件中的代码.头文件中,存在变量或者函数的<strong>声明</strong>，而不要放定义.这些全局变量或函数在其他的.cpp源文件中得到定义.因此头文件的作用就是声明即将用的函数或变量,将不同.cpp链接起来,同样的东西便不用在多个cpp中都进行编译.在多个文件中出现了对于一个符号（变量或函数）的定义，纵然这些定义都是相同的，但对于编译器来说，这样做不合法,即不能多重定义<br>头文件中可以定义的类别,例外:</p>
<h2 id="哈希表unordered-map"><a href="#哈希表unordered-map" class="headerlink" title="哈希表unordered_map"></a><a href="https://www.jianshu.com/p/4e64fce04a38">哈希表unordered_map</a></h2><p>无序映射表，key-value，可以将查询时间复杂度降为o(1).</p>
<p>相关函数查一查。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宝石与石头问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; mp;<span class="comment">//&lt;Key T&gt;</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : J) <span class="comment">//j为字符串J中的一个字符</span></span><br><span class="line">            mp[j] = <span class="number">1</span>;	<span class="comment">//mp[Key] = value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : S)</span><br><span class="line">            <span class="keyword">if</span> (mp[s]) sum++; <span class="comment">//mp[s]有这个Key为1</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a><a href="https://www.cnblogs.com/frankfang/archive/2011/05/02/2034393.html">声明和定义</a></h2><blockquote>
<p>“定义”的严谨C++语意，即内存占有，编译器将在相对内存地址上为其对象定址！</p>
</blockquote>
<blockquote>
<p>所以有回复说：</p>
<p>变量和对象不加extern永远是定义,类中的除外。<br>函数只有函数头是声明，有函数体的是定义。<br>类永远只是声明。类成员函数的函数体是定义。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x; <span class="comment">//这里的x是声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a; <span class="comment">//这里的a是声明</span></span><br><span class="line">    <span class="comment">//非static变量在类实例化时才分配内存.</span></span><br><span class="line">    MyClass();<span class="comment">//这里的函数是声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> MyClass::x;<span class="comment">//这是定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MyClass::a=<span class="number">11</span>;<span class="comment">//这是定义</span></span><br></pre></td></tr></table></figure>



<h2 id="boost-make-shared"><a href="#boost-make-shared" class="headerlink" title="boost::make_shared"></a>boost::make_shared</h2><p>智能指针,可以允许多个指针指向同一个地址内存,并且在所有指针的计数器消除为0时候自动删除内存.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">233</span>);</span><br><span class="line"><span class="function">boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="comment">//然后就不能再delete p了, 否则重复释放</span></span><br></pre></td></tr></table></figure>

<h2 id="auto-关键字"><a href="#auto-关键字" class="headerlink" title="auto 关键字"></a>auto 关键字</h2><p>声明变量时根据初始化表达式自动推断该变量的类型</p>
<p><code>auto z(&quot;hello&quot;);//const char*</code></p>
<p>但是不建议对于简单的变量使用auto,而多用于类型冗长/变量使用范围专一时候使用,方便程序阅读.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = vect.begin(); it != vect.end(); ++it)</span><br><span class="line">&#123;  <span class="comment">//it的类型是std::vector&lt;int&gt;::iterator</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; *it;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2020年9月"><a href="#2020年9月" class="headerlink" title="2020年9月"></a>2020年9月</h1><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> b = [](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x *= <span class="number">2</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = [](<span class="keyword">int</span> x)&#123;<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;&#125;(<span class="number">123</span>);<span class="comment">//函数体后的123也可传递参数x</span></span><br></pre></td></tr></table></figure>

<p>一般是以上形式: </p>
<ul>
<li>方括号[]开始, 用于捕捉外部参数变量;</li>
<li>圆括号()类似函数体的输入参数</li>
<li>花括号{} 是函数主体</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Int x;</span><br><span class="line"><span class="keyword">auto</span> c = [x]()&#123;<span class="keyword">return</span> x += <span class="number">3</span>;&#125;; <span class="comment">//复制传值,不会改变外部变量x的值</span></span><br><span class="line"><span class="keyword">auto</span> c = [&amp;x]()&#123;<span class="keyword">return</span> x += <span class="number">3</span>;&#125;; <span class="comment">//引用传递,可改变</span></span><br><span class="line"><span class="keyword">auto</span> c = [=]()&#123;<span class="keyword">return</span> x += <span class="number">3</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = [&amp;]()&#123;<span class="keyword">return</span> x += <span class="number">3</span>;&#125;; <span class="comment">//隐形传递, =表示值传递,&amp;表示引用</span></span><br></pre></td></tr></table></figure>

<p>完全格式:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> d = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">return</span> a+b;&#125;();<span class="comment">// -&gt;后表示函数体的返回值</span></span><br></pre></td></tr></table></figure>

<h2 id="std-transform"><a href="#std-transform" class="headerlink" title="std::transform"></a>std::transform</h2><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>sizeof(short) &lt; sizeof(int) &lt; sizeof(long),</p>
<p>short 是2字节，16位；int是32位，4字节；long在32位计算器中也是4字节。</p>
<p>C++中用INT_MAX和INT_MIN可以分别代表int型上下限，（-2^31,2^31-1)</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cloud-&gt; points.swap(filtered_points);</span><br></pre></td></tr></table></figure>

<h2 id="运算符重载-operator"><a href="#运算符重载-operator" class="headerlink" title="运算符重载 operator="></a>运算符重载 operator=</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IntCell &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> IntCell &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">        *membervalue  = *rhs.membervalue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在拷贝复制自定义对象的时候, <code>myclass a = b;</code>, 等号<code>=</code>的运算逻辑需要重载, 因此引入<code>operator=</code>. 应当将二者一起看做一个函数, 就方便理解了. </p>
<h1 id="2020年10月"><a href="#2020年10月" class="headerlink" title="2020年10月"></a>2020年10月</h1><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>参考链接: <a href="https://www.runoob.com/w3cnote/cpp-static-usage.html">https://www.runoob.com/w3cnote/cpp-static-usage.html</a></p>
<h3 id="静态声明"><a href="#静态声明" class="headerlink" title="静态声明"></a>静态声明</h3><p>将变量存放在<strong>静态内存</strong>中,必须在程序一开始就存在(被初始化),并在程序结束后自动销毁. 不能在函数内被分配空间和初始化.</p>
<blockquote>
<p>这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main() 函数前的全局数据声明和定义处</p>
</blockquote>
<p>早期使用static声明变量, 使得其在整个文件中都有效, 如今已经被命名空间取代.</p>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><ul>
<li><p>静态成员变量或静态成员函数是面向这一大类的, 而非具体实例. 比如人这一个class, 其平均年龄或者寿命属性是针对这一类人, 而不像名字年龄这种针对个体的, 可定义为static. 它能被所有对象共享.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">avgLife</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>
</li>
<li><p>可通过类的对象,引用,指针访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> old = human::avgLife();</span><br><span class="line">human a1;</span><br><span class="line">human * a2 = &amp;a1;</span><br><span class="line">old = a1.avgLife();</span><br><span class="line">old = a2-&gt;avgLife();</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员函数可直接调用静态成员</p>
</li>
<li><p>静态成员函数不能调用非静态成员，内部实现不能用this指针，也不能和仅访问函数const一起使用</p>
</li>
</ul>
<h2 id="多态-vitual-override-final"><a href="#多态-vitual-override-final" class="headerlink" title="多态 vitual/override/final"></a>多态 vitual/override/final</h2><p><strong>vitual</strong>: 定义33333虚函数, 允许不同的派生类使用相同名字的函数进行分别不同的实现.</p>
<p><strong>vitual =0</strong>有时候基类并不能定义具体的对象实例(比如动物), 可在基类中规定好纯虚函数接口,给子类分别去实现.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vitual <span class="keyword">int</span> <span class="title">fun</span><span class="params">(member_a, menber_b)</span><span class="keyword">const</span> </span>= <span class="number">0</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote>
<p>C++多态(<strong>polymorphism</strong>)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(<strong>override</strong>)，或者称为重写。</p>
<p>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，<strong>动态绑定</strong>。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。<em>如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。</em></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcC</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">funcD</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// compiler error: DerivedClass::funcB() does not </span></span><br><span class="line">                  <span class="comment">// override BaseClass::funcB() const</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcC</span><span class="params">( <span class="keyword">double</span> = <span class="number">0.0</span> )</span> <span class="keyword">override</span></span>; <span class="comment">// compiler error: </span></span><br><span class="line">                         <span class="comment">// DerivedClass::funcC(double) does not </span></span><br><span class="line">                         <span class="comment">// override BaseClass::funcC(int)</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">funcD</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// compiler error: DerivedClass::funcD() does not </span></span><br><span class="line">              <span class="comment">// override the non-virtual BaseClass::funcD()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>finanl</strong>表示后续派生类的虚函数不能再覆盖了.</p>
<h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p><strong>静态内存</strong>:存放static对象和类的static成员,以及定义在函数体外部的变量. 在使用之前自动分配,在程序结束时候自动销毁.</p>
<p><strong>栈</strong>: 保存定义在函数内的非static对象, 仅存在于该程序块运行的生命周期中</p>
<p><strong>堆</strong>: 用来储存动态分配的对象, 即动态对象的生存期由程序自己控制. 传统使用<code>new/delete</code>分配和销毁内存. 因此很容易造成内存泄露和引用非法内存的指针.所以引入更容易和安全的只能指针: <code>shared_ptr</code>, <code>unique_ptr</code>,``weak_ptr`</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个指针指向同一个对象地址,每次被引用都增加一个引用计数,当该引用计数清零时候调出析构函数释放该动态内存.  <code>p1.use_count()</code>,返回该智能指针的引用计数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; sp1;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make_shared函数,尖括号是返回值类型,圆括号为类的构造函数的参数</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">auto</span> p1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>。。。。。</p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector</title>
    <url>/2019/12/19/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/Vector/</url>
    <content><![CDATA[<p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">学习教材</a><br>学习要及时总结</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">vector</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //包含sort函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>,M=<span class="number">6</span>;</span><br><span class="line">    <span class="comment">//一维向量</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">obj</span><span class="params">(N)</span></span>;<span class="comment">//int 类型，obj变量名，N数据尺寸</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">6</span>,<span class="number">0</span>)</span></span>; <span class="comment">//数据尺寸为6个，都初始化为0</span></span><br><span class="line">    <span class="comment">//二位向量</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">obj2</span><span class="params">(N,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M))</span></span>;<span class="comment">//注意中间有个空格</span></span><br><span class="line">    obj2[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据增减</span></span><br><span class="line">    obj.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        obj.push_back(i);  <span class="comment">//在末尾添加数据i</span></span><br><span class="line">        obj.pop_back(); <span class="comment">//在末尾移除数据 </span></span><br><span class="line">    &#125; </span><br><span class="line">    obj.clear();<span class="comment">//清除所有数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    sort(obj.begain(),obj.end());<span class="comment">//从小到大排序</span></span><br><span class="line">    reverse(obj.begain(),obj.end());<span class="comment">//从大到小排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//创建迭代器对象访问向量地址</span></span><br><span class="line">    <span class="keyword">for</span>(it=obj.begain();it!=obj.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/09/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><img src="/2020/09/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20200904091254966.png" alt="image-20200904091254966" style="zoom:80%;">

<p>二叉树每个节点都有左右子树，利用递归关系：当前树深度=max(两子树深度最大值）+ 1.</p>
<p>递归初始化：空节点深度为空</p>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><img src="/2020/09/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20200904092120931.png" alt="image-20200904092120931" style="zoom:80%;">

<p>左子树的所有节点值都比当前节点小，右节点都比当前节点大。利用limit.h找到树的最大最小值，LONG_MIN, LONG_MAX，设置上下界。左子树为MIN~当前val，右子树为当前val–MAX。</p>
<p>递归关系：若当前节点不在上下界内，返回false；否则，递归验证左右子树，返回他俩的与值。</p>
<p>递归初始化：若当前节点为空，返回true。</p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/09/10/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><img src="/2020/09/10/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200911214956202.png" alt="image-20200911214956202" style="zoom:150%;">

<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><img src="/2020/09/10/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200909193353682.png" alt="image-20200909193353682" style="zoom:80%;">

<p>斐波那契数列，可以递归/求通项/动态规划。</p>
<p>动态规划相当于从前往后推里，并只保留递推需要的值，即前两个数值，这样可以减小空间复杂度。</p>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>  注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票</p>
</blockquote>
<p>一次遍历或动态规划。动态规划即维护一个dp[i]列表，保存每一天的最大利润。而一次遍历相当于前者的优化，只保留最低价格，并比较当前卖出的利润是否大于最大利润。</p>
<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</span><br></pre></td></tr></table></figure>

<p>动态规划。 每个dp[i]中保存dp[i-1]与当前元素的和，如果dp[i-1]为负数，则不加上这个值。dp中最大的值就是最大子序和。</p>
<p><code>dp[i] = max(dp[i-1], nums[i]);</code></p>
<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><blockquote>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<p>自上而下，动态规划。n所房屋的最高金额等于考虑最后一所房屋要不要偷，若不进去，则与偷前n-1所房屋一致；若进去偷，则与偷前n-2所房屋的最高金额相关。即：</p>
<p><code>dp[i] = max(dp[i-1], dp[i-2]+nums[i];</code></p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2020/09/20/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="字符数组Char"><a href="#字符数组Char" class="headerlink" title="字符数组Char"></a>字符数组Char</h2><p>初始化：<code>char s[8] = &quot;China&quot;</code>最后一位以<code>‘/0’</code>保存结束标记符。</p>
<p>输入：<code>cin&gt;&gt;s</code>, 空格/Tab/回车都是输入字符串的结束符；<code>gets(s)</code>, 只有回车才结束. 自动补全’\0’. </p>
<p>输出: <code>cout&lt;&lt;s</code>, <code>puts(s)</code></p>
<p>赋值: <code>strcpy(s,&quot;China&quot;)</code></p>
<p>头文件: <code>#include &quot;stdio.h&quot;</code>包含了上述gets/puts函数;</p>
<p>​            <code>&quot;string.h&quot;</code>包含了字符串处理函数. <code>strlen(s);strcmp(s1,s2);strcpy(s,&quot;china&quot;)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s2[<span class="number">100</span>];</span><br><span class="line">    gets(s2);</span><br><span class="line">    <span class="built_in">puts</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="标准库–字符串string"><a href="#标准库–字符串string" class="headerlink" title="标准库–字符串string"></a>标准库–字符串string</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;china&quot;</span>;		<span class="comment">// 初始化,赋值构造函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;China&quot;</span>)</span></span>;		<span class="comment">// 直接构造函数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s)&#123;		<span class="comment">// 输入,以空格/tab/回车为结束符</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,s))	<span class="comment">//输入, getline函数相当于符号&quot;&gt;&gt;&quot;,参数为数据流cin,和保存的字符串变量</span></span><br><span class="line">        <span class="keyword">if</span>(!s.empty()) <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空才输出s</span></span><br><span class="line">    s1 = s1+<span class="string">&quot;NO1&quot;</span>;</span><br><span class="line">    s2 = s1 + s2 ;			<span class="comment">//字符串连接</span></span><br><span class="line">    <span class="keyword">int</span> l = s.size();		<span class="comment">//返回长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(ch))&#123;</span><br><span class="line">                s2 += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left ++;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/2020/09/11/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>经典排序算法</title>
    <url>/2020/09/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/">优秀连接</a></p>
<p><img src="/2020/09/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F.png" alt="排序"></p>
<h2 id="经典排序算法"><a href="#经典排序算法" class="headerlink" title="经典排序算法"></a>经典排序算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">56</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">65</span>,<span class="number">85</span>,<span class="number">43</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n =<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//冒泡排序；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">                &#123;<span class="keyword">int</span> temp = a[j];a[j] = a[j+<span class="number">1</span>];a[j+<span class="number">1</span>] = temp;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];a[j] = a[i];a[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; temp &lt; a[j])&#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><img src="/2020/09/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/image-20200904105656076.png" alt="image-20200904105656076" style="zoom:80%;">

<p>双指针。copy一个nums1内存空间res保存结果。</p>
<p>p&lt;q, 则p值放入res，p++;反之同。退出循环的条件，指针没到末尾</p>
<p>注意：p,q长度不一致，把未排完的依次放入res末尾。</p>
<h3 id="第一个错误版本"><a href="#第一个错误版本" class="headerlink" title="第一个错误版本"></a>第一个错误版本</h3><img src="/2020/09/03/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/image-20200909183836225.png" alt="image-20200909183836225" style="zoom:80%;">

<p>二分法查找。复杂度o(logn)</p>
<p>初始化边界：left为1，right为n. </p>
<p>判断中间值：isBadVersion(left+(right-left)/2)</p>
<p>退出循环的条件： left &lt; right</p>
]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2020/09/15/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一个函数调用他自己，就叫递归。</p>
<p>栈，每个函数运行时都会有的一篇存储空间。每个函数调用时都会增加一层栈。</p>
<p>搞清楚递归的<strong>终止条件</strong>，&amp;&amp;递归的<strong>转移关系</strong>。</p>
<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><h2 id="NQueen"><a href="#NQueen" class="headerlink" title="NQueen"></a>NQueen</h2><h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2>]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/06/30/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/CXX/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="设置哑结点"><a href="#设置哑结点" class="headerlink" title="设置哑结点"></a>设置哑结点</h1><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="comment">//设置哑结点</span></span><br><span class="line">        ListNode *dummynode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        <span class="comment">//求得链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;next)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//工作指针归原点，将指针移动到目标前一个节点</span></span><br><span class="line">        node = dummynode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">           node = node-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummynode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
